
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Classes
 * 
 */
export type Classes = $Result.DefaultSelection<Prisma.$ClassesPayload>
/**
 * Model Students
 * 
 */
export type Students = $Result.DefaultSelection<Prisma.$StudentsPayload>
/**
 * Model Registrations
 * 
 */
export type Registrations = $Result.DefaultSelection<Prisma.$RegistrationsPayload>
/**
 * Model Teachers
 * 
 */
export type Teachers = $Result.DefaultSelection<Prisma.$TeachersPayload>
/**
 * Model TeacherWorkHours
 * 
 */
export type TeacherWorkHours = $Result.DefaultSelection<Prisma.$TeacherWorkHoursPayload>
/**
 * Model Lessons
 * 
 */
export type Lessons = $Result.DefaultSelection<Prisma.$LessonsPayload>
/**
 * Model Subjects
 * 
 */
export type Subjects = $Result.DefaultSelection<Prisma.$SubjectsPayload>
/**
 * Model Notes
 * 
 */
export type Notes = $Result.DefaultSelection<Prisma.$NotesPayload>
/**
 * Model Parents
 * 
 */
export type Parents = $Result.DefaultSelection<Prisma.$ParentsPayload>
/**
 * Model StudentParents
 * 
 */
export type StudentParents = $Result.DefaultSelection<Prisma.$StudentParentsPayload>
/**
 * Model Payments
 * 
 */
export type Payments = $Result.DefaultSelection<Prisma.$PaymentsPayload>
/**
 * Model SingleFee
 * 
 */
export type SingleFee = $Result.DefaultSelection<Prisma.$SingleFeePayload>
/**
 * Model FeeTemplate
 * 
 */
export type FeeTemplate = $Result.DefaultSelection<Prisma.$FeeTemplatePayload>
/**
 * Model Attendances
 * 
 */
export type Attendances = $Result.DefaultSelection<Prisma.$AttendancesPayload>
/**
 * Model Employees
 * 
 */
export type Employees = $Result.DefaultSelection<Prisma.$EmployeesPayload>
/**
 * Model SalaryPayments
 * 
 */
export type SalaryPayments = $Result.DefaultSelection<Prisma.$SalaryPaymentsPayload>
/**
 * Model Schedules
 * 
 */
export type Schedules = $Result.DefaultSelection<Prisma.$SchedulesPayload>
/**
 * Model FinancialCategory
 * 
 */
export type FinancialCategory = $Result.DefaultSelection<Prisma.$FinancialCategoryPayload>
/**
 * Model FinancialTransaction
 * 
 */
export type FinancialTransaction = $Result.DefaultSelection<Prisma.$FinancialTransactionPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model FinancialReport
 * 
 */
export type FinancialReport = $Result.DefaultSelection<Prisma.$FinancialReportPayload>
/**
 * Model DispatchRule
 * 
 */
export type DispatchRule = $Result.DefaultSelection<Prisma.$DispatchRulePayload>
/**
 * Model DispatchRuleDetail
 * 
 */
export type DispatchRuleDetail = $Result.DefaultSelection<Prisma.$DispatchRuleDetailPayload>
/**
 * Model Events
 * 
 */
export type Events = $Result.DefaultSelection<Prisma.$EventsPayload>
/**
 * Model EmployeeAttendance
 * 
 */
export type EmployeeAttendance = $Result.DefaultSelection<Prisma.$EmployeeAttendancePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Settings
 * const settings = await prisma.settings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Settings
   * const settings = await prisma.settings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classes`: Exposes CRUD operations for the **Classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classes.findMany()
    * ```
    */
  get classes(): Prisma.ClassesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **Students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.StudentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registrations`: Exposes CRUD operations for the **Registrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Registrations
    * const registrations = await prisma.registrations.findMany()
    * ```
    */
  get registrations(): Prisma.RegistrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teachers`: Exposes CRUD operations for the **Teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teachers.findMany()
    * ```
    */
  get teachers(): Prisma.TeachersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherWorkHours`: Exposes CRUD operations for the **TeacherWorkHours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherWorkHours
    * const teacherWorkHours = await prisma.teacherWorkHours.findMany()
    * ```
    */
  get teacherWorkHours(): Prisma.TeacherWorkHoursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessons`: Exposes CRUD operations for the **Lessons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lessons.findMany()
    * ```
    */
  get lessons(): Prisma.LessonsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subjects`: Exposes CRUD operations for the **Subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subjects.findMany()
    * ```
    */
  get subjects(): Prisma.SubjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **Notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.NotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parents`: Exposes CRUD operations for the **Parents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parents.findMany()
    * ```
    */
  get parents(): Prisma.ParentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentParents`: Exposes CRUD operations for the **StudentParents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParents
    * const studentParents = await prisma.studentParents.findMany()
    * ```
    */
  get studentParents(): Prisma.StudentParentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.PaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.singleFee`: Exposes CRUD operations for the **SingleFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SingleFees
    * const singleFees = await prisma.singleFee.findMany()
    * ```
    */
  get singleFee(): Prisma.SingleFeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeTemplate`: Exposes CRUD operations for the **FeeTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeTemplates
    * const feeTemplates = await prisma.feeTemplate.findMany()
    * ```
    */
  get feeTemplate(): Prisma.FeeTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendances`: Exposes CRUD operations for the **Attendances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendances.findMany()
    * ```
    */
  get attendances(): Prisma.AttendancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **Employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.EmployeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryPayments`: Exposes CRUD operations for the **SalaryPayments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryPayments
    * const salaryPayments = await prisma.salaryPayments.findMany()
    * ```
    */
  get salaryPayments(): Prisma.SalaryPaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedules`: Exposes CRUD operations for the **Schedules** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedules.findMany()
    * ```
    */
  get schedules(): Prisma.SchedulesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialCategory`: Exposes CRUD operations for the **FinancialCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialCategories
    * const financialCategories = await prisma.financialCategory.findMany()
    * ```
    */
  get financialCategory(): Prisma.FinancialCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialTransaction`: Exposes CRUD operations for the **FinancialTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialTransactions
    * const financialTransactions = await prisma.financialTransaction.findMany()
    * ```
    */
  get financialTransaction(): Prisma.FinancialTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialReport`: Exposes CRUD operations for the **FinancialReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialReports
    * const financialReports = await prisma.financialReport.findMany()
    * ```
    */
  get financialReport(): Prisma.FinancialReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispatchRule`: Exposes CRUD operations for the **DispatchRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DispatchRules
    * const dispatchRules = await prisma.dispatchRule.findMany()
    * ```
    */
  get dispatchRule(): Prisma.DispatchRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispatchRuleDetail`: Exposes CRUD operations for the **DispatchRuleDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DispatchRuleDetails
    * const dispatchRuleDetails = await prisma.dispatchRuleDetail.findMany()
    * ```
    */
  get dispatchRuleDetail(): Prisma.DispatchRuleDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeAttendance`: Exposes CRUD operations for the **EmployeeAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeAttendances
    * const employeeAttendances = await prisma.employeeAttendance.findMany()
    * ```
    */
  get employeeAttendance(): Prisma.EmployeeAttendanceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Settings: 'Settings',
    Classes: 'Classes',
    Students: 'Students',
    Registrations: 'Registrations',
    Teachers: 'Teachers',
    TeacherWorkHours: 'TeacherWorkHours',
    Lessons: 'Lessons',
    Subjects: 'Subjects',
    Notes: 'Notes',
    Parents: 'Parents',
    StudentParents: 'StudentParents',
    Payments: 'Payments',
    SingleFee: 'SingleFee',
    FeeTemplate: 'FeeTemplate',
    Attendances: 'Attendances',
    Employees: 'Employees',
    SalaryPayments: 'SalaryPayments',
    Schedules: 'Schedules',
    FinancialCategory: 'FinancialCategory',
    FinancialTransaction: 'FinancialTransaction',
    Budget: 'Budget',
    FinancialReport: 'FinancialReport',
    DispatchRule: 'DispatchRule',
    DispatchRuleDetail: 'DispatchRuleDetail',
    Events: 'Events',
    EmployeeAttendance: 'EmployeeAttendance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "settings" | "classes" | "students" | "registrations" | "teachers" | "teacherWorkHours" | "lessons" | "subjects" | "notes" | "parents" | "studentParents" | "payments" | "singleFee" | "feeTemplate" | "attendances" | "employees" | "salaryPayments" | "schedules" | "financialCategory" | "financialTransaction" | "budget" | "financialReport" | "dispatchRule" | "dispatchRuleDetail" | "events" | "employeeAttendance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Classes: {
        payload: Prisma.$ClassesPayload<ExtArgs>
        fields: Prisma.ClassesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          findFirst: {
            args: Prisma.ClassesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          findMany: {
            args: Prisma.ClassesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>[]
          }
          create: {
            args: Prisma.ClassesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          createMany: {
            args: Prisma.ClassesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>[]
          }
          delete: {
            args: Prisma.ClassesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          update: {
            args: Prisma.ClassesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          deleteMany: {
            args: Prisma.ClassesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>[]
          }
          upsert: {
            args: Prisma.ClassesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          aggregate: {
            args: Prisma.ClassesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasses>
          }
          groupBy: {
            args: Prisma.ClassesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassesCountArgs<ExtArgs>
            result: $Utils.Optional<ClassesCountAggregateOutputType> | number
          }
        }
      }
      Students: {
        payload: Prisma.$StudentsPayload<ExtArgs>
        fields: Prisma.StudentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findFirst: {
            args: Prisma.StudentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findMany: {
            args: Prisma.StudentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          create: {
            args: Prisma.StudentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          createMany: {
            args: Prisma.StudentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          delete: {
            args: Prisma.StudentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          update: {
            args: Prisma.StudentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          deleteMany: {
            args: Prisma.StudentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          upsert: {
            args: Prisma.StudentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.StudentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      Registrations: {
        payload: Prisma.$RegistrationsPayload<ExtArgs>
        fields: Prisma.RegistrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegistrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegistrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          findFirst: {
            args: Prisma.RegistrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegistrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          findMany: {
            args: Prisma.RegistrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>[]
          }
          create: {
            args: Prisma.RegistrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          createMany: {
            args: Prisma.RegistrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegistrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>[]
          }
          delete: {
            args: Prisma.RegistrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          update: {
            args: Prisma.RegistrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          deleteMany: {
            args: Prisma.RegistrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegistrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegistrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>[]
          }
          upsert: {
            args: Prisma.RegistrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          aggregate: {
            args: Prisma.RegistrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegistrations>
          }
          groupBy: {
            args: Prisma.RegistrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegistrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegistrationsCountArgs<ExtArgs>
            result: $Utils.Optional<RegistrationsCountAggregateOutputType> | number
          }
        }
      }
      Teachers: {
        payload: Prisma.$TeachersPayload<ExtArgs>
        fields: Prisma.TeachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeachersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeachersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          findFirst: {
            args: Prisma.TeachersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeachersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          findMany: {
            args: Prisma.TeachersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>[]
          }
          create: {
            args: Prisma.TeachersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          createMany: {
            args: Prisma.TeachersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeachersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>[]
          }
          delete: {
            args: Prisma.TeachersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          update: {
            args: Prisma.TeachersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          deleteMany: {
            args: Prisma.TeachersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeachersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeachersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>[]
          }
          upsert: {
            args: Prisma.TeachersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          aggregate: {
            args: Prisma.TeachersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachers>
          }
          groupBy: {
            args: Prisma.TeachersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeachersCountArgs<ExtArgs>
            result: $Utils.Optional<TeachersCountAggregateOutputType> | number
          }
        }
      }
      TeacherWorkHours: {
        payload: Prisma.$TeacherWorkHoursPayload<ExtArgs>
        fields: Prisma.TeacherWorkHoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherWorkHoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherWorkHoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          findFirst: {
            args: Prisma.TeacherWorkHoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherWorkHoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          findMany: {
            args: Prisma.TeacherWorkHoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>[]
          }
          create: {
            args: Prisma.TeacherWorkHoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          createMany: {
            args: Prisma.TeacherWorkHoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherWorkHoursCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>[]
          }
          delete: {
            args: Prisma.TeacherWorkHoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          update: {
            args: Prisma.TeacherWorkHoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          deleteMany: {
            args: Prisma.TeacherWorkHoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherWorkHoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherWorkHoursUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>[]
          }
          upsert: {
            args: Prisma.TeacherWorkHoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          aggregate: {
            args: Prisma.TeacherWorkHoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherWorkHours>
          }
          groupBy: {
            args: Prisma.TeacherWorkHoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherWorkHoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherWorkHoursCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherWorkHoursCountAggregateOutputType> | number
          }
        }
      }
      Lessons: {
        payload: Prisma.$LessonsPayload<ExtArgs>
        fields: Prisma.LessonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          findFirst: {
            args: Prisma.LessonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          findMany: {
            args: Prisma.LessonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          create: {
            args: Prisma.LessonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          createMany: {
            args: Prisma.LessonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          delete: {
            args: Prisma.LessonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          update: {
            args: Prisma.LessonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          deleteMany: {
            args: Prisma.LessonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          upsert: {
            args: Prisma.LessonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          aggregate: {
            args: Prisma.LessonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessons>
          }
          groupBy: {
            args: Prisma.LessonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonsCountArgs<ExtArgs>
            result: $Utils.Optional<LessonsCountAggregateOutputType> | number
          }
        }
      }
      Subjects: {
        payload: Prisma.$SubjectsPayload<ExtArgs>
        fields: Prisma.SubjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          findFirst: {
            args: Prisma.SubjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          findMany: {
            args: Prisma.SubjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>[]
          }
          create: {
            args: Prisma.SubjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          createMany: {
            args: Prisma.SubjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>[]
          }
          delete: {
            args: Prisma.SubjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          update: {
            args: Prisma.SubjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          deleteMany: {
            args: Prisma.SubjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>[]
          }
          upsert: {
            args: Prisma.SubjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          aggregate: {
            args: Prisma.SubjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjects>
          }
          groupBy: {
            args: Prisma.SubjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectsCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectsCountAggregateOutputType> | number
          }
        }
      }
      Notes: {
        payload: Prisma.$NotesPayload<ExtArgs>
        fields: Prisma.NotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          findFirst: {
            args: Prisma.NotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          findMany: {
            args: Prisma.NotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          create: {
            args: Prisma.NotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          createMany: {
            args: Prisma.NotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          delete: {
            args: Prisma.NotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          update: {
            args: Prisma.NotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          deleteMany: {
            args: Prisma.NotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          upsert: {
            args: Prisma.NotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          aggregate: {
            args: Prisma.NotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotes>
          }
          groupBy: {
            args: Prisma.NotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotesCountArgs<ExtArgs>
            result: $Utils.Optional<NotesCountAggregateOutputType> | number
          }
        }
      }
      Parents: {
        payload: Prisma.$ParentsPayload<ExtArgs>
        fields: Prisma.ParentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          findFirst: {
            args: Prisma.ParentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          findMany: {
            args: Prisma.ParentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>[]
          }
          create: {
            args: Prisma.ParentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          createMany: {
            args: Prisma.ParentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>[]
          }
          delete: {
            args: Prisma.ParentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          update: {
            args: Prisma.ParentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          deleteMany: {
            args: Prisma.ParentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>[]
          }
          upsert: {
            args: Prisma.ParentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          aggregate: {
            args: Prisma.ParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParents>
          }
          groupBy: {
            args: Prisma.ParentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentsCountArgs<ExtArgs>
            result: $Utils.Optional<ParentsCountAggregateOutputType> | number
          }
        }
      }
      StudentParents: {
        payload: Prisma.$StudentParentsPayload<ExtArgs>
        fields: Prisma.StudentParentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentParentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentParentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          findFirst: {
            args: Prisma.StudentParentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentParentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          findMany: {
            args: Prisma.StudentParentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>[]
          }
          create: {
            args: Prisma.StudentParentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          createMany: {
            args: Prisma.StudentParentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentParentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>[]
          }
          delete: {
            args: Prisma.StudentParentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          update: {
            args: Prisma.StudentParentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          deleteMany: {
            args: Prisma.StudentParentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentParentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentParentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>[]
          }
          upsert: {
            args: Prisma.StudentParentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          aggregate: {
            args: Prisma.StudentParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentParents>
          }
          groupBy: {
            args: Prisma.StudentParentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentParentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentParentsCountAggregateOutputType> | number
          }
        }
      }
      Payments: {
        payload: Prisma.$PaymentsPayload<ExtArgs>
        fields: Prisma.PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findFirst: {
            args: Prisma.PaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findMany: {
            args: Prisma.PaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          create: {
            args: Prisma.PaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          createMany: {
            args: Prisma.PaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          delete: {
            args: Prisma.PaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          update: {
            args: Prisma.PaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.PaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      SingleFee: {
        payload: Prisma.$SingleFeePayload<ExtArgs>
        fields: Prisma.SingleFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SingleFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SingleFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>
          }
          findFirst: {
            args: Prisma.SingleFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SingleFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>
          }
          findMany: {
            args: Prisma.SingleFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>[]
          }
          create: {
            args: Prisma.SingleFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>
          }
          createMany: {
            args: Prisma.SingleFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SingleFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>[]
          }
          delete: {
            args: Prisma.SingleFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>
          }
          update: {
            args: Prisma.SingleFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>
          }
          deleteMany: {
            args: Prisma.SingleFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SingleFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SingleFeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>[]
          }
          upsert: {
            args: Prisma.SingleFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleFeePayload>
          }
          aggregate: {
            args: Prisma.SingleFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSingleFee>
          }
          groupBy: {
            args: Prisma.SingleFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SingleFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SingleFeeCountArgs<ExtArgs>
            result: $Utils.Optional<SingleFeeCountAggregateOutputType> | number
          }
        }
      }
      FeeTemplate: {
        payload: Prisma.$FeeTemplatePayload<ExtArgs>
        fields: Prisma.FeeTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>
          }
          findFirst: {
            args: Prisma.FeeTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>
          }
          findMany: {
            args: Prisma.FeeTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>[]
          }
          create: {
            args: Prisma.FeeTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>
          }
          createMany: {
            args: Prisma.FeeTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>[]
          }
          delete: {
            args: Prisma.FeeTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>
          }
          update: {
            args: Prisma.FeeTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>
          }
          deleteMany: {
            args: Prisma.FeeTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>[]
          }
          upsert: {
            args: Prisma.FeeTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeTemplatePayload>
          }
          aggregate: {
            args: Prisma.FeeTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeTemplate>
          }
          groupBy: {
            args: Prisma.FeeTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<FeeTemplateCountAggregateOutputType> | number
          }
        }
      }
      Attendances: {
        payload: Prisma.$AttendancesPayload<ExtArgs>
        fields: Prisma.AttendancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          findFirst: {
            args: Prisma.AttendancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          findMany: {
            args: Prisma.AttendancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>[]
          }
          create: {
            args: Prisma.AttendancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          createMany: {
            args: Prisma.AttendancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendancesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>[]
          }
          delete: {
            args: Prisma.AttendancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          update: {
            args: Prisma.AttendancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          deleteMany: {
            args: Prisma.AttendancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendancesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>[]
          }
          upsert: {
            args: Prisma.AttendancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          aggregate: {
            args: Prisma.AttendancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendances>
          }
          groupBy: {
            args: Prisma.AttendancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendancesCountArgs<ExtArgs>
            result: $Utils.Optional<AttendancesCountAggregateOutputType> | number
          }
        }
      }
      Employees: {
        payload: Prisma.$EmployeesPayload<ExtArgs>
        fields: Prisma.EmployeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findFirst: {
            args: Prisma.EmployeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findMany: {
            args: Prisma.EmployeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          create: {
            args: Prisma.EmployeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          createMany: {
            args: Prisma.EmployeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          delete: {
            args: Prisma.EmployeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          update: {
            args: Prisma.EmployeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          upsert: {
            args: Prisma.EmployeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployees>
          }
          groupBy: {
            args: Prisma.EmployeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesCountAggregateOutputType> | number
          }
        }
      }
      SalaryPayments: {
        payload: Prisma.$SalaryPaymentsPayload<ExtArgs>
        fields: Prisma.SalaryPaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryPaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryPaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          findFirst: {
            args: Prisma.SalaryPaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryPaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          findMany: {
            args: Prisma.SalaryPaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>[]
          }
          create: {
            args: Prisma.SalaryPaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          createMany: {
            args: Prisma.SalaryPaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryPaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>[]
          }
          delete: {
            args: Prisma.SalaryPaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          update: {
            args: Prisma.SalaryPaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          deleteMany: {
            args: Prisma.SalaryPaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryPaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryPaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>[]
          }
          upsert: {
            args: Prisma.SalaryPaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          aggregate: {
            args: Prisma.SalaryPaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryPayments>
          }
          groupBy: {
            args: Prisma.SalaryPaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryPaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentsCountAggregateOutputType> | number
          }
        }
      }
      Schedules: {
        payload: Prisma.$SchedulesPayload<ExtArgs>
        fields: Prisma.SchedulesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchedulesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchedulesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          findFirst: {
            args: Prisma.SchedulesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchedulesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          findMany: {
            args: Prisma.SchedulesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>[]
          }
          create: {
            args: Prisma.SchedulesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          createMany: {
            args: Prisma.SchedulesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchedulesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>[]
          }
          delete: {
            args: Prisma.SchedulesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          update: {
            args: Prisma.SchedulesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          deleteMany: {
            args: Prisma.SchedulesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchedulesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchedulesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>[]
          }
          upsert: {
            args: Prisma.SchedulesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          aggregate: {
            args: Prisma.SchedulesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedules>
          }
          groupBy: {
            args: Prisma.SchedulesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchedulesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchedulesCountArgs<ExtArgs>
            result: $Utils.Optional<SchedulesCountAggregateOutputType> | number
          }
        }
      }
      FinancialCategory: {
        payload: Prisma.$FinancialCategoryPayload<ExtArgs>
        fields: Prisma.FinancialCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>
          }
          findFirst: {
            args: Prisma.FinancialCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>
          }
          findMany: {
            args: Prisma.FinancialCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>[]
          }
          create: {
            args: Prisma.FinancialCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>
          }
          createMany: {
            args: Prisma.FinancialCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>[]
          }
          delete: {
            args: Prisma.FinancialCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>
          }
          update: {
            args: Prisma.FinancialCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>
          }
          deleteMany: {
            args: Prisma.FinancialCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>[]
          }
          upsert: {
            args: Prisma.FinancialCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialCategoryPayload>
          }
          aggregate: {
            args: Prisma.FinancialCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialCategory>
          }
          groupBy: {
            args: Prisma.FinancialCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialCategoryCountAggregateOutputType> | number
          }
        }
      }
      FinancialTransaction: {
        payload: Prisma.$FinancialTransactionPayload<ExtArgs>
        fields: Prisma.FinancialTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          findFirst: {
            args: Prisma.FinancialTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          findMany: {
            args: Prisma.FinancialTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
          }
          create: {
            args: Prisma.FinancialTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          createMany: {
            args: Prisma.FinancialTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
          }
          delete: {
            args: Prisma.FinancialTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          update: {
            args: Prisma.FinancialTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          deleteMany: {
            args: Prisma.FinancialTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
          }
          upsert: {
            args: Prisma.FinancialTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          aggregate: {
            args: Prisma.FinancialTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialTransaction>
          }
          groupBy: {
            args: Prisma.FinancialTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialTransactionCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      FinancialReport: {
        payload: Prisma.$FinancialReportPayload<ExtArgs>
        fields: Prisma.FinancialReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>
          }
          findFirst: {
            args: Prisma.FinancialReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>
          }
          findMany: {
            args: Prisma.FinancialReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>[]
          }
          create: {
            args: Prisma.FinancialReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>
          }
          createMany: {
            args: Prisma.FinancialReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>[]
          }
          delete: {
            args: Prisma.FinancialReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>
          }
          update: {
            args: Prisma.FinancialReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>
          }
          deleteMany: {
            args: Prisma.FinancialReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>[]
          }
          upsert: {
            args: Prisma.FinancialReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialReportPayload>
          }
          aggregate: {
            args: Prisma.FinancialReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialReport>
          }
          groupBy: {
            args: Prisma.FinancialReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialReportCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialReportCountAggregateOutputType> | number
          }
        }
      }
      DispatchRule: {
        payload: Prisma.$DispatchRulePayload<ExtArgs>
        fields: Prisma.DispatchRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispatchRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispatchRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>
          }
          findFirst: {
            args: Prisma.DispatchRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispatchRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>
          }
          findMany: {
            args: Prisma.DispatchRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>[]
          }
          create: {
            args: Prisma.DispatchRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>
          }
          createMany: {
            args: Prisma.DispatchRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispatchRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>[]
          }
          delete: {
            args: Prisma.DispatchRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>
          }
          update: {
            args: Prisma.DispatchRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>
          }
          deleteMany: {
            args: Prisma.DispatchRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispatchRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispatchRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>[]
          }
          upsert: {
            args: Prisma.DispatchRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRulePayload>
          }
          aggregate: {
            args: Prisma.DispatchRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispatchRule>
          }
          groupBy: {
            args: Prisma.DispatchRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispatchRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispatchRuleCountArgs<ExtArgs>
            result: $Utils.Optional<DispatchRuleCountAggregateOutputType> | number
          }
        }
      }
      DispatchRuleDetail: {
        payload: Prisma.$DispatchRuleDetailPayload<ExtArgs>
        fields: Prisma.DispatchRuleDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispatchRuleDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispatchRuleDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>
          }
          findFirst: {
            args: Prisma.DispatchRuleDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispatchRuleDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>
          }
          findMany: {
            args: Prisma.DispatchRuleDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>[]
          }
          create: {
            args: Prisma.DispatchRuleDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>
          }
          createMany: {
            args: Prisma.DispatchRuleDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispatchRuleDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>[]
          }
          delete: {
            args: Prisma.DispatchRuleDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>
          }
          update: {
            args: Prisma.DispatchRuleDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>
          }
          deleteMany: {
            args: Prisma.DispatchRuleDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispatchRuleDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispatchRuleDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>[]
          }
          upsert: {
            args: Prisma.DispatchRuleDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchRuleDetailPayload>
          }
          aggregate: {
            args: Prisma.DispatchRuleDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispatchRuleDetail>
          }
          groupBy: {
            args: Prisma.DispatchRuleDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispatchRuleDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispatchRuleDetailCountArgs<ExtArgs>
            result: $Utils.Optional<DispatchRuleDetailCountAggregateOutputType> | number
          }
        }
      }
      Events: {
        payload: Prisma.$EventsPayload<ExtArgs>
        fields: Prisma.EventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findFirst: {
            args: Prisma.EventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findMany: {
            args: Prisma.EventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          create: {
            args: Prisma.EventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          createMany: {
            args: Prisma.EventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          delete: {
            args: Prisma.EventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          update: {
            args: Prisma.EventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          deleteMany: {
            args: Prisma.EventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          upsert: {
            args: Prisma.EventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.EventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      EmployeeAttendance: {
        payload: Prisma.$EmployeeAttendancePayload<ExtArgs>
        fields: Prisma.EmployeeAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>
          }
          findFirst: {
            args: Prisma.EmployeeAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>
          }
          findMany: {
            args: Prisma.EmployeeAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>[]
          }
          create: {
            args: Prisma.EmployeeAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>
          }
          createMany: {
            args: Prisma.EmployeeAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>[]
          }
          delete: {
            args: Prisma.EmployeeAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>
          }
          update: {
            args: Prisma.EmployeeAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttendancePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeAttendance>
          }
          groupBy: {
            args: Prisma.EmployeeAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAttendanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    settings?: SettingsOmit
    classes?: ClassesOmit
    students?: StudentsOmit
    registrations?: RegistrationsOmit
    teachers?: TeachersOmit
    teacherWorkHours?: TeacherWorkHoursOmit
    lessons?: LessonsOmit
    subjects?: SubjectsOmit
    notes?: NotesOmit
    parents?: ParentsOmit
    studentParents?: StudentParentsOmit
    payments?: PaymentsOmit
    singleFee?: SingleFeeOmit
    feeTemplate?: FeeTemplateOmit
    attendances?: AttendancesOmit
    employees?: EmployeesOmit
    salaryPayments?: SalaryPaymentsOmit
    schedules?: SchedulesOmit
    financialCategory?: FinancialCategoryOmit
    financialTransaction?: FinancialTransactionOmit
    budget?: BudgetOmit
    financialReport?: FinancialReportOmit
    dispatchRule?: DispatchRuleOmit
    dispatchRuleDetail?: DispatchRuleDetailOmit
    events?: EventsOmit
    employeeAttendance?: EmployeeAttendanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClassesCountOutputType
   */

  export type ClassesCountOutputType = {
    lessons: number
    registrations: number
    subjects: number
    single_fees: number
    fee_templates: number
  }

  export type ClassesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | ClassesCountOutputTypeCountLessonsArgs
    registrations?: boolean | ClassesCountOutputTypeCountRegistrationsArgs
    subjects?: boolean | ClassesCountOutputTypeCountSubjectsArgs
    single_fees?: boolean | ClassesCountOutputTypeCountSingle_feesArgs
    fee_templates?: boolean | ClassesCountOutputTypeCountFee_templatesArgs
  }

  // Custom InputTypes
  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassesCountOutputType
     */
    select?: ClassesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistrationsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountSingle_feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SingleFeeWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountFee_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeTemplateWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    attendances: number
    notes: number
    registrations: number
    student_parents: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | StudentsCountOutputTypeCountAttendancesArgs
    notes?: boolean | StudentsCountOutputTypeCountNotesArgs
    registrations?: boolean | StudentsCountOutputTypeCountRegistrationsArgs
    student_parents?: boolean | StudentsCountOutputTypeCountStudent_parentsArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendancesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistrationsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentsWhereInput
  }


  /**
   * Count Type RegistrationsCountOutputType
   */

  export type RegistrationsCountOutputType = {
    payments: number
  }

  export type RegistrationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | RegistrationsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * RegistrationsCountOutputType without action
   */
  export type RegistrationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistrationsCountOutputType
     */
    select?: RegistrationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegistrationsCountOutputType without action
   */
  export type RegistrationsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Count Type TeachersCountOutputType
   */

  export type TeachersCountOutputType = {
    lessons: number
    workHours: number
    attendances: number
  }

  export type TeachersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | TeachersCountOutputTypeCountLessonsArgs
    workHours?: boolean | TeachersCountOutputTypeCountWorkHoursArgs
    attendances?: boolean | TeachersCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachersCountOutputType
     */
    select?: TeachersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountWorkHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkHoursWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAttendanceWhereInput
  }


  /**
   * Count Type LessonsCountOutputType
   */

  export type LessonsCountOutputType = {
    notes: number
    schedules: number
  }

  export type LessonsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | LessonsCountOutputTypeCountNotesArgs
    schedules?: boolean | LessonsCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonsCountOutputType
     */
    select?: LessonsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
  }

  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchedulesWhereInput
  }


  /**
   * Count Type SubjectsCountOutputType
   */

  export type SubjectsCountOutputType = {
    lessons: number
    workHours: number
  }

  export type SubjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | SubjectsCountOutputTypeCountLessonsArgs
    workHours?: boolean | SubjectsCountOutputTypeCountWorkHoursArgs
  }

  // Custom InputTypes
  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectsCountOutputType
     */
    select?: SubjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountWorkHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkHoursWhereInput
  }


  /**
   * Count Type ParentsCountOutputType
   */

  export type ParentsCountOutputType = {
    student_parents: number
  }

  export type ParentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_parents?: boolean | ParentsCountOutputTypeCountStudent_parentsArgs
  }

  // Custom InputTypes
  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentsCountOutputType
     */
    select?: ParentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeCountStudent_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentsWhereInput
  }


  /**
   * Count Type SingleFeeCountOutputType
   */

  export type SingleFeeCountOutputType = {
    payments: number
    dispatch_rules: number
  }

  export type SingleFeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SingleFeeCountOutputTypeCountPaymentsArgs
    dispatch_rules?: boolean | SingleFeeCountOutputTypeCountDispatch_rulesArgs
  }

  // Custom InputTypes
  /**
   * SingleFeeCountOutputType without action
   */
  export type SingleFeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFeeCountOutputType
     */
    select?: SingleFeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SingleFeeCountOutputType without action
   */
  export type SingleFeeCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * SingleFeeCountOutputType without action
   */
  export type SingleFeeCountOutputTypeCountDispatch_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchRuleWhereInput
  }


  /**
   * Count Type FeeTemplateCountOutputType
   */

  export type FeeTemplateCountOutputType = {
    payments: number
  }

  export type FeeTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | FeeTemplateCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * FeeTemplateCountOutputType without action
   */
  export type FeeTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplateCountOutputType
     */
    select?: FeeTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeTemplateCountOutputType without action
   */
  export type FeeTemplateCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Count Type EmployeesCountOutputType
   */

  export type EmployeesCountOutputType = {
    salary_payments: number
    attendances: number
  }

  export type EmployeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salary_payments?: boolean | EmployeesCountOutputTypeCountSalary_paymentsArgs
    attendances?: boolean | EmployeesCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesCountOutputType
     */
    select?: EmployeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountSalary_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentsWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAttendanceWhereInput
  }


  /**
   * Count Type FinancialCategoryCountOutputType
   */

  export type FinancialCategoryCountOutputType = {
    transactions: number
    dispatch_rule_details: number
  }

  export type FinancialCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | FinancialCategoryCountOutputTypeCountTransactionsArgs
    dispatch_rule_details?: boolean | FinancialCategoryCountOutputTypeCountDispatch_rule_detailsArgs
  }

  // Custom InputTypes
  /**
   * FinancialCategoryCountOutputType without action
   */
  export type FinancialCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategoryCountOutputType
     */
    select?: FinancialCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinancialCategoryCountOutputType without action
   */
  export type FinancialCategoryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialTransactionWhereInput
  }

  /**
   * FinancialCategoryCountOutputType without action
   */
  export type FinancialCategoryCountOutputTypeCountDispatch_rule_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchRuleDetailWhereInput
  }


  /**
   * Count Type DispatchRuleCountOutputType
   */

  export type DispatchRuleCountOutputType = {
    details: number
  }

  export type DispatchRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | DispatchRuleCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * DispatchRuleCountOutputType without action
   */
  export type DispatchRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleCountOutputType
     */
    select?: DispatchRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DispatchRuleCountOutputType without action
   */
  export type DispatchRuleCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchRuleDetailWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
    loggedIn: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
    loggedIn: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    schoolName: string | null
    schoolAddress: string | null
    loggedIn: number | null
    userRole: string | null
    schoolId: string | null
    userToken: string | null
    last_sync: Date | null
    activeSchoolYear: string | null
    roleId: string | null
    schoolYearStartDate: Date | null
    directorName: string | null
    directorGender: string | null
    schoolLogo: string | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    schoolName: string | null
    schoolAddress: string | null
    loggedIn: number | null
    userRole: string | null
    schoolId: string | null
    userToken: string | null
    last_sync: Date | null
    activeSchoolYear: string | null
    roleId: string | null
    schoolYearStartDate: Date | null
    directorName: string | null
    directorGender: string | null
    schoolLogo: string | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    schoolName: number
    schoolAddress: number
    loggedIn: number
    userRole: number
    schoolId: number
    userToken: number
    last_sync: number
    activeSchoolYear: number
    roleId: number
    permissions: number
    schoolYearStartDate: number
    directorName: number
    directorGender: number
    schoolLogo: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
    loggedIn?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
    loggedIn?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    schoolName?: true
    schoolAddress?: true
    loggedIn?: true
    userRole?: true
    schoolId?: true
    userToken?: true
    last_sync?: true
    activeSchoolYear?: true
    roleId?: true
    schoolYearStartDate?: true
    directorName?: true
    directorGender?: true
    schoolLogo?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    schoolName?: true
    schoolAddress?: true
    loggedIn?: true
    userRole?: true
    schoolId?: true
    userToken?: true
    last_sync?: true
    activeSchoolYear?: true
    roleId?: true
    schoolYearStartDate?: true
    directorName?: true
    directorGender?: true
    schoolLogo?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    schoolName?: true
    schoolAddress?: true
    loggedIn?: true
    userRole?: true
    schoolId?: true
    userToken?: true
    last_sync?: true
    activeSchoolYear?: true
    roleId?: true
    permissions?: true
    schoolYearStartDate?: true
    directorName?: true
    directorGender?: true
    schoolLogo?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: number
    schoolName: string | null
    schoolAddress: string | null
    loggedIn: number | null
    userRole: string | null
    schoolId: string | null
    userToken: string | null
    last_sync: Date | null
    activeSchoolYear: string | null
    roleId: string | null
    permissions: JsonValue | null
    schoolYearStartDate: Date | null
    directorName: string | null
    directorGender: string | null
    schoolLogo: string | null
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
    activeSchoolYear?: boolean
    roleId?: boolean
    permissions?: boolean
    schoolYearStartDate?: boolean
    directorName?: boolean
    directorGender?: boolean
    schoolLogo?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
    activeSchoolYear?: boolean
    roleId?: boolean
    permissions?: boolean
    schoolYearStartDate?: boolean
    directorName?: boolean
    directorGender?: boolean
    schoolLogo?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
    activeSchoolYear?: boolean
    roleId?: boolean
    permissions?: boolean
    schoolYearStartDate?: boolean
    directorName?: boolean
    directorGender?: boolean
    schoolLogo?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
    activeSchoolYear?: boolean
    roleId?: boolean
    permissions?: boolean
    schoolYearStartDate?: boolean
    directorName?: boolean
    directorGender?: boolean
    schoolLogo?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolName" | "schoolAddress" | "loggedIn" | "userRole" | "schoolId" | "userToken" | "last_sync" | "activeSchoolYear" | "roleId" | "permissions" | "schoolYearStartDate" | "directorName" | "directorGender" | "schoolLogo", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schoolName: string | null
      schoolAddress: string | null
      loggedIn: number | null
      userRole: string | null
      schoolId: string | null
      userToken: string | null
      last_sync: Date | null
      activeSchoolYear: string | null
      roleId: string | null
      permissions: Prisma.JsonValue | null
      schoolYearStartDate: Date | null
      directorName: string | null
      directorGender: string | null
      schoolLogo: string | null
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'Int'>
    readonly schoolName: FieldRef<"Settings", 'String'>
    readonly schoolAddress: FieldRef<"Settings", 'String'>
    readonly loggedIn: FieldRef<"Settings", 'Int'>
    readonly userRole: FieldRef<"Settings", 'String'>
    readonly schoolId: FieldRef<"Settings", 'String'>
    readonly userToken: FieldRef<"Settings", 'String'>
    readonly last_sync: FieldRef<"Settings", 'DateTime'>
    readonly activeSchoolYear: FieldRef<"Settings", 'String'>
    readonly roleId: FieldRef<"Settings", 'String'>
    readonly permissions: FieldRef<"Settings", 'Json'>
    readonly schoolYearStartDate: FieldRef<"Settings", 'DateTime'>
    readonly directorName: FieldRef<"Settings", 'String'>
    readonly directorGender: FieldRef<"Settings", 'String'>
    readonly schoolLogo: FieldRef<"Settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data?: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model Classes
   */

  export type AggregateClasses = {
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  export type ClassesAvgAggregateOutputType = {
    id: number | null
  }

  export type ClassesSumAggregateOutputType = {
    id: number | null
  }

  export type ClassesMinAggregateOutputType = {
    id: number | null
    name: string | null
    level: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type ClassesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    level: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type ClassesCountAggregateOutputType = {
    id: number
    name: number
    level: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type ClassesAvgAggregateInputType = {
    id?: true
  }

  export type ClassesSumAggregateInputType = {
    id?: true
  }

  export type ClassesMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type ClassesMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type ClassesCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type ClassesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to aggregate.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassesMaxAggregateInputType
  }

  export type GetClassesAggregateType<T extends ClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasses[P]>
      : GetScalarType<T[P], AggregateClasses[P]>
  }




  export type ClassesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassesWhereInput
    orderBy?: ClassesOrderByWithAggregationInput | ClassesOrderByWithAggregationInput[]
    by: ClassesScalarFieldEnum[] | ClassesScalarFieldEnum
    having?: ClassesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassesCountAggregateInputType | true
    _avg?: ClassesAvgAggregateInputType
    _sum?: ClassesSumAggregateInputType
    _min?: ClassesMinAggregateInputType
    _max?: ClassesMaxAggregateInputType
  }

  export type ClassesGroupByOutputType = {
    id: number
    name: string
    level: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  type GetClassesGroupByPayload<T extends ClassesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassesGroupByOutputType[P]>
            : GetScalarType<T[P], ClassesGroupByOutputType[P]>
        }
      >
    >


  export type ClassesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: boolean | Classes$lessonsArgs<ExtArgs>
    registrations?: boolean | Classes$registrationsArgs<ExtArgs>
    subjects?: boolean | Classes$subjectsArgs<ExtArgs>
    single_fees?: boolean | Classes$single_feesArgs<ExtArgs>
    fee_templates?: boolean | Classes$fee_templatesArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classes"]>

  export type ClassesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["classes"]>

  export type ClassesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["classes"]>

  export type ClassesSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type ClassesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "level" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["classes"]>
  export type ClassesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Classes$lessonsArgs<ExtArgs>
    registrations?: boolean | Classes$registrationsArgs<ExtArgs>
    subjects?: boolean | Classes$subjectsArgs<ExtArgs>
    single_fees?: boolean | Classes$single_feesArgs<ExtArgs>
    fee_templates?: boolean | Classes$fee_templatesArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClassesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classes"
    objects: {
      lessons: Prisma.$LessonsPayload<ExtArgs>[]
      registrations: Prisma.$RegistrationsPayload<ExtArgs>[]
      subjects: Prisma.$SubjectsPayload<ExtArgs>[]
      single_fees: Prisma.$SingleFeePayload<ExtArgs>[]
      fee_templates: Prisma.$FeeTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      level: string | null
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["classes"]>
    composites: {}
  }

  type ClassesGetPayload<S extends boolean | null | undefined | ClassesDefaultArgs> = $Result.GetResult<Prisma.$ClassesPayload, S>

  type ClassesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassesCountAggregateInputType | true
    }

  export interface ClassesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classes'], meta: { name: 'Classes' } }
    /**
     * Find zero or one Classes that matches the filter.
     * @param {ClassesFindUniqueArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassesFindUniqueArgs>(args: SelectSubset<T, ClassesFindUniqueArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassesFindUniqueOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassesFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesFindFirstArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassesFindFirstArgs>(args?: SelectSubset<T, ClassesFindFirstArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesFindFirstOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassesFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classes.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classesWithIdOnly = await prisma.classes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassesFindManyArgs>(args?: SelectSubset<T, ClassesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classes.
     * @param {ClassesCreateArgs} args - Arguments to create a Classes.
     * @example
     * // Create one Classes
     * const Classes = await prisma.classes.create({
     *   data: {
     *     // ... data to create a Classes
     *   }
     * })
     * 
     */
    create<T extends ClassesCreateArgs>(args: SelectSubset<T, ClassesCreateArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassesCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassesCreateManyArgs>(args?: SelectSubset<T, ClassesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassesCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classesWithIdOnly = await prisma.classes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassesCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classes.
     * @param {ClassesDeleteArgs} args - Arguments to delete one Classes.
     * @example
     * // Delete one Classes
     * const Classes = await prisma.classes.delete({
     *   where: {
     *     // ... filter to delete one Classes
     *   }
     * })
     * 
     */
    delete<T extends ClassesDeleteArgs>(args: SelectSubset<T, ClassesDeleteArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classes.
     * @param {ClassesUpdateArgs} args - Arguments to update one Classes.
     * @example
     * // Update one Classes
     * const classes = await prisma.classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassesUpdateArgs>(args: SelectSubset<T, ClassesUpdateArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassesDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassesDeleteManyArgs>(args?: SelectSubset<T, ClassesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassesUpdateManyArgs>(args: SelectSubset<T, ClassesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassesUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classesWithIdOnly = await prisma.classes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassesUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classes.
     * @param {ClassesUpsertArgs} args - Arguments to update or create a Classes.
     * @example
     * // Update or create a Classes
     * const classes = await prisma.classes.upsert({
     *   create: {
     *     // ... data to create a Classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classes we want to update
     *   }
     * })
     */
    upsert<T extends ClassesUpsertArgs>(args: SelectSubset<T, ClassesUpsertArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classes.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassesCountArgs>(
      args?: Subset<T, ClassesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassesAggregateArgs>(args: Subset<T, ClassesAggregateArgs>): Prisma.PrismaPromise<GetClassesAggregateType<T>>

    /**
     * Group by Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassesGroupByArgs['orderBy'] }
        : { orderBy?: ClassesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classes model
   */
  readonly fields: ClassesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Classes$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Classes$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrations<T extends Classes$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Classes$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Classes$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Classes$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    single_fees<T extends Classes$single_feesArgs<ExtArgs> = {}>(args?: Subset<T, Classes$single_feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fee_templates<T extends Classes$fee_templatesArgs<ExtArgs> = {}>(args?: Subset<T, Classes$fee_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classes model
   */
  interface ClassesFieldRefs {
    readonly id: FieldRef<"Classes", 'Int'>
    readonly name: FieldRef<"Classes", 'String'>
    readonly level: FieldRef<"Classes", 'String'>
    readonly school_id: FieldRef<"Classes", 'String'>
    readonly supabase_id: FieldRef<"Classes", 'String'>
    readonly last_modified: FieldRef<"Classes", 'DateTime'>
    readonly needs_sync: FieldRef<"Classes", 'Boolean'>
    readonly is_deleted: FieldRef<"Classes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Classes findUnique
   */
  export type ClassesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes findUniqueOrThrow
   */
  export type ClassesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes findFirst
   */
  export type ClassesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * Classes findFirstOrThrow
   */
  export type ClassesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * Classes findMany
   */
  export type ClassesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * Classes create
   */
  export type ClassesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * The data needed to create a Classes.
     */
    data: XOR<ClassesCreateInput, ClassesUncheckedCreateInput>
  }

  /**
   * Classes createMany
   */
  export type ClassesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassesCreateManyInput | ClassesCreateManyInput[]
  }

  /**
   * Classes createManyAndReturn
   */
  export type ClassesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassesCreateManyInput | ClassesCreateManyInput[]
  }

  /**
   * Classes update
   */
  export type ClassesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * The data needed to update a Classes.
     */
    data: XOR<ClassesUpdateInput, ClassesUncheckedUpdateInput>
    /**
     * Choose, which Classes to update.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes updateMany
   */
  export type ClassesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassesUpdateManyMutationInput, ClassesUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassesWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Classes updateManyAndReturn
   */
  export type ClassesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassesUpdateManyMutationInput, ClassesUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassesWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Classes upsert
   */
  export type ClassesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * The filter to search for the Classes to update in case it exists.
     */
    where: ClassesWhereUniqueInput
    /**
     * In case the Classes found by the `where` argument doesn't exist, create a new Classes with this data.
     */
    create: XOR<ClassesCreateInput, ClassesUncheckedCreateInput>
    /**
     * In case the Classes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassesUpdateInput, ClassesUncheckedUpdateInput>
  }

  /**
   * Classes delete
   */
  export type ClassesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter which Classes to delete.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes deleteMany
   */
  export type ClassesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassesWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Classes.lessons
   */
  export type Classes$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    cursor?: LessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Classes.registrations
   */
  export type Classes$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    where?: RegistrationsWhereInput
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    cursor?: RegistrationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Classes.subjects
   */
  export type Classes$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    where?: SubjectsWhereInput
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    cursor?: SubjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Classes.single_fees
   */
  export type Classes$single_feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    where?: SingleFeeWhereInput
    orderBy?: SingleFeeOrderByWithRelationInput | SingleFeeOrderByWithRelationInput[]
    cursor?: SingleFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SingleFeeScalarFieldEnum | SingleFeeScalarFieldEnum[]
  }

  /**
   * Classes.fee_templates
   */
  export type Classes$fee_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    where?: FeeTemplateWhereInput
    orderBy?: FeeTemplateOrderByWithRelationInput | FeeTemplateOrderByWithRelationInput[]
    cursor?: FeeTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeTemplateScalarFieldEnum | FeeTemplateScalarFieldEnum[]
  }

  /**
   * Classes without action
   */
  export type ClassesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
  }


  /**
   * Model Students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    id: number | null
  }

  export type StudentsSumAggregateOutputType = {
    id: number | null
  }

  export type StudentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    genre: string | null
    birth_date: string | null
    picture_url: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    matricul: string | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    genre: string | null
    birth_date: string | null
    picture_url: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    matricul: string | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    genre: number
    birth_date: number
    picture_url: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    matricul: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    id?: true
  }

  export type StudentsSumAggregateInputType = {
    id?: true
  }

  export type StudentsMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    genre?: true
    birth_date?: true
    picture_url?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    matricul?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    genre?: true
    birth_date?: true
    picture_url?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    matricul?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    genre?: true
    birth_date?: true
    picture_url?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    matricul?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to aggregate.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type StudentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentsWhereInput
    orderBy?: StudentsOrderByWithAggregationInput | StudentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: StudentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    genre: string | null
    birth_date: string | null
    picture_url: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    matricul: string | null
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends StudentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
    attendances?: boolean | Students$attendancesArgs<ExtArgs>
    notes?: boolean | Students$notesArgs<ExtArgs>
    registrations?: boolean | Students$registrationsArgs<ExtArgs>
    student_parents?: boolean | Students$student_parentsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
  }

  export type StudentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "genre" | "birth_date" | "picture_url" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted" | "matricul", ExtArgs["result"]["students"]>
  export type StudentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | Students$attendancesArgs<ExtArgs>
    notes?: boolean | Students$notesArgs<ExtArgs>
    registrations?: boolean | Students$registrationsArgs<ExtArgs>
    student_parents?: boolean | Students$student_parentsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StudentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StudentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Students"
    objects: {
      attendances: Prisma.$AttendancesPayload<ExtArgs>[]
      notes: Prisma.$NotesPayload<ExtArgs>[]
      registrations: Prisma.$RegistrationsPayload<ExtArgs>[]
      student_parents: Prisma.$StudentParentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      genre: string | null
      birth_date: string | null
      picture_url: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
      matricul: string | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type StudentsGetPayload<S extends boolean | null | undefined | StudentsDefaultArgs> = $Result.GetResult<Prisma.$StudentsPayload, S>

  type StudentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface StudentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Students'], meta: { name: 'Students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {StudentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentsFindUniqueArgs>(args: SelectSubset<T, StudentsFindUniqueArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentsFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentsFindFirstArgs>(args?: SelectSubset<T, StudentsFindFirstArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentsFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentsFindManyArgs>(args?: SelectSubset<T, StudentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Students.
     * @param {StudentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends StudentsCreateArgs>(args: SelectSubset<T, StudentsCreateArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentsCreateManyArgs>(args?: SelectSubset<T, StudentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentsCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentsCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Students.
     * @param {StudentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends StudentsDeleteArgs>(args: SelectSubset<T, StudentsDeleteArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Students.
     * @param {StudentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentsUpdateArgs>(args: SelectSubset<T, StudentsUpdateArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentsDeleteManyArgs>(args?: SelectSubset<T, StudentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentsUpdateManyArgs>(args: SelectSubset<T, StudentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentsUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentsUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Students.
     * @param {StudentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends StudentsUpsertArgs>(args: SelectSubset<T, StudentsUpsertArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentsCountArgs>(
      args?: Subset<T, StudentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Students model
   */
  readonly fields: StudentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendances<T extends Students$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Students$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Students$notesArgs<ExtArgs> = {}>(args?: Subset<T, Students$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrations<T extends Students$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Students$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_parents<T extends Students$student_parentsArgs<ExtArgs> = {}>(args?: Subset<T, Students$student_parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Students model
   */
  interface StudentsFieldRefs {
    readonly id: FieldRef<"Students", 'Int'>
    readonly name: FieldRef<"Students", 'String'>
    readonly first_name: FieldRef<"Students", 'String'>
    readonly genre: FieldRef<"Students", 'String'>
    readonly birth_date: FieldRef<"Students", 'String'>
    readonly picture_url: FieldRef<"Students", 'String'>
    readonly supabase_id: FieldRef<"Students", 'String'>
    readonly last_modified: FieldRef<"Students", 'DateTime'>
    readonly needs_sync: FieldRef<"Students", 'Boolean'>
    readonly is_deleted: FieldRef<"Students", 'Boolean'>
    readonly matricul: FieldRef<"Students", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Students findUnique
   */
  export type StudentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students findUniqueOrThrow
   */
  export type StudentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students findFirst
   */
  export type StudentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students findFirstOrThrow
   */
  export type StudentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students findMany
   */
  export type StudentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students create
   */
  export type StudentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Students.
     */
    data?: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
  }

  /**
   * Students createMany
   */
  export type StudentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentsCreateManyInput | StudentsCreateManyInput[]
  }

  /**
   * Students createManyAndReturn
   */
  export type StudentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentsCreateManyInput | StudentsCreateManyInput[]
  }

  /**
   * Students update
   */
  export type StudentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Students.
     */
    data: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
    /**
     * Choose, which Students to update.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students updateMany
   */
  export type StudentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Students updateManyAndReturn
   */
  export type StudentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Students upsert
   */
  export type StudentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Students to update in case it exists.
     */
    where: StudentsWhereUniqueInput
    /**
     * In case the Students found by the `where` argument doesn't exist, create a new Students with this data.
     */
    create: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
    /**
     * In case the Students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
  }

  /**
   * Students delete
   */
  export type StudentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter which Students to delete.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students deleteMany
   */
  export type StudentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Students.attendances
   */
  export type Students$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    where?: AttendancesWhereInput
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    cursor?: AttendancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Students.notes
   */
  export type Students$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Students.registrations
   */
  export type Students$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    where?: RegistrationsWhereInput
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    cursor?: RegistrationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Students.student_parents
   */
  export type Students$student_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    where?: StudentParentsWhereInput
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    cursor?: StudentParentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * Students without action
   */
  export type StudentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
  }


  /**
   * Model Registrations
   */

  export type AggregateRegistrations = {
    _count: RegistrationsCountAggregateOutputType | null
    _avg: RegistrationsAvgAggregateOutputType | null
    _sum: RegistrationsSumAggregateOutputType | null
    _min: RegistrationsMinAggregateOutputType | null
    _max: RegistrationsMaxAggregateOutputType | null
  }

  export type RegistrationsAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
  }

  export type RegistrationsSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
  }

  export type RegistrationsMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
    school_year: string | null
    state: string | null
    registration_date: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type RegistrationsMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
    school_year: string | null
    state: string | null
    registration_date: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type RegistrationsCountAggregateOutputType = {
    id: number
    student_id: number
    class_id: number
    school_year: number
    state: number
    registration_date: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type RegistrationsAvgAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
  }

  export type RegistrationsSumAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
  }

  export type RegistrationsMinAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
    school_year?: true
    state?: true
    registration_date?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type RegistrationsMaxAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
    school_year?: true
    state?: true
    registration_date?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type RegistrationsCountAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
    school_year?: true
    state?: true
    registration_date?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type RegistrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Registrations to aggregate.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Registrations
    **/
    _count?: true | RegistrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegistrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegistrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegistrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegistrationsMaxAggregateInputType
  }

  export type GetRegistrationsAggregateType<T extends RegistrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistrations[P]>
      : GetScalarType<T[P], AggregateRegistrations[P]>
  }




  export type RegistrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistrationsWhereInput
    orderBy?: RegistrationsOrderByWithAggregationInput | RegistrationsOrderByWithAggregationInput[]
    by: RegistrationsScalarFieldEnum[] | RegistrationsScalarFieldEnum
    having?: RegistrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegistrationsCountAggregateInputType | true
    _avg?: RegistrationsAvgAggregateInputType
    _sum?: RegistrationsSumAggregateInputType
    _min?: RegistrationsMinAggregateInputType
    _max?: RegistrationsMaxAggregateInputType
  }

  export type RegistrationsGroupByOutputType = {
    id: number
    student_id: number
    class_id: number
    school_year: string | null
    state: string | null
    registration_date: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: RegistrationsCountAggregateOutputType | null
    _avg: RegistrationsAvgAggregateOutputType | null
    _sum: RegistrationsSumAggregateOutputType | null
    _min: RegistrationsMinAggregateOutputType | null
    _max: RegistrationsMaxAggregateOutputType | null
  }

  type GetRegistrationsGroupByPayload<T extends RegistrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegistrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegistrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegistrationsGroupByOutputType[P]>
            : GetScalarType<T[P], RegistrationsGroupByOutputType[P]>
        }
      >
    >


  export type RegistrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: boolean | Registrations$paymentsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
    _count?: boolean | RegistrationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registrations"]>

  export type RegistrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registrations"]>

  export type RegistrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registrations"]>

  export type RegistrationsSelectScalar = {
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "class_id" | "school_year" | "state" | "registration_date" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["registrations"]>
  export type RegistrationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Registrations$paymentsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
    _count?: boolean | RegistrationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegistrationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type RegistrationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $RegistrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Registrations"
    objects: {
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
      class: Prisma.$ClassesPayload<ExtArgs>
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      class_id: number
      school_year: string | null
      state: string | null
      registration_date: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["registrations"]>
    composites: {}
  }

  type RegistrationsGetPayload<S extends boolean | null | undefined | RegistrationsDefaultArgs> = $Result.GetResult<Prisma.$RegistrationsPayload, S>

  type RegistrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegistrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegistrationsCountAggregateInputType | true
    }

  export interface RegistrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Registrations'], meta: { name: 'Registrations' } }
    /**
     * Find zero or one Registrations that matches the filter.
     * @param {RegistrationsFindUniqueArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegistrationsFindUniqueArgs>(args: SelectSubset<T, RegistrationsFindUniqueArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Registrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegistrationsFindUniqueOrThrowArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegistrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, RegistrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsFindFirstArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegistrationsFindFirstArgs>(args?: SelectSubset<T, RegistrationsFindFirstArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Registrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsFindFirstOrThrowArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegistrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, RegistrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Registrations
     * const registrations = await prisma.registrations.findMany()
     * 
     * // Get first 10 Registrations
     * const registrations = await prisma.registrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registrationsWithIdOnly = await prisma.registrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegistrationsFindManyArgs>(args?: SelectSubset<T, RegistrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Registrations.
     * @param {RegistrationsCreateArgs} args - Arguments to create a Registrations.
     * @example
     * // Create one Registrations
     * const Registrations = await prisma.registrations.create({
     *   data: {
     *     // ... data to create a Registrations
     *   }
     * })
     * 
     */
    create<T extends RegistrationsCreateArgs>(args: SelectSubset<T, RegistrationsCreateArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Registrations.
     * @param {RegistrationsCreateManyArgs} args - Arguments to create many Registrations.
     * @example
     * // Create many Registrations
     * const registrations = await prisma.registrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegistrationsCreateManyArgs>(args?: SelectSubset<T, RegistrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Registrations and returns the data saved in the database.
     * @param {RegistrationsCreateManyAndReturnArgs} args - Arguments to create many Registrations.
     * @example
     * // Create many Registrations
     * const registrations = await prisma.registrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Registrations and only return the `id`
     * const registrationsWithIdOnly = await prisma.registrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegistrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, RegistrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Registrations.
     * @param {RegistrationsDeleteArgs} args - Arguments to delete one Registrations.
     * @example
     * // Delete one Registrations
     * const Registrations = await prisma.registrations.delete({
     *   where: {
     *     // ... filter to delete one Registrations
     *   }
     * })
     * 
     */
    delete<T extends RegistrationsDeleteArgs>(args: SelectSubset<T, RegistrationsDeleteArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Registrations.
     * @param {RegistrationsUpdateArgs} args - Arguments to update one Registrations.
     * @example
     * // Update one Registrations
     * const registrations = await prisma.registrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegistrationsUpdateArgs>(args: SelectSubset<T, RegistrationsUpdateArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Registrations.
     * @param {RegistrationsDeleteManyArgs} args - Arguments to filter Registrations to delete.
     * @example
     * // Delete a few Registrations
     * const { count } = await prisma.registrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegistrationsDeleteManyArgs>(args?: SelectSubset<T, RegistrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Registrations
     * const registrations = await prisma.registrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegistrationsUpdateManyArgs>(args: SelectSubset<T, RegistrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Registrations and returns the data updated in the database.
     * @param {RegistrationsUpdateManyAndReturnArgs} args - Arguments to update many Registrations.
     * @example
     * // Update many Registrations
     * const registrations = await prisma.registrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Registrations and only return the `id`
     * const registrationsWithIdOnly = await prisma.registrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegistrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, RegistrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Registrations.
     * @param {RegistrationsUpsertArgs} args - Arguments to update or create a Registrations.
     * @example
     * // Update or create a Registrations
     * const registrations = await prisma.registrations.upsert({
     *   create: {
     *     // ... data to create a Registrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Registrations we want to update
     *   }
     * })
     */
    upsert<T extends RegistrationsUpsertArgs>(args: SelectSubset<T, RegistrationsUpsertArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsCountArgs} args - Arguments to filter Registrations to count.
     * @example
     * // Count the number of Registrations
     * const count = await prisma.registrations.count({
     *   where: {
     *     // ... the filter for the Registrations we want to count
     *   }
     * })
    **/
    count<T extends RegistrationsCountArgs>(
      args?: Subset<T, RegistrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegistrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegistrationsAggregateArgs>(args: Subset<T, RegistrationsAggregateArgs>): Prisma.PrismaPromise<GetRegistrationsAggregateType<T>>

    /**
     * Group by Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegistrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegistrationsGroupByArgs['orderBy'] }
        : { orderBy?: RegistrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegistrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Registrations model
   */
  readonly fields: RegistrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Registrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegistrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends Registrations$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Registrations$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class<T extends ClassesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassesDefaultArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Registrations model
   */
  interface RegistrationsFieldRefs {
    readonly id: FieldRef<"Registrations", 'Int'>
    readonly student_id: FieldRef<"Registrations", 'Int'>
    readonly class_id: FieldRef<"Registrations", 'Int'>
    readonly school_year: FieldRef<"Registrations", 'String'>
    readonly state: FieldRef<"Registrations", 'String'>
    readonly registration_date: FieldRef<"Registrations", 'String'>
    readonly supabase_id: FieldRef<"Registrations", 'String'>
    readonly last_modified: FieldRef<"Registrations", 'DateTime'>
    readonly needs_sync: FieldRef<"Registrations", 'Boolean'>
    readonly is_deleted: FieldRef<"Registrations", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Registrations findUnique
   */
  export type RegistrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations findUniqueOrThrow
   */
  export type RegistrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations findFirst
   */
  export type RegistrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Registrations.
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Registrations.
     */
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Registrations findFirstOrThrow
   */
  export type RegistrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Registrations.
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Registrations.
     */
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Registrations findMany
   */
  export type RegistrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Registrations.
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Registrations create
   */
  export type RegistrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Registrations.
     */
    data: XOR<RegistrationsCreateInput, RegistrationsUncheckedCreateInput>
  }

  /**
   * Registrations createMany
   */
  export type RegistrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Registrations.
     */
    data: RegistrationsCreateManyInput | RegistrationsCreateManyInput[]
  }

  /**
   * Registrations createManyAndReturn
   */
  export type RegistrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * The data used to create many Registrations.
     */
    data: RegistrationsCreateManyInput | RegistrationsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Registrations update
   */
  export type RegistrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Registrations.
     */
    data: XOR<RegistrationsUpdateInput, RegistrationsUncheckedUpdateInput>
    /**
     * Choose, which Registrations to update.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations updateMany
   */
  export type RegistrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Registrations.
     */
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyInput>
    /**
     * Filter which Registrations to update
     */
    where?: RegistrationsWhereInput
    /**
     * Limit how many Registrations to update.
     */
    limit?: number
  }

  /**
   * Registrations updateManyAndReturn
   */
  export type RegistrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * The data used to update Registrations.
     */
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyInput>
    /**
     * Filter which Registrations to update
     */
    where?: RegistrationsWhereInput
    /**
     * Limit how many Registrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Registrations upsert
   */
  export type RegistrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Registrations to update in case it exists.
     */
    where: RegistrationsWhereUniqueInput
    /**
     * In case the Registrations found by the `where` argument doesn't exist, create a new Registrations with this data.
     */
    create: XOR<RegistrationsCreateInput, RegistrationsUncheckedCreateInput>
    /**
     * In case the Registrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegistrationsUpdateInput, RegistrationsUncheckedUpdateInput>
  }

  /**
   * Registrations delete
   */
  export type RegistrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter which Registrations to delete.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations deleteMany
   */
  export type RegistrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Registrations to delete
     */
    where?: RegistrationsWhereInput
    /**
     * Limit how many Registrations to delete.
     */
    limit?: number
  }

  /**
   * Registrations.payments
   */
  export type Registrations$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Registrations without action
   */
  export type RegistrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
  }


  /**
   * Model Teachers
   */

  export type AggregateTeachers = {
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  export type TeachersAvgAggregateOutputType = {
    id: number | null
    hourlyRate: number | null
  }

  export type TeachersSumAggregateOutputType = {
    id: number | null
    hourlyRate: number | null
  }

  export type TeachersMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    password_hash: string | null
    role_id: string | null
    speciality: string | null
    matricule: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    hourlyRate: number | null
    school_id: string | null
  }

  export type TeachersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    password_hash: string | null
    role_id: string | null
    speciality: string | null
    matricule: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    hourlyRate: number | null
    school_id: string | null
  }

  export type TeachersCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    phone: number
    email: number
    adress: number
    password_hash: number
    role_id: number
    speciality: number
    matricule: number
    supabase_id: number
    user_supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    hourlyRate: number
    school_id: number
    _all: number
  }


  export type TeachersAvgAggregateInputType = {
    id?: true
    hourlyRate?: true
  }

  export type TeachersSumAggregateInputType = {
    id?: true
    hourlyRate?: true
  }

  export type TeachersMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    password_hash?: true
    role_id?: true
    speciality?: true
    matricule?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    hourlyRate?: true
    school_id?: true
  }

  export type TeachersMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    password_hash?: true
    role_id?: true
    speciality?: true
    matricule?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    hourlyRate?: true
    school_id?: true
  }

  export type TeachersCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    password_hash?: true
    role_id?: true
    speciality?: true
    matricule?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    hourlyRate?: true
    school_id?: true
    _all?: true
  }

  export type TeachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to aggregate.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachersMaxAggregateInputType
  }

  export type GetTeachersAggregateType<T extends TeachersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers[P]>
      : GetScalarType<T[P], AggregateTeachers[P]>
  }




  export type TeachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachersWhereInput
    orderBy?: TeachersOrderByWithAggregationInput | TeachersOrderByWithAggregationInput[]
    by: TeachersScalarFieldEnum[] | TeachersScalarFieldEnum
    having?: TeachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachersCountAggregateInputType | true
    _avg?: TeachersAvgAggregateInputType
    _sum?: TeachersSumAggregateInputType
    _min?: TeachersMinAggregateInputType
    _max?: TeachersMaxAggregateInputType
  }

  export type TeachersGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    password_hash: string | null
    role_id: string | null
    speciality: string | null
    matricule: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    hourlyRate: number | null
    school_id: string | null
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  type GetTeachersGroupByPayload<T extends TeachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachersGroupByOutputType[P]>
            : GetScalarType<T[P], TeachersGroupByOutputType[P]>
        }
      >
    >


  export type TeachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
    lessons?: boolean | Teachers$lessonsArgs<ExtArgs>
    workHours?: boolean | Teachers$workHoursArgs<ExtArgs>
    attendances?: boolean | Teachers$attendancesArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type TeachersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["teachers"]>

  export type TeachersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["teachers"]>

  export type TeachersSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
  }

  export type TeachersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "phone" | "email" | "adress" | "password_hash" | "role_id" | "speciality" | "matricule" | "supabase_id" | "user_supabase_id" | "last_modified" | "needs_sync" | "is_deleted" | "hourlyRate" | "school_id", ExtArgs["result"]["teachers"]>
  export type TeachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Teachers$lessonsArgs<ExtArgs>
    workHours?: boolean | Teachers$workHoursArgs<ExtArgs>
    attendances?: boolean | Teachers$attendancesArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeachersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeachersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teachers"
    objects: {
      lessons: Prisma.$LessonsPayload<ExtArgs>[]
      workHours: Prisma.$TeacherWorkHoursPayload<ExtArgs>[]
      attendances: Prisma.$EmployeeAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      phone: string | null
      email: string | null
      adress: string | null
      password_hash: string | null
      role_id: string | null
      speciality: string | null
      matricule: string | null
      supabase_id: string | null
      user_supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
      hourlyRate: number | null
      school_id: string | null
    }, ExtArgs["result"]["teachers"]>
    composites: {}
  }

  type TeachersGetPayload<S extends boolean | null | undefined | TeachersDefaultArgs> = $Result.GetResult<Prisma.$TeachersPayload, S>

  type TeachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeachersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeachersCountAggregateInputType | true
    }

  export interface TeachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teachers'], meta: { name: 'Teachers' } }
    /**
     * Find zero or one Teachers that matches the filter.
     * @param {TeachersFindUniqueArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeachersFindUniqueArgs>(args: SelectSubset<T, TeachersFindUniqueArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teachers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeachersFindUniqueOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeachersFindUniqueOrThrowArgs>(args: SelectSubset<T, TeachersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindFirstArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeachersFindFirstArgs>(args?: SelectSubset<T, TeachersFindFirstArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindFirstOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeachersFindFirstOrThrowArgs>(args?: SelectSubset<T, TeachersFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teachers.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teachers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachersWithIdOnly = await prisma.teachers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeachersFindManyArgs>(args?: SelectSubset<T, TeachersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teachers.
     * @param {TeachersCreateArgs} args - Arguments to create a Teachers.
     * @example
     * // Create one Teachers
     * const Teachers = await prisma.teachers.create({
     *   data: {
     *     // ... data to create a Teachers
     *   }
     * })
     * 
     */
    create<T extends TeachersCreateArgs>(args: SelectSubset<T, TeachersCreateArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeachersCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeachersCreateManyArgs>(args?: SelectSubset<T, TeachersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeachersCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teachersWithIdOnly = await prisma.teachers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeachersCreateManyAndReturnArgs>(args?: SelectSubset<T, TeachersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teachers.
     * @param {TeachersDeleteArgs} args - Arguments to delete one Teachers.
     * @example
     * // Delete one Teachers
     * const Teachers = await prisma.teachers.delete({
     *   where: {
     *     // ... filter to delete one Teachers
     *   }
     * })
     * 
     */
    delete<T extends TeachersDeleteArgs>(args: SelectSubset<T, TeachersDeleteArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teachers.
     * @param {TeachersUpdateArgs} args - Arguments to update one Teachers.
     * @example
     * // Update one Teachers
     * const teachers = await prisma.teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeachersUpdateArgs>(args: SelectSubset<T, TeachersUpdateArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeachersDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeachersDeleteManyArgs>(args?: SelectSubset<T, TeachersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeachersUpdateManyArgs>(args: SelectSubset<T, TeachersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeachersUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teachersWithIdOnly = await prisma.teachers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeachersUpdateManyAndReturnArgs>(args: SelectSubset<T, TeachersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teachers.
     * @param {TeachersUpsertArgs} args - Arguments to update or create a Teachers.
     * @example
     * // Update or create a Teachers
     * const teachers = await prisma.teachers.upsert({
     *   create: {
     *     // ... data to create a Teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers we want to update
     *   }
     * })
     */
    upsert<T extends TeachersUpsertArgs>(args: SelectSubset<T, TeachersUpsertArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teachers.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeachersCountArgs>(
      args?: Subset<T, TeachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachersAggregateArgs>(args: Subset<T, TeachersAggregateArgs>): Prisma.PrismaPromise<GetTeachersAggregateType<T>>

    /**
     * Group by Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeachersGroupByArgs['orderBy'] }
        : { orderBy?: TeachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teachers model
   */
  readonly fields: TeachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Teachers$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Teachers$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workHours<T extends Teachers$workHoursArgs<ExtArgs> = {}>(args?: Subset<T, Teachers$workHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Teachers$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Teachers$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teachers model
   */
  interface TeachersFieldRefs {
    readonly id: FieldRef<"Teachers", 'Int'>
    readonly name: FieldRef<"Teachers", 'String'>
    readonly first_name: FieldRef<"Teachers", 'String'>
    readonly phone: FieldRef<"Teachers", 'String'>
    readonly email: FieldRef<"Teachers", 'String'>
    readonly adress: FieldRef<"Teachers", 'String'>
    readonly password_hash: FieldRef<"Teachers", 'String'>
    readonly role_id: FieldRef<"Teachers", 'String'>
    readonly speciality: FieldRef<"Teachers", 'String'>
    readonly matricule: FieldRef<"Teachers", 'String'>
    readonly supabase_id: FieldRef<"Teachers", 'String'>
    readonly user_supabase_id: FieldRef<"Teachers", 'String'>
    readonly last_modified: FieldRef<"Teachers", 'DateTime'>
    readonly needs_sync: FieldRef<"Teachers", 'Boolean'>
    readonly is_deleted: FieldRef<"Teachers", 'Boolean'>
    readonly hourlyRate: FieldRef<"Teachers", 'Float'>
    readonly school_id: FieldRef<"Teachers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Teachers findUnique
   */
  export type TeachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers findUniqueOrThrow
   */
  export type TeachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers findFirst
   */
  export type TeachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * Teachers findFirstOrThrow
   */
  export type TeachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * Teachers findMany
   */
  export type TeachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * Teachers create
   */
  export type TeachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The data needed to create a Teachers.
     */
    data?: XOR<TeachersCreateInput, TeachersUncheckedCreateInput>
  }

  /**
   * Teachers createMany
   */
  export type TeachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeachersCreateManyInput | TeachersCreateManyInput[]
  }

  /**
   * Teachers createManyAndReturn
   */
  export type TeachersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeachersCreateManyInput | TeachersCreateManyInput[]
  }

  /**
   * Teachers update
   */
  export type TeachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The data needed to update a Teachers.
     */
    data: XOR<TeachersUpdateInput, TeachersUncheckedUpdateInput>
    /**
     * Choose, which Teachers to update.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers updateMany
   */
  export type TeachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeachersUpdateManyMutationInput, TeachersUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeachersWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teachers updateManyAndReturn
   */
  export type TeachersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeachersUpdateManyMutationInput, TeachersUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeachersWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teachers upsert
   */
  export type TeachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The filter to search for the Teachers to update in case it exists.
     */
    where: TeachersWhereUniqueInput
    /**
     * In case the Teachers found by the `where` argument doesn't exist, create a new Teachers with this data.
     */
    create: XOR<TeachersCreateInput, TeachersUncheckedCreateInput>
    /**
     * In case the Teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeachersUpdateInput, TeachersUncheckedUpdateInput>
  }

  /**
   * Teachers delete
   */
  export type TeachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter which Teachers to delete.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers deleteMany
   */
  export type TeachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeachersWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teachers.lessons
   */
  export type Teachers$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    cursor?: LessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Teachers.workHours
   */
  export type Teachers$workHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    where?: TeacherWorkHoursWhereInput
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    cursor?: TeacherWorkHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * Teachers.attendances
   */
  export type Teachers$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    where?: EmployeeAttendanceWhereInput
    orderBy?: EmployeeAttendanceOrderByWithRelationInput | EmployeeAttendanceOrderByWithRelationInput[]
    cursor?: EmployeeAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeAttendanceScalarFieldEnum | EmployeeAttendanceScalarFieldEnum[]
  }

  /**
   * Teachers without action
   */
  export type TeachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
  }


  /**
   * Model TeacherWorkHours
   */

  export type AggregateTeacherWorkHours = {
    _count: TeacherWorkHoursCountAggregateOutputType | null
    _avg: TeacherWorkHoursAvgAggregateOutputType | null
    _sum: TeacherWorkHoursSumAggregateOutputType | null
    _min: TeacherWorkHoursMinAggregateOutputType | null
    _max: TeacherWorkHoursMaxAggregateOutputType | null
  }

  export type TeacherWorkHoursAvgAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    hours: number | null
  }

  export type TeacherWorkHoursSumAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    hours: number | null
  }

  export type TeacherWorkHoursMinAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    hours: number | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type TeacherWorkHoursMaxAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    hours: number | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type TeacherWorkHoursCountAggregateOutputType = {
    id: number
    teacher_id: number
    subject_id: number
    date: number
    start_time: number
    end_time: number
    hours: number
    notes: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type TeacherWorkHoursAvgAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    hours?: true
  }

  export type TeacherWorkHoursSumAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    hours?: true
  }

  export type TeacherWorkHoursMinAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    date?: true
    start_time?: true
    end_time?: true
    hours?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type TeacherWorkHoursMaxAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    date?: true
    start_time?: true
    end_time?: true
    hours?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type TeacherWorkHoursCountAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    date?: true
    start_time?: true
    end_time?: true
    hours?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type TeacherWorkHoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherWorkHours to aggregate.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherWorkHours
    **/
    _count?: true | TeacherWorkHoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherWorkHoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherWorkHoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherWorkHoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherWorkHoursMaxAggregateInputType
  }

  export type GetTeacherWorkHoursAggregateType<T extends TeacherWorkHoursAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherWorkHours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherWorkHours[P]>
      : GetScalarType<T[P], AggregateTeacherWorkHours[P]>
  }




  export type TeacherWorkHoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkHoursWhereInput
    orderBy?: TeacherWorkHoursOrderByWithAggregationInput | TeacherWorkHoursOrderByWithAggregationInput[]
    by: TeacherWorkHoursScalarFieldEnum[] | TeacherWorkHoursScalarFieldEnum
    having?: TeacherWorkHoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherWorkHoursCountAggregateInputType | true
    _avg?: TeacherWorkHoursAvgAggregateInputType
    _sum?: TeacherWorkHoursSumAggregateInputType
    _min?: TeacherWorkHoursMinAggregateInputType
    _max?: TeacherWorkHoursMaxAggregateInputType
  }

  export type TeacherWorkHoursGroupByOutputType = {
    id: number
    teacher_id: number
    subject_id: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    hours: number
    notes: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: TeacherWorkHoursCountAggregateOutputType | null
    _avg: TeacherWorkHoursAvgAggregateOutputType | null
    _sum: TeacherWorkHoursSumAggregateOutputType | null
    _min: TeacherWorkHoursMinAggregateOutputType | null
    _max: TeacherWorkHoursMaxAggregateOutputType | null
  }

  type GetTeacherWorkHoursGroupByPayload<T extends TeacherWorkHoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherWorkHoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherWorkHoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherWorkHoursGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherWorkHoursGroupByOutputType[P]>
        }
      >
    >


  export type TeacherWorkHoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherWorkHours"]>

  export type TeacherWorkHoursSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherWorkHours"]>

  export type TeacherWorkHoursSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherWorkHours"]>

  export type TeacherWorkHoursSelectScalar = {
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacher_id" | "subject_id" | "date" | "start_time" | "end_time" | "hours" | "notes" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["teacherWorkHours"]>
  export type TeacherWorkHoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }
  export type TeacherWorkHoursIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }
  export type TeacherWorkHoursIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }

  export type $TeacherWorkHoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherWorkHours"
    objects: {
      subject: Prisma.$SubjectsPayload<ExtArgs> | null
      teacher: Prisma.$TeachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacher_id: number
      subject_id: number | null
      date: string | null
      start_time: string | null
      end_time: string | null
      hours: number
      notes: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["teacherWorkHours"]>
    composites: {}
  }

  type TeacherWorkHoursGetPayload<S extends boolean | null | undefined | TeacherWorkHoursDefaultArgs> = $Result.GetResult<Prisma.$TeacherWorkHoursPayload, S>

  type TeacherWorkHoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherWorkHoursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherWorkHoursCountAggregateInputType | true
    }

  export interface TeacherWorkHoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherWorkHours'], meta: { name: 'TeacherWorkHours' } }
    /**
     * Find zero or one TeacherWorkHours that matches the filter.
     * @param {TeacherWorkHoursFindUniqueArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherWorkHoursFindUniqueArgs>(args: SelectSubset<T, TeacherWorkHoursFindUniqueArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherWorkHours that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherWorkHoursFindUniqueOrThrowArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherWorkHoursFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherWorkHoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherWorkHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursFindFirstArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherWorkHoursFindFirstArgs>(args?: SelectSubset<T, TeacherWorkHoursFindFirstArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherWorkHours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursFindFirstOrThrowArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherWorkHoursFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherWorkHoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherWorkHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findMany()
     * 
     * // Get first 10 TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWorkHoursWithIdOnly = await prisma.teacherWorkHours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherWorkHoursFindManyArgs>(args?: SelectSubset<T, TeacherWorkHoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherWorkHours.
     * @param {TeacherWorkHoursCreateArgs} args - Arguments to create a TeacherWorkHours.
     * @example
     * // Create one TeacherWorkHours
     * const TeacherWorkHours = await prisma.teacherWorkHours.create({
     *   data: {
     *     // ... data to create a TeacherWorkHours
     *   }
     * })
     * 
     */
    create<T extends TeacherWorkHoursCreateArgs>(args: SelectSubset<T, TeacherWorkHoursCreateArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherWorkHours.
     * @param {TeacherWorkHoursCreateManyArgs} args - Arguments to create many TeacherWorkHours.
     * @example
     * // Create many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherWorkHoursCreateManyArgs>(args?: SelectSubset<T, TeacherWorkHoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherWorkHours and returns the data saved in the database.
     * @param {TeacherWorkHoursCreateManyAndReturnArgs} args - Arguments to create many TeacherWorkHours.
     * @example
     * // Create many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherWorkHours and only return the `id`
     * const teacherWorkHoursWithIdOnly = await prisma.teacherWorkHours.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherWorkHoursCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherWorkHoursCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeacherWorkHours.
     * @param {TeacherWorkHoursDeleteArgs} args - Arguments to delete one TeacherWorkHours.
     * @example
     * // Delete one TeacherWorkHours
     * const TeacherWorkHours = await prisma.teacherWorkHours.delete({
     *   where: {
     *     // ... filter to delete one TeacherWorkHours
     *   }
     * })
     * 
     */
    delete<T extends TeacherWorkHoursDeleteArgs>(args: SelectSubset<T, TeacherWorkHoursDeleteArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherWorkHours.
     * @param {TeacherWorkHoursUpdateArgs} args - Arguments to update one TeacherWorkHours.
     * @example
     * // Update one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherWorkHoursUpdateArgs>(args: SelectSubset<T, TeacherWorkHoursUpdateArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherWorkHours.
     * @param {TeacherWorkHoursDeleteManyArgs} args - Arguments to filter TeacherWorkHours to delete.
     * @example
     * // Delete a few TeacherWorkHours
     * const { count } = await prisma.teacherWorkHours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherWorkHoursDeleteManyArgs>(args?: SelectSubset<T, TeacherWorkHoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherWorkHoursUpdateManyArgs>(args: SelectSubset<T, TeacherWorkHoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherWorkHours and returns the data updated in the database.
     * @param {TeacherWorkHoursUpdateManyAndReturnArgs} args - Arguments to update many TeacherWorkHours.
     * @example
     * // Update many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeacherWorkHours and only return the `id`
     * const teacherWorkHoursWithIdOnly = await prisma.teacherWorkHours.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherWorkHoursUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherWorkHoursUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeacherWorkHours.
     * @param {TeacherWorkHoursUpsertArgs} args - Arguments to update or create a TeacherWorkHours.
     * @example
     * // Update or create a TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.upsert({
     *   create: {
     *     // ... data to create a TeacherWorkHours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherWorkHours we want to update
     *   }
     * })
     */
    upsert<T extends TeacherWorkHoursUpsertArgs>(args: SelectSubset<T, TeacherWorkHoursUpsertArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursCountArgs} args - Arguments to filter TeacherWorkHours to count.
     * @example
     * // Count the number of TeacherWorkHours
     * const count = await prisma.teacherWorkHours.count({
     *   where: {
     *     // ... the filter for the TeacherWorkHours we want to count
     *   }
     * })
    **/
    count<T extends TeacherWorkHoursCountArgs>(
      args?: Subset<T, TeacherWorkHoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherWorkHoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherWorkHoursAggregateArgs>(args: Subset<T, TeacherWorkHoursAggregateArgs>): Prisma.PrismaPromise<GetTeacherWorkHoursAggregateType<T>>

    /**
     * Group by TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherWorkHoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherWorkHoursGroupByArgs['orderBy'] }
        : { orderBy?: TeacherWorkHoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherWorkHoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherWorkHoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherWorkHours model
   */
  readonly fields: TeacherWorkHoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherWorkHours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherWorkHoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends TeacherWorkHours$subjectArgs<ExtArgs> = {}>(args?: Subset<T, TeacherWorkHours$subjectArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeachersDefaultArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherWorkHours model
   */
  interface TeacherWorkHoursFieldRefs {
    readonly id: FieldRef<"TeacherWorkHours", 'Int'>
    readonly teacher_id: FieldRef<"TeacherWorkHours", 'Int'>
    readonly subject_id: FieldRef<"TeacherWorkHours", 'Int'>
    readonly date: FieldRef<"TeacherWorkHours", 'String'>
    readonly start_time: FieldRef<"TeacherWorkHours", 'String'>
    readonly end_time: FieldRef<"TeacherWorkHours", 'String'>
    readonly hours: FieldRef<"TeacherWorkHours", 'Float'>
    readonly notes: FieldRef<"TeacherWorkHours", 'String'>
    readonly supabase_id: FieldRef<"TeacherWorkHours", 'String'>
    readonly last_modified: FieldRef<"TeacherWorkHours", 'DateTime'>
    readonly needs_sync: FieldRef<"TeacherWorkHours", 'Boolean'>
    readonly is_deleted: FieldRef<"TeacherWorkHours", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TeacherWorkHours findUnique
   */
  export type TeacherWorkHoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours findUniqueOrThrow
   */
  export type TeacherWorkHoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours findFirst
   */
  export type TeacherWorkHoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherWorkHours.
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherWorkHours.
     */
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * TeacherWorkHours findFirstOrThrow
   */
  export type TeacherWorkHoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherWorkHours.
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherWorkHours.
     */
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * TeacherWorkHours findMany
   */
  export type TeacherWorkHoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherWorkHours.
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * TeacherWorkHours create
   */
  export type TeacherWorkHoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursCreateInput, TeacherWorkHoursUncheckedCreateInput>
  }

  /**
   * TeacherWorkHours createMany
   */
  export type TeacherWorkHoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherWorkHours.
     */
    data: TeacherWorkHoursCreateManyInput | TeacherWorkHoursCreateManyInput[]
  }

  /**
   * TeacherWorkHours createManyAndReturn
   */
  export type TeacherWorkHoursCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * The data used to create many TeacherWorkHours.
     */
    data: TeacherWorkHoursCreateManyInput | TeacherWorkHoursCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherWorkHours update
   */
  export type TeacherWorkHoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursUpdateInput, TeacherWorkHoursUncheckedUpdateInput>
    /**
     * Choose, which TeacherWorkHours to update.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours updateMany
   */
  export type TeacherWorkHoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyInput>
    /**
     * Filter which TeacherWorkHours to update
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * Limit how many TeacherWorkHours to update.
     */
    limit?: number
  }

  /**
   * TeacherWorkHours updateManyAndReturn
   */
  export type TeacherWorkHoursUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * The data used to update TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyInput>
    /**
     * Filter which TeacherWorkHours to update
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * Limit how many TeacherWorkHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherWorkHours upsert
   */
  export type TeacherWorkHoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherWorkHours to update in case it exists.
     */
    where: TeacherWorkHoursWhereUniqueInput
    /**
     * In case the TeacherWorkHours found by the `where` argument doesn't exist, create a new TeacherWorkHours with this data.
     */
    create: XOR<TeacherWorkHoursCreateInput, TeacherWorkHoursUncheckedCreateInput>
    /**
     * In case the TeacherWorkHours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherWorkHoursUpdateInput, TeacherWorkHoursUncheckedUpdateInput>
  }

  /**
   * TeacherWorkHours delete
   */
  export type TeacherWorkHoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter which TeacherWorkHours to delete.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours deleteMany
   */
  export type TeacherWorkHoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherWorkHours to delete
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * Limit how many TeacherWorkHours to delete.
     */
    limit?: number
  }

  /**
   * TeacherWorkHours.subject
   */
  export type TeacherWorkHours$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    where?: SubjectsWhereInput
  }

  /**
   * TeacherWorkHours without action
   */
  export type TeacherWorkHoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
  }


  /**
   * Model Lessons
   */

  export type AggregateLessons = {
    _count: LessonsCountAggregateOutputType | null
    _avg: LessonsAvgAggregateOutputType | null
    _sum: LessonsSumAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  export type LessonsAvgAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
  }

  export type LessonsSumAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
  }

  export type LessonsMinAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
    school_year: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type LessonsMaxAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
    school_year: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type LessonsCountAggregateOutputType = {
    id: number
    teacher_id: number
    class_id: number
    subject_id: number
    school_year: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type LessonsAvgAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
  }

  export type LessonsSumAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
  }

  export type LessonsMinAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
    school_year?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type LessonsMaxAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
    school_year?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type LessonsCountAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
    school_year?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type LessonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to aggregate.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonsMaxAggregateInputType
  }

  export type GetLessonsAggregateType<T extends LessonsAggregateArgs> = {
        [P in keyof T & keyof AggregateLessons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessons[P]>
      : GetScalarType<T[P], AggregateLessons[P]>
  }




  export type LessonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithAggregationInput | LessonsOrderByWithAggregationInput[]
    by: LessonsScalarFieldEnum[] | LessonsScalarFieldEnum
    having?: LessonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonsCountAggregateInputType | true
    _avg?: LessonsAvgAggregateInputType
    _sum?: LessonsSumAggregateInputType
    _min?: LessonsMinAggregateInputType
    _max?: LessonsMaxAggregateInputType
  }

  export type LessonsGroupByOutputType = {
    id: number
    teacher_id: number | null
    class_id: number
    subject_id: number
    school_year: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: LessonsCountAggregateOutputType | null
    _avg: LessonsAvgAggregateOutputType | null
    _sum: LessonsSumAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  type GetLessonsGroupByPayload<T extends LessonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonsGroupByOutputType[P]>
            : GetScalarType<T[P], LessonsGroupByOutputType[P]>
        }
      >
    >


  export type LessonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
    notes?: boolean | Lessons$notesArgs<ExtArgs>
    schedules?: boolean | Lessons$schedulesArgs<ExtArgs>
    _count?: boolean | LessonsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectScalar = {
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacher_id" | "class_id" | "subject_id" | "school_year" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["lessons"]>
  export type LessonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
    notes?: boolean | Lessons$notesArgs<ExtArgs>
    schedules?: boolean | Lessons$schedulesArgs<ExtArgs>
    _count?: boolean | LessonsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }
  export type LessonsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }

  export type $LessonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lessons"
    objects: {
      subject: Prisma.$SubjectsPayload<ExtArgs>
      class: Prisma.$ClassesPayload<ExtArgs>
      teacher: Prisma.$TeachersPayload<ExtArgs> | null
      notes: Prisma.$NotesPayload<ExtArgs>[]
      schedules: Prisma.$SchedulesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacher_id: number | null
      class_id: number
      subject_id: number
      school_year: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["lessons"]>
    composites: {}
  }

  type LessonsGetPayload<S extends boolean | null | undefined | LessonsDefaultArgs> = $Result.GetResult<Prisma.$LessonsPayload, S>

  type LessonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonsCountAggregateInputType | true
    }

  export interface LessonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lessons'], meta: { name: 'Lessons' } }
    /**
     * Find zero or one Lessons that matches the filter.
     * @param {LessonsFindUniqueArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonsFindUniqueArgs>(args: SelectSubset<T, LessonsFindUniqueArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lessons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonsFindUniqueOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonsFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindFirstArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonsFindFirstArgs>(args?: SelectSubset<T, LessonsFindFirstArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lessons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindFirstOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonsFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lessons.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lessons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonsWithIdOnly = await prisma.lessons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonsFindManyArgs>(args?: SelectSubset<T, LessonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lessons.
     * @param {LessonsCreateArgs} args - Arguments to create a Lessons.
     * @example
     * // Create one Lessons
     * const Lessons = await prisma.lessons.create({
     *   data: {
     *     // ... data to create a Lessons
     *   }
     * })
     * 
     */
    create<T extends LessonsCreateArgs>(args: SelectSubset<T, LessonsCreateArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonsCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lessons = await prisma.lessons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonsCreateManyArgs>(args?: SelectSubset<T, LessonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonsCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lessons = await prisma.lessons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonsWithIdOnly = await prisma.lessons.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonsCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lessons.
     * @param {LessonsDeleteArgs} args - Arguments to delete one Lessons.
     * @example
     * // Delete one Lessons
     * const Lessons = await prisma.lessons.delete({
     *   where: {
     *     // ... filter to delete one Lessons
     *   }
     * })
     * 
     */
    delete<T extends LessonsDeleteArgs>(args: SelectSubset<T, LessonsDeleteArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lessons.
     * @param {LessonsUpdateArgs} args - Arguments to update one Lessons.
     * @example
     * // Update one Lessons
     * const lessons = await prisma.lessons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonsUpdateArgs>(args: SelectSubset<T, LessonsUpdateArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonsDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lessons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonsDeleteManyArgs>(args?: SelectSubset<T, LessonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lessons = await prisma.lessons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonsUpdateManyArgs>(args: SelectSubset<T, LessonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonsUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lessons = await prisma.lessons.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonsWithIdOnly = await prisma.lessons.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonsUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lessons.
     * @param {LessonsUpsertArgs} args - Arguments to update or create a Lessons.
     * @example
     * // Update or create a Lessons
     * const lessons = await prisma.lessons.upsert({
     *   create: {
     *     // ... data to create a Lessons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lessons we want to update
     *   }
     * })
     */
    upsert<T extends LessonsUpsertArgs>(args: SelectSubset<T, LessonsUpsertArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lessons.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonsCountArgs>(
      args?: Subset<T, LessonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonsAggregateArgs>(args: Subset<T, LessonsAggregateArgs>): Prisma.PrismaPromise<GetLessonsAggregateType<T>>

    /**
     * Group by Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonsGroupByArgs['orderBy'] }
        : { orderBy?: LessonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lessons model
   */
  readonly fields: LessonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lessons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectsDefaultArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassesDefaultArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends Lessons$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Lessons$teacherArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notes<T extends Lessons$notesArgs<ExtArgs> = {}>(args?: Subset<T, Lessons$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Lessons$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Lessons$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lessons model
   */
  interface LessonsFieldRefs {
    readonly id: FieldRef<"Lessons", 'Int'>
    readonly teacher_id: FieldRef<"Lessons", 'Int'>
    readonly class_id: FieldRef<"Lessons", 'Int'>
    readonly subject_id: FieldRef<"Lessons", 'Int'>
    readonly school_year: FieldRef<"Lessons", 'String'>
    readonly supabase_id: FieldRef<"Lessons", 'String'>
    readonly last_modified: FieldRef<"Lessons", 'DateTime'>
    readonly needs_sync: FieldRef<"Lessons", 'Boolean'>
    readonly is_deleted: FieldRef<"Lessons", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Lessons findUnique
   */
  export type LessonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons findUniqueOrThrow
   */
  export type LessonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons findFirst
   */
  export type LessonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons findFirstOrThrow
   */
  export type LessonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons findMany
   */
  export type LessonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons create
   */
  export type LessonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The data needed to create a Lessons.
     */
    data: XOR<LessonsCreateInput, LessonsUncheckedCreateInput>
  }

  /**
   * Lessons createMany
   */
  export type LessonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonsCreateManyInput | LessonsCreateManyInput[]
  }

  /**
   * Lessons createManyAndReturn
   */
  export type LessonsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonsCreateManyInput | LessonsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lessons update
   */
  export type LessonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The data needed to update a Lessons.
     */
    data: XOR<LessonsUpdateInput, LessonsUncheckedUpdateInput>
    /**
     * Choose, which Lessons to update.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons updateMany
   */
  export type LessonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonsWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lessons updateManyAndReturn
   */
  export type LessonsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonsWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lessons upsert
   */
  export type LessonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The filter to search for the Lessons to update in case it exists.
     */
    where: LessonsWhereUniqueInput
    /**
     * In case the Lessons found by the `where` argument doesn't exist, create a new Lessons with this data.
     */
    create: XOR<LessonsCreateInput, LessonsUncheckedCreateInput>
    /**
     * In case the Lessons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonsUpdateInput, LessonsUncheckedUpdateInput>
  }

  /**
   * Lessons delete
   */
  export type LessonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter which Lessons to delete.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons deleteMany
   */
  export type LessonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonsWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lessons.teacher
   */
  export type Lessons$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    where?: TeachersWhereInput
  }

  /**
   * Lessons.notes
   */
  export type Lessons$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Lessons.schedules
   */
  export type Lessons$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    where?: SchedulesWhereInput
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    cursor?: SchedulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Lessons without action
   */
  export type LessonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
  }


  /**
   * Model Subjects
   */

  export type AggregateSubjects = {
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  export type SubjectsAvgAggregateOutputType = {
    id: number | null
    class_id: number | null
    coefficient: number | null
  }

  export type SubjectsSumAggregateOutputType = {
    id: number | null
    class_id: number | null
    coefficient: number | null
  }

  export type SubjectsMinAggregateOutputType = {
    id: number | null
    name: string | null
    class_id: number | null
    school_year: string | null
    coefficient: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SubjectsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    class_id: number | null
    school_year: string | null
    coefficient: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SubjectsCountAggregateOutputType = {
    id: number
    name: number
    class_id: number
    school_year: number
    coefficient: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type SubjectsAvgAggregateInputType = {
    id?: true
    class_id?: true
    coefficient?: true
  }

  export type SubjectsSumAggregateInputType = {
    id?: true
    class_id?: true
    coefficient?: true
  }

  export type SubjectsMinAggregateInputType = {
    id?: true
    name?: true
    class_id?: true
    school_year?: true
    coefficient?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SubjectsMaxAggregateInputType = {
    id?: true
    name?: true
    class_id?: true
    school_year?: true
    coefficient?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SubjectsCountAggregateInputType = {
    id?: true
    name?: true
    class_id?: true
    school_year?: true
    coefficient?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type SubjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to aggregate.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectsMaxAggregateInputType
  }

  export type GetSubjectsAggregateType<T extends SubjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjects[P]>
      : GetScalarType<T[P], AggregateSubjects[P]>
  }




  export type SubjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectsWhereInput
    orderBy?: SubjectsOrderByWithAggregationInput | SubjectsOrderByWithAggregationInput[]
    by: SubjectsScalarFieldEnum[] | SubjectsScalarFieldEnum
    having?: SubjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectsCountAggregateInputType | true
    _avg?: SubjectsAvgAggregateInputType
    _sum?: SubjectsSumAggregateInputType
    _min?: SubjectsMinAggregateInputType
    _max?: SubjectsMaxAggregateInputType
  }

  export type SubjectsGroupByOutputType = {
    id: number
    name: string
    class_id: number
    school_year: string | null
    coefficient: number | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  type GetSubjectsGroupByPayload<T extends SubjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
        }
      >
    >


  export type SubjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: boolean | Subjects$lessonsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    workHours?: boolean | Subjects$workHoursArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>

  export type SubjectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>

  export type SubjectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>

  export type SubjectsSelectScalar = {
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SubjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "class_id" | "school_year" | "coefficient" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["subjects"]>
  export type SubjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Subjects$lessonsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    workHours?: boolean | Subjects$workHoursArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }
  export type SubjectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }

  export type $SubjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subjects"
    objects: {
      lessons: Prisma.$LessonsPayload<ExtArgs>[]
      class: Prisma.$ClassesPayload<ExtArgs>
      workHours: Prisma.$TeacherWorkHoursPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      class_id: number
      school_year: string | null
      coefficient: number | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["subjects"]>
    composites: {}
  }

  type SubjectsGetPayload<S extends boolean | null | undefined | SubjectsDefaultArgs> = $Result.GetResult<Prisma.$SubjectsPayload, S>

  type SubjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectsCountAggregateInputType | true
    }

  export interface SubjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subjects'], meta: { name: 'Subjects' } }
    /**
     * Find zero or one Subjects that matches the filter.
     * @param {SubjectsFindUniqueArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectsFindUniqueArgs>(args: SelectSubset<T, SubjectsFindUniqueArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectsFindUniqueOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsFindFirstArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectsFindFirstArgs>(args?: SelectSubset<T, SubjectsFindFirstArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsFindFirstOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subjects.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subjects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectsWithIdOnly = await prisma.subjects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectsFindManyArgs>(args?: SelectSubset<T, SubjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subjects.
     * @param {SubjectsCreateArgs} args - Arguments to create a Subjects.
     * @example
     * // Create one Subjects
     * const Subjects = await prisma.subjects.create({
     *   data: {
     *     // ... data to create a Subjects
     *   }
     * })
     * 
     */
    create<T extends SubjectsCreateArgs>(args: SelectSubset<T, SubjectsCreateArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectsCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectsCreateManyArgs>(args?: SelectSubset<T, SubjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectsCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectsWithIdOnly = await prisma.subjects.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subjects.
     * @param {SubjectsDeleteArgs} args - Arguments to delete one Subjects.
     * @example
     * // Delete one Subjects
     * const Subjects = await prisma.subjects.delete({
     *   where: {
     *     // ... filter to delete one Subjects
     *   }
     * })
     * 
     */
    delete<T extends SubjectsDeleteArgs>(args: SelectSubset<T, SubjectsDeleteArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subjects.
     * @param {SubjectsUpdateArgs} args - Arguments to update one Subjects.
     * @example
     * // Update one Subjects
     * const subjects = await prisma.subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectsUpdateArgs>(args: SelectSubset<T, SubjectsUpdateArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectsDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectsDeleteManyArgs>(args?: SelectSubset<T, SubjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectsUpdateManyArgs>(args: SelectSubset<T, SubjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectsUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectsWithIdOnly = await prisma.subjects.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subjects.
     * @param {SubjectsUpsertArgs} args - Arguments to update or create a Subjects.
     * @example
     * // Update or create a Subjects
     * const subjects = await prisma.subjects.upsert({
     *   create: {
     *     // ... data to create a Subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjects we want to update
     *   }
     * })
     */
    upsert<T extends SubjectsUpsertArgs>(args: SelectSubset<T, SubjectsUpsertArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subjects.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectsCountArgs>(
      args?: Subset<T, SubjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectsAggregateArgs>(args: Subset<T, SubjectsAggregateArgs>): Prisma.PrismaPromise<GetSubjectsAggregateType<T>>

    /**
     * Group by Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectsGroupByArgs['orderBy'] }
        : { orderBy?: SubjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subjects model
   */
  readonly fields: SubjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Subjects$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Subjects$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class<T extends ClassesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassesDefaultArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workHours<T extends Subjects$workHoursArgs<ExtArgs> = {}>(args?: Subset<T, Subjects$workHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subjects model
   */
  interface SubjectsFieldRefs {
    readonly id: FieldRef<"Subjects", 'Int'>
    readonly name: FieldRef<"Subjects", 'String'>
    readonly class_id: FieldRef<"Subjects", 'Int'>
    readonly school_year: FieldRef<"Subjects", 'String'>
    readonly coefficient: FieldRef<"Subjects", 'Int'>
    readonly supabase_id: FieldRef<"Subjects", 'String'>
    readonly last_modified: FieldRef<"Subjects", 'DateTime'>
    readonly needs_sync: FieldRef<"Subjects", 'Boolean'>
    readonly is_deleted: FieldRef<"Subjects", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Subjects findUnique
   */
  export type SubjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects findUniqueOrThrow
   */
  export type SubjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects findFirst
   */
  export type SubjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Subjects findFirstOrThrow
   */
  export type SubjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Subjects findMany
   */
  export type SubjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Subjects create
   */
  export type SubjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a Subjects.
     */
    data: XOR<SubjectsCreateInput, SubjectsUncheckedCreateInput>
  }

  /**
   * Subjects createMany
   */
  export type SubjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectsCreateManyInput | SubjectsCreateManyInput[]
  }

  /**
   * Subjects createManyAndReturn
   */
  export type SubjectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectsCreateManyInput | SubjectsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subjects update
   */
  export type SubjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a Subjects.
     */
    data: XOR<SubjectsUpdateInput, SubjectsUncheckedUpdateInput>
    /**
     * Choose, which Subjects to update.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects updateMany
   */
  export type SubjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectsUpdateManyMutationInput, SubjectsUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectsWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subjects updateManyAndReturn
   */
  export type SubjectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectsUpdateManyMutationInput, SubjectsUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectsWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subjects upsert
   */
  export type SubjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the Subjects to update in case it exists.
     */
    where: SubjectsWhereUniqueInput
    /**
     * In case the Subjects found by the `where` argument doesn't exist, create a new Subjects with this data.
     */
    create: XOR<SubjectsCreateInput, SubjectsUncheckedCreateInput>
    /**
     * In case the Subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectsUpdateInput, SubjectsUncheckedUpdateInput>
  }

  /**
   * Subjects delete
   */
  export type SubjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter which Subjects to delete.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects deleteMany
   */
  export type SubjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectsWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subjects.lessons
   */
  export type Subjects$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    cursor?: LessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Subjects.workHours
   */
  export type Subjects$workHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    where?: TeacherWorkHoursWhereInput
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    cursor?: TeacherWorkHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * Subjects without action
   */
  export type SubjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
  }


  /**
   * Model Notes
   */

  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    quarter: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    quarter: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    type: string | null
    quarter: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    type: string | null
    quarter: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    student_id: number
    lesson_id: number
    value: number
    type: number
    quarter: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    quarter?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    quarter?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    type?: true
    quarter?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    type?: true
    quarter?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    type?: true
    quarter?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type NotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to aggregate.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type NotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithAggregationInput | NotesOrderByWithAggregationInput[]
    by: NotesScalarFieldEnum[] | NotesScalarFieldEnum
    having?: NotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }

  export type NotesGroupByOutputType = {
    id: number
    student_id: number
    lesson_id: number
    value: number | null
    type: string | null
    quarter: number | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends NotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type NotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectScalar = {
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "lesson_id" | "value" | "type" | "quarter" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["notes"]>
  export type NotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type NotesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type NotesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $NotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notes"
    objects: {
      lesson: Prisma.$LessonsPayload<ExtArgs>
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      lesson_id: number
      value: number | null
      type: string | null
      quarter: number | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["notes"]>
    composites: {}
  }

  type NotesGetPayload<S extends boolean | null | undefined | NotesDefaultArgs> = $Result.GetResult<Prisma.$NotesPayload, S>

  type NotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface NotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notes'], meta: { name: 'Notes' } }
    /**
     * Find zero or one Notes that matches the filter.
     * @param {NotesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotesFindUniqueArgs>(args: SelectSubset<T, NotesFindUniqueArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotesFindUniqueOrThrowArgs>(args: SelectSubset<T, NotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotesFindFirstArgs>(args?: SelectSubset<T, NotesFindFirstArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotesFindFirstOrThrowArgs>(args?: SelectSubset<T, NotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotesFindManyArgs>(args?: SelectSubset<T, NotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notes.
     * @param {NotesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
     */
    create<T extends NotesCreateArgs>(args: SelectSubset<T, NotesCreateArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {NotesCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotesCreateManyArgs>(args?: SelectSubset<T, NotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NotesCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotesCreateManyAndReturnArgs>(args?: SelectSubset<T, NotesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notes.
     * @param {NotesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
     */
    delete<T extends NotesDeleteArgs>(args: SelectSubset<T, NotesDeleteArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notes.
     * @param {NotesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotesUpdateArgs>(args: SelectSubset<T, NotesUpdateArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {NotesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotesDeleteManyArgs>(args?: SelectSubset<T, NotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotesUpdateManyArgs>(args: SelectSubset<T, NotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {NotesUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotesUpdateManyAndReturnArgs>(args: SelectSubset<T, NotesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notes.
     * @param {NotesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
     */
    upsert<T extends NotesUpsertArgs>(args: SelectSubset<T, NotesUpsertArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NotesCountArgs>(
      args?: Subset<T, NotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesGroupByArgs['orderBy'] }
        : { orderBy?: NotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notes model
   */
  readonly fields: NotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonsDefaultArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notes model
   */
  interface NotesFieldRefs {
    readonly id: FieldRef<"Notes", 'Int'>
    readonly student_id: FieldRef<"Notes", 'Int'>
    readonly lesson_id: FieldRef<"Notes", 'Int'>
    readonly value: FieldRef<"Notes", 'Float'>
    readonly type: FieldRef<"Notes", 'String'>
    readonly quarter: FieldRef<"Notes", 'Int'>
    readonly supabase_id: FieldRef<"Notes", 'String'>
    readonly last_modified: FieldRef<"Notes", 'DateTime'>
    readonly needs_sync: FieldRef<"Notes", 'Boolean'>
    readonly is_deleted: FieldRef<"Notes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notes findUnique
   */
  export type NotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes findUniqueOrThrow
   */
  export type NotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes findFirst
   */
  export type NotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes findFirstOrThrow
   */
  export type NotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes findMany
   */
  export type NotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes create
   */
  export type NotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The data needed to create a Notes.
     */
    data: XOR<NotesCreateInput, NotesUncheckedCreateInput>
  }

  /**
   * Notes createMany
   */
  export type NotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NotesCreateManyInput | NotesCreateManyInput[]
  }

  /**
   * Notes createManyAndReturn
   */
  export type NotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NotesCreateManyInput | NotesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notes update
   */
  export type NotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The data needed to update a Notes.
     */
    data: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
    /**
     * Choose, which Notes to update.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes updateMany
   */
  export type NotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NotesWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Notes updateManyAndReturn
   */
  export type NotesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * The data used to update Notes.
     */
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NotesWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notes upsert
   */
  export type NotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The filter to search for the Notes to update in case it exists.
     */
    where: NotesWhereUniqueInput
    /**
     * In case the Notes found by the `where` argument doesn't exist, create a new Notes with this data.
     */
    create: XOR<NotesCreateInput, NotesUncheckedCreateInput>
    /**
     * In case the Notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
  }

  /**
   * Notes delete
   */
  export type NotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter which Notes to delete.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes deleteMany
   */
  export type NotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NotesWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Notes without action
   */
  export type NotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
  }


  /**
   * Model Parents
   */

  export type AggregateParents = {
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  export type ParentsAvgAggregateOutputType = {
    id: number | null
  }

  export type ParentsSumAggregateOutputType = {
    id: number | null
  }

  export type ParentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    profession: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    school_id: string | null
  }

  export type ParentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    profession: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    school_id: string | null
  }

  export type ParentsCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    phone: number
    email: number
    adress: number
    gender: number
    profession: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    school_id: number
    _all: number
  }


  export type ParentsAvgAggregateInputType = {
    id?: true
  }

  export type ParentsSumAggregateInputType = {
    id?: true
  }

  export type ParentsMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    profession?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    school_id?: true
  }

  export type ParentsMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    profession?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    school_id?: true
  }

  export type ParentsCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    profession?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    school_id?: true
    _all?: true
  }

  export type ParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to aggregate.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentsMaxAggregateInputType
  }

  export type GetParentsAggregateType<T extends ParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParents[P]>
      : GetScalarType<T[P], AggregateParents[P]>
  }




  export type ParentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentsWhereInput
    orderBy?: ParentsOrderByWithAggregationInput | ParentsOrderByWithAggregationInput[]
    by: ParentsScalarFieldEnum[] | ParentsScalarFieldEnum
    having?: ParentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentsCountAggregateInputType | true
    _avg?: ParentsAvgAggregateInputType
    _sum?: ParentsSumAggregateInputType
    _min?: ParentsMinAggregateInputType
    _max?: ParentsMaxAggregateInputType
  }

  export type ParentsGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    profession: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    school_id: string | null
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  type GetParentsGroupByPayload<T extends ParentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentsGroupByOutputType[P]>
            : GetScalarType<T[P], ParentsGroupByOutputType[P]>
        }
      >
    >


  export type ParentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
    student_parents?: boolean | Parents$student_parentsArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>

  export type ParentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["parents"]>

  export type ParentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["parents"]>

  export type ParentsSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
  }

  export type ParentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "phone" | "email" | "adress" | "gender" | "profession" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted" | "school_id", ExtArgs["result"]["parents"]>
  export type ParentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_parents?: boolean | Parents$student_parentsArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ParentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ParentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parents"
    objects: {
      student_parents: Prisma.$StudentParentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      phone: string | null
      email: string | null
      adress: string | null
      gender: string | null
      profession: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
      school_id: string | null
    }, ExtArgs["result"]["parents"]>
    composites: {}
  }

  type ParentsGetPayload<S extends boolean | null | undefined | ParentsDefaultArgs> = $Result.GetResult<Prisma.$ParentsPayload, S>

  type ParentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentsCountAggregateInputType | true
    }

  export interface ParentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parents'], meta: { name: 'Parents' } }
    /**
     * Find zero or one Parents that matches the filter.
     * @param {ParentsFindUniqueArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentsFindUniqueArgs>(args: SelectSubset<T, ParentsFindUniqueArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentsFindUniqueOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentsFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsFindFirstArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentsFindFirstArgs>(args?: SelectSubset<T, ParentsFindFirstArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsFindFirstOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentsFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parents.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentsWithIdOnly = await prisma.parents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentsFindManyArgs>(args?: SelectSubset<T, ParentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parents.
     * @param {ParentsCreateArgs} args - Arguments to create a Parents.
     * @example
     * // Create one Parents
     * const Parents = await prisma.parents.create({
     *   data: {
     *     // ... data to create a Parents
     *   }
     * })
     * 
     */
    create<T extends ParentsCreateArgs>(args: SelectSubset<T, ParentsCreateArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentsCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentsCreateManyArgs>(args?: SelectSubset<T, ParentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentsCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentsWithIdOnly = await prisma.parents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentsCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parents.
     * @param {ParentsDeleteArgs} args - Arguments to delete one Parents.
     * @example
     * // Delete one Parents
     * const Parents = await prisma.parents.delete({
     *   where: {
     *     // ... filter to delete one Parents
     *   }
     * })
     * 
     */
    delete<T extends ParentsDeleteArgs>(args: SelectSubset<T, ParentsDeleteArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parents.
     * @param {ParentsUpdateArgs} args - Arguments to update one Parents.
     * @example
     * // Update one Parents
     * const parents = await prisma.parents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentsUpdateArgs>(args: SelectSubset<T, ParentsUpdateArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentsDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentsDeleteManyArgs>(args?: SelectSubset<T, ParentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentsUpdateManyArgs>(args: SelectSubset<T, ParentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {ParentsUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `id`
     * const parentsWithIdOnly = await prisma.parents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentsUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parents.
     * @param {ParentsUpsertArgs} args - Arguments to update or create a Parents.
     * @example
     * // Update or create a Parents
     * const parents = await prisma.parents.upsert({
     *   create: {
     *     // ... data to create a Parents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parents we want to update
     *   }
     * })
     */
    upsert<T extends ParentsUpsertArgs>(args: SelectSubset<T, ParentsUpsertArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parents.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentsCountArgs>(
      args?: Subset<T, ParentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentsAggregateArgs>(args: Subset<T, ParentsAggregateArgs>): Prisma.PrismaPromise<GetParentsAggregateType<T>>

    /**
     * Group by Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentsGroupByArgs['orderBy'] }
        : { orderBy?: ParentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parents model
   */
  readonly fields: ParentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student_parents<T extends Parents$student_parentsArgs<ExtArgs> = {}>(args?: Subset<T, Parents$student_parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parents model
   */
  interface ParentsFieldRefs {
    readonly id: FieldRef<"Parents", 'Int'>
    readonly name: FieldRef<"Parents", 'String'>
    readonly first_name: FieldRef<"Parents", 'String'>
    readonly phone: FieldRef<"Parents", 'String'>
    readonly email: FieldRef<"Parents", 'String'>
    readonly adress: FieldRef<"Parents", 'String'>
    readonly gender: FieldRef<"Parents", 'String'>
    readonly profession: FieldRef<"Parents", 'String'>
    readonly supabase_id: FieldRef<"Parents", 'String'>
    readonly last_modified: FieldRef<"Parents", 'DateTime'>
    readonly needs_sync: FieldRef<"Parents", 'Boolean'>
    readonly is_deleted: FieldRef<"Parents", 'Boolean'>
    readonly school_id: FieldRef<"Parents", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parents findUnique
   */
  export type ParentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents findUniqueOrThrow
   */
  export type ParentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents findFirst
   */
  export type ParentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * Parents findFirstOrThrow
   */
  export type ParentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * Parents findMany
   */
  export type ParentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * Parents create
   */
  export type ParentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Parents.
     */
    data?: XOR<ParentsCreateInput, ParentsUncheckedCreateInput>
  }

  /**
   * Parents createMany
   */
  export type ParentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentsCreateManyInput | ParentsCreateManyInput[]
  }

  /**
   * Parents createManyAndReturn
   */
  export type ParentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentsCreateManyInput | ParentsCreateManyInput[]
  }

  /**
   * Parents update
   */
  export type ParentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Parents.
     */
    data: XOR<ParentsUpdateInput, ParentsUncheckedUpdateInput>
    /**
     * Choose, which Parents to update.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents updateMany
   */
  export type ParentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentsUpdateManyMutationInput, ParentsUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentsWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parents updateManyAndReturn
   */
  export type ParentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentsUpdateManyMutationInput, ParentsUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentsWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parents upsert
   */
  export type ParentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Parents to update in case it exists.
     */
    where: ParentsWhereUniqueInput
    /**
     * In case the Parents found by the `where` argument doesn't exist, create a new Parents with this data.
     */
    create: XOR<ParentsCreateInput, ParentsUncheckedCreateInput>
    /**
     * In case the Parents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentsUpdateInput, ParentsUncheckedUpdateInput>
  }

  /**
   * Parents delete
   */
  export type ParentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter which Parents to delete.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents deleteMany
   */
  export type ParentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentsWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parents.student_parents
   */
  export type Parents$student_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    where?: StudentParentsWhereInput
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    cursor?: StudentParentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * Parents without action
   */
  export type ParentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
  }


  /**
   * Model StudentParents
   */

  export type AggregateStudentParents = {
    _count: StudentParentsCountAggregateOutputType | null
    _avg: StudentParentsAvgAggregateOutputType | null
    _sum: StudentParentsSumAggregateOutputType | null
    _min: StudentParentsMinAggregateOutputType | null
    _max: StudentParentsMaxAggregateOutputType | null
  }

  export type StudentParentsAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
  }

  export type StudentParentsSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
  }

  export type StudentParentsMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
    relation: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type StudentParentsMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
    relation: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type StudentParentsCountAggregateOutputType = {
    id: number
    student_id: number
    parent_id: number
    relation: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type StudentParentsAvgAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
  }

  export type StudentParentsSumAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
  }

  export type StudentParentsMinAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
    relation?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type StudentParentsMaxAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
    relation?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type StudentParentsCountAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
    relation?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type StudentParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to aggregate.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParents
    **/
    _count?: true | StudentParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentParentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentParentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentsMaxAggregateInputType
  }

  export type GetStudentParentsAggregateType<T extends StudentParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParents[P]>
      : GetScalarType<T[P], AggregateStudentParents[P]>
  }




  export type StudentParentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentsWhereInput
    orderBy?: StudentParentsOrderByWithAggregationInput | StudentParentsOrderByWithAggregationInput[]
    by: StudentParentsScalarFieldEnum[] | StudentParentsScalarFieldEnum
    having?: StudentParentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentsCountAggregateInputType | true
    _avg?: StudentParentsAvgAggregateInputType
    _sum?: StudentParentsSumAggregateInputType
    _min?: StudentParentsMinAggregateInputType
    _max?: StudentParentsMaxAggregateInputType
  }

  export type StudentParentsGroupByOutputType = {
    id: number
    student_id: number
    parent_id: number
    relation: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: StudentParentsCountAggregateOutputType | null
    _avg: StudentParentsAvgAggregateOutputType | null
    _sum: StudentParentsSumAggregateOutputType | null
    _min: StudentParentsMinAggregateOutputType | null
    _max: StudentParentsMaxAggregateOutputType | null
  }

  type GetStudentParentsGroupByPayload<T extends StudentParentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParents"]>

  export type StudentParentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParents"]>

  export type StudentParentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParents"]>

  export type StudentParentsSelectScalar = {
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "parent_id" | "relation" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["studentParents"]>
  export type StudentParentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type StudentParentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type StudentParentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $StudentParentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentParents"
    objects: {
      parent: Prisma.$ParentsPayload<ExtArgs>
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      parent_id: number
      relation: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["studentParents"]>
    composites: {}
  }

  type StudentParentsGetPayload<S extends boolean | null | undefined | StudentParentsDefaultArgs> = $Result.GetResult<Prisma.$StudentParentsPayload, S>

  type StudentParentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentParentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentParentsCountAggregateInputType | true
    }

  export interface StudentParentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentParents'], meta: { name: 'StudentParents' } }
    /**
     * Find zero or one StudentParents that matches the filter.
     * @param {StudentParentsFindUniqueArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentParentsFindUniqueArgs>(args: SelectSubset<T, StudentParentsFindUniqueArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentParents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentParentsFindUniqueOrThrowArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentParentsFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentParentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindFirstArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentParentsFindFirstArgs>(args?: SelectSubset<T, StudentParentsFindFirstArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindFirstOrThrowArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentParentsFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentParentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParents
     * const studentParents = await prisma.studentParents.findMany()
     * 
     * // Get first 10 StudentParents
     * const studentParents = await prisma.studentParents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentParentsWithIdOnly = await prisma.studentParents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentParentsFindManyArgs>(args?: SelectSubset<T, StudentParentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentParents.
     * @param {StudentParentsCreateArgs} args - Arguments to create a StudentParents.
     * @example
     * // Create one StudentParents
     * const StudentParents = await prisma.studentParents.create({
     *   data: {
     *     // ... data to create a StudentParents
     *   }
     * })
     * 
     */
    create<T extends StudentParentsCreateArgs>(args: SelectSubset<T, StudentParentsCreateArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentParents.
     * @param {StudentParentsCreateManyArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParents = await prisma.studentParents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentParentsCreateManyArgs>(args?: SelectSubset<T, StudentParentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentParents and returns the data saved in the database.
     * @param {StudentParentsCreateManyAndReturnArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParents = await prisma.studentParents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentParents and only return the `id`
     * const studentParentsWithIdOnly = await prisma.studentParents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentParentsCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentParentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentParents.
     * @param {StudentParentsDeleteArgs} args - Arguments to delete one StudentParents.
     * @example
     * // Delete one StudentParents
     * const StudentParents = await prisma.studentParents.delete({
     *   where: {
     *     // ... filter to delete one StudentParents
     *   }
     * })
     * 
     */
    delete<T extends StudentParentsDeleteArgs>(args: SelectSubset<T, StudentParentsDeleteArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentParents.
     * @param {StudentParentsUpdateArgs} args - Arguments to update one StudentParents.
     * @example
     * // Update one StudentParents
     * const studentParents = await prisma.studentParents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentParentsUpdateArgs>(args: SelectSubset<T, StudentParentsUpdateArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentParents.
     * @param {StudentParentsDeleteManyArgs} args - Arguments to filter StudentParents to delete.
     * @example
     * // Delete a few StudentParents
     * const { count } = await prisma.studentParents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentParentsDeleteManyArgs>(args?: SelectSubset<T, StudentParentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParents
     * const studentParents = await prisma.studentParents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentParentsUpdateManyArgs>(args: SelectSubset<T, StudentParentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents and returns the data updated in the database.
     * @param {StudentParentsUpdateManyAndReturnArgs} args - Arguments to update many StudentParents.
     * @example
     * // Update many StudentParents
     * const studentParents = await prisma.studentParents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentParents and only return the `id`
     * const studentParentsWithIdOnly = await prisma.studentParents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentParentsUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentParentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentParents.
     * @param {StudentParentsUpsertArgs} args - Arguments to update or create a StudentParents.
     * @example
     * // Update or create a StudentParents
     * const studentParents = await prisma.studentParents.upsert({
     *   create: {
     *     // ... data to create a StudentParents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParents we want to update
     *   }
     * })
     */
    upsert<T extends StudentParentsUpsertArgs>(args: SelectSubset<T, StudentParentsUpsertArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsCountArgs} args - Arguments to filter StudentParents to count.
     * @example
     * // Count the number of StudentParents
     * const count = await prisma.studentParents.count({
     *   where: {
     *     // ... the filter for the StudentParents we want to count
     *   }
     * })
    **/
    count<T extends StudentParentsCountArgs>(
      args?: Subset<T, StudentParentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentsAggregateArgs>(args: Subset<T, StudentParentsAggregateArgs>): Prisma.PrismaPromise<GetStudentParentsAggregateType<T>>

    /**
     * Group by StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentParents model
   */
  readonly fields: StudentParentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentParentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ParentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentsDefaultArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentParents model
   */
  interface StudentParentsFieldRefs {
    readonly id: FieldRef<"StudentParents", 'Int'>
    readonly student_id: FieldRef<"StudentParents", 'Int'>
    readonly parent_id: FieldRef<"StudentParents", 'Int'>
    readonly relation: FieldRef<"StudentParents", 'String'>
    readonly supabase_id: FieldRef<"StudentParents", 'String'>
    readonly last_modified: FieldRef<"StudentParents", 'DateTime'>
    readonly needs_sync: FieldRef<"StudentParents", 'Boolean'>
    readonly is_deleted: FieldRef<"StudentParents", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StudentParents findUnique
   */
  export type StudentParentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents findUniqueOrThrow
   */
  export type StudentParentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents findFirst
   */
  export type StudentParentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * StudentParents findFirstOrThrow
   */
  export type StudentParentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * StudentParents findMany
   */
  export type StudentParentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * StudentParents create
   */
  export type StudentParentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentParents.
     */
    data: XOR<StudentParentsCreateInput, StudentParentsUncheckedCreateInput>
  }

  /**
   * StudentParents createMany
   */
  export type StudentParentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentsCreateManyInput | StudentParentsCreateManyInput[]
  }

  /**
   * StudentParents createManyAndReturn
   */
  export type StudentParentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentsCreateManyInput | StudentParentsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParents update
   */
  export type StudentParentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentParents.
     */
    data: XOR<StudentParentsUpdateInput, StudentParentsUncheckedUpdateInput>
    /**
     * Choose, which StudentParents to update.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents updateMany
   */
  export type StudentParentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentsWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
  }

  /**
   * StudentParents updateManyAndReturn
   */
  export type StudentParentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentsWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParents upsert
   */
  export type StudentParentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentParents to update in case it exists.
     */
    where: StudentParentsWhereUniqueInput
    /**
     * In case the StudentParents found by the `where` argument doesn't exist, create a new StudentParents with this data.
     */
    create: XOR<StudentParentsCreateInput, StudentParentsUncheckedCreateInput>
    /**
     * In case the StudentParents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentsUpdateInput, StudentParentsUncheckedUpdateInput>
  }

  /**
   * StudentParents delete
   */
  export type StudentParentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter which StudentParents to delete.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents deleteMany
   */
  export type StudentParentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to delete
     */
    where?: StudentParentsWhereInput
    /**
     * Limit how many StudentParents to delete.
     */
    limit?: number
  }

  /**
   * StudentParents without action
   */
  export type StudentParentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
  }


  /**
   * Model Payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    registration_id: number | null
    amount: number | null
    single_fee_id: number | null
    fee_template_id: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    registration_id: number | null
    amount: number | null
    single_fee_id: number | null
    fee_template_id: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    registration_id: number | null
    amount: number | null
    method: string | null
    date: string | null
    reference: string | null
    emitter_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    single_fee_id: number | null
    fee_template_id: number | null
    period_identifier: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    registration_id: number | null
    amount: number | null
    method: string | null
    date: string | null
    reference: string | null
    emitter_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    single_fee_id: number | null
    fee_template_id: number | null
    period_identifier: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    registration_id: number
    amount: number
    method: number
    date: number
    reference: number
    emitter_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    single_fee_id: number
    fee_template_id: number
    period_identifier: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    registration_id?: true
    amount?: true
    single_fee_id?: true
    fee_template_id?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    registration_id?: true
    amount?: true
    single_fee_id?: true
    fee_template_id?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    registration_id?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    emitter_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    single_fee_id?: true
    fee_template_id?: true
    period_identifier?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    registration_id?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    emitter_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    single_fee_id?: true
    fee_template_id?: true
    period_identifier?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    registration_id?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    emitter_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    single_fee_id?: true
    fee_template_id?: true
    period_identifier?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to aggregate.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithAggregationInput | PaymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    registration_id: number | null
    amount: number | null
    method: string | null
    date: string | null
    reference: string | null
    emitter_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    single_fee_id: number | null
    fee_template_id: number | null
    period_identifier: string | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: boolean
    fee_template_id?: boolean
    period_identifier?: boolean
    registration?: boolean | Payments$registrationArgs<ExtArgs>
    single_fee?: boolean | Payments$single_feeArgs<ExtArgs>
    fee_template?: boolean | Payments$fee_templateArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: boolean
    fee_template_id?: boolean
    period_identifier?: boolean
    registration?: boolean | Payments$registrationArgs<ExtArgs>
    single_fee?: boolean | Payments$single_feeArgs<ExtArgs>
    fee_template?: boolean | Payments$fee_templateArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: boolean
    fee_template_id?: boolean
    period_identifier?: boolean
    registration?: boolean | Payments$registrationArgs<ExtArgs>
    single_fee?: boolean | Payments$single_feeArgs<ExtArgs>
    fee_template?: boolean | Payments$fee_templateArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectScalar = {
    id?: boolean
    registration_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: boolean
    fee_template_id?: boolean
    period_identifier?: boolean
  }

  export type PaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "registration_id" | "amount" | "method" | "date" | "reference" | "emitter_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted" | "single_fee_id" | "fee_template_id" | "period_identifier", ExtArgs["result"]["payments"]>
  export type PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registration?: boolean | Payments$registrationArgs<ExtArgs>
    single_fee?: boolean | Payments$single_feeArgs<ExtArgs>
    fee_template?: boolean | Payments$fee_templateArgs<ExtArgs>
  }
  export type PaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registration?: boolean | Payments$registrationArgs<ExtArgs>
    single_fee?: boolean | Payments$single_feeArgs<ExtArgs>
    fee_template?: boolean | Payments$fee_templateArgs<ExtArgs>
  }
  export type PaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registration?: boolean | Payments$registrationArgs<ExtArgs>
    single_fee?: boolean | Payments$single_feeArgs<ExtArgs>
    fee_template?: boolean | Payments$fee_templateArgs<ExtArgs>
  }

  export type $PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payments"
    objects: {
      registration: Prisma.$RegistrationsPayload<ExtArgs> | null
      single_fee: Prisma.$SingleFeePayload<ExtArgs> | null
      fee_template: Prisma.$FeeTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      registration_id: number | null
      amount: number | null
      method: string | null
      date: string | null
      reference: string | null
      emitter_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
      single_fee_id: number | null
      fee_template_id: number | null
      period_identifier: string | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type PaymentsGetPayload<S extends boolean | null | undefined | PaymentsDefaultArgs> = $Result.GetResult<Prisma.$PaymentsPayload, S>

  type PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payments'], meta: { name: 'Payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {PaymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentsFindUniqueArgs>(args: SelectSubset<T, PaymentsFindUniqueArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentsFindFirstArgs>(args?: SelectSubset<T, PaymentsFindFirstArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentsFindManyArgs>(args?: SelectSubset<T, PaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {PaymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends PaymentsCreateArgs>(args: SelectSubset<T, PaymentsCreateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentsCreateManyArgs>(args?: SelectSubset<T, PaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {PaymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends PaymentsDeleteArgs>(args: SelectSubset<T, PaymentsDeleteArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {PaymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentsUpdateArgs>(args: SelectSubset<T, PaymentsUpdateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentsDeleteManyArgs>(args?: SelectSubset<T, PaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentsUpdateManyArgs>(args: SelectSubset<T, PaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {PaymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends PaymentsUpsertArgs>(args: SelectSubset<T, PaymentsUpsertArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentsCountArgs>(
      args?: Subset<T, PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payments model
   */
  readonly fields: PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    registration<T extends Payments$registrationArgs<ExtArgs> = {}>(args?: Subset<T, Payments$registrationArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    single_fee<T extends Payments$single_feeArgs<ExtArgs> = {}>(args?: Subset<T, Payments$single_feeArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fee_template<T extends Payments$fee_templateArgs<ExtArgs> = {}>(args?: Subset<T, Payments$fee_templateArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payments model
   */
  interface PaymentsFieldRefs {
    readonly id: FieldRef<"Payments", 'Int'>
    readonly registration_id: FieldRef<"Payments", 'Int'>
    readonly amount: FieldRef<"Payments", 'Float'>
    readonly method: FieldRef<"Payments", 'String'>
    readonly date: FieldRef<"Payments", 'String'>
    readonly reference: FieldRef<"Payments", 'String'>
    readonly emitter_id: FieldRef<"Payments", 'String'>
    readonly supabase_id: FieldRef<"Payments", 'String'>
    readonly last_modified: FieldRef<"Payments", 'DateTime'>
    readonly needs_sync: FieldRef<"Payments", 'Boolean'>
    readonly is_deleted: FieldRef<"Payments", 'Boolean'>
    readonly single_fee_id: FieldRef<"Payments", 'Int'>
    readonly fee_template_id: FieldRef<"Payments", 'Int'>
    readonly period_identifier: FieldRef<"Payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payments findUnique
   */
  export type PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findUniqueOrThrow
   */
  export type PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findFirst
   */
  export type PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findFirstOrThrow
   */
  export type PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findMany
   */
  export type PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments create
   */
  export type PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Payments.
     */
    data?: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
  }

  /**
   * Payments createMany
   */
  export type PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
  }

  /**
   * Payments createManyAndReturn
   */
  export type PaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments update
   */
  export type PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Payments.
     */
    data: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Payments to update.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments updateMany
   */
  export type PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payments updateManyAndReturn
   */
  export type PaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments upsert
   */
  export type PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Payments to update in case it exists.
     */
    where: PaymentsWhereUniqueInput
    /**
     * In case the Payments found by the `where` argument doesn't exist, create a new Payments with this data.
     */
    create: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
    /**
     * In case the Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
  }

  /**
   * Payments delete
   */
  export type PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Payments to delete.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments deleteMany
   */
  export type PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payments.registration
   */
  export type Payments$registrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    where?: RegistrationsWhereInput
  }

  /**
   * Payments.single_fee
   */
  export type Payments$single_feeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    where?: SingleFeeWhereInput
  }

  /**
   * Payments.fee_template
   */
  export type Payments$fee_templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    where?: FeeTemplateWhereInput
  }

  /**
   * Payments without action
   */
  export type PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model SingleFee
   */

  export type AggregateSingleFee = {
    _count: SingleFeeCountAggregateOutputType | null
    _avg: SingleFeeAvgAggregateOutputType | null
    _sum: SingleFeeSumAggregateOutputType | null
    _min: SingleFeeMinAggregateOutputType | null
    _max: SingleFeeMaxAggregateOutputType | null
  }

  export type SingleFeeAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    class_id: number | null
  }

  export type SingleFeeSumAggregateOutputType = {
    id: number | null
    amount: number | null
    class_id: number | null
  }

  export type SingleFeeMinAggregateOutputType = {
    id: number | null
    name: string | null
    amount: number | null
    due_date: string | null
    school_year: string | null
    level: string | null
    class_id: number | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SingleFeeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    amount: number | null
    due_date: string | null
    school_year: string | null
    level: string | null
    class_id: number | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SingleFeeCountAggregateOutputType = {
    id: number
    name: number
    amount: number
    due_date: number
    school_year: number
    level: number
    class_id: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type SingleFeeAvgAggregateInputType = {
    id?: true
    amount?: true
    class_id?: true
  }

  export type SingleFeeSumAggregateInputType = {
    id?: true
    amount?: true
    class_id?: true
  }

  export type SingleFeeMinAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    due_date?: true
    school_year?: true
    level?: true
    class_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SingleFeeMaxAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    due_date?: true
    school_year?: true
    level?: true
    class_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SingleFeeCountAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    due_date?: true
    school_year?: true
    level?: true
    class_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type SingleFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SingleFee to aggregate.
     */
    where?: SingleFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleFees to fetch.
     */
    orderBy?: SingleFeeOrderByWithRelationInput | SingleFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SingleFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SingleFees
    **/
    _count?: true | SingleFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SingleFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SingleFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SingleFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SingleFeeMaxAggregateInputType
  }

  export type GetSingleFeeAggregateType<T extends SingleFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateSingleFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSingleFee[P]>
      : GetScalarType<T[P], AggregateSingleFee[P]>
  }




  export type SingleFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SingleFeeWhereInput
    orderBy?: SingleFeeOrderByWithAggregationInput | SingleFeeOrderByWithAggregationInput[]
    by: SingleFeeScalarFieldEnum[] | SingleFeeScalarFieldEnum
    having?: SingleFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SingleFeeCountAggregateInputType | true
    _avg?: SingleFeeAvgAggregateInputType
    _sum?: SingleFeeSumAggregateInputType
    _min?: SingleFeeMinAggregateInputType
    _max?: SingleFeeMaxAggregateInputType
  }

  export type SingleFeeGroupByOutputType = {
    id: number
    name: string | null
    amount: number | null
    due_date: string | null
    school_year: string | null
    level: string | null
    class_id: number | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: SingleFeeCountAggregateOutputType | null
    _avg: SingleFeeAvgAggregateOutputType | null
    _sum: SingleFeeSumAggregateOutputType | null
    _min: SingleFeeMinAggregateOutputType | null
    _max: SingleFeeMaxAggregateOutputType | null
  }

  type GetSingleFeeGroupByPayload<T extends SingleFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SingleFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SingleFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SingleFeeGroupByOutputType[P]>
            : GetScalarType<T[P], SingleFeeGroupByOutputType[P]>
        }
      >
    >


  export type SingleFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    class_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | SingleFee$classArgs<ExtArgs>
    payments?: boolean | SingleFee$paymentsArgs<ExtArgs>
    dispatch_rules?: boolean | SingleFee$dispatch_rulesArgs<ExtArgs>
    _count?: boolean | SingleFeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["singleFee"]>

  export type SingleFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    class_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | SingleFee$classArgs<ExtArgs>
  }, ExtArgs["result"]["singleFee"]>

  export type SingleFeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    class_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | SingleFee$classArgs<ExtArgs>
  }, ExtArgs["result"]["singleFee"]>

  export type SingleFeeSelectScalar = {
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    class_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SingleFeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "amount" | "due_date" | "school_year" | "level" | "class_id" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["singleFee"]>
  export type SingleFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | SingleFee$classArgs<ExtArgs>
    payments?: boolean | SingleFee$paymentsArgs<ExtArgs>
    dispatch_rules?: boolean | SingleFee$dispatch_rulesArgs<ExtArgs>
    _count?: boolean | SingleFeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SingleFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | SingleFee$classArgs<ExtArgs>
  }
  export type SingleFeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | SingleFee$classArgs<ExtArgs>
  }

  export type $SingleFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SingleFee"
    objects: {
      class: Prisma.$ClassesPayload<ExtArgs> | null
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
      dispatch_rules: Prisma.$DispatchRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      amount: number | null
      due_date: string | null
      school_year: string | null
      level: string | null
      class_id: number | null
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["singleFee"]>
    composites: {}
  }

  type SingleFeeGetPayload<S extends boolean | null | undefined | SingleFeeDefaultArgs> = $Result.GetResult<Prisma.$SingleFeePayload, S>

  type SingleFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SingleFeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SingleFeeCountAggregateInputType | true
    }

  export interface SingleFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SingleFee'], meta: { name: 'SingleFee' } }
    /**
     * Find zero or one SingleFee that matches the filter.
     * @param {SingleFeeFindUniqueArgs} args - Arguments to find a SingleFee
     * @example
     * // Get one SingleFee
     * const singleFee = await prisma.singleFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SingleFeeFindUniqueArgs>(args: SelectSubset<T, SingleFeeFindUniqueArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SingleFee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SingleFeeFindUniqueOrThrowArgs} args - Arguments to find a SingleFee
     * @example
     * // Get one SingleFee
     * const singleFee = await prisma.singleFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SingleFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, SingleFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SingleFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleFeeFindFirstArgs} args - Arguments to find a SingleFee
     * @example
     * // Get one SingleFee
     * const singleFee = await prisma.singleFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SingleFeeFindFirstArgs>(args?: SelectSubset<T, SingleFeeFindFirstArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SingleFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleFeeFindFirstOrThrowArgs} args - Arguments to find a SingleFee
     * @example
     * // Get one SingleFee
     * const singleFee = await prisma.singleFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SingleFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, SingleFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SingleFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SingleFees
     * const singleFees = await prisma.singleFee.findMany()
     * 
     * // Get first 10 SingleFees
     * const singleFees = await prisma.singleFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const singleFeeWithIdOnly = await prisma.singleFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SingleFeeFindManyArgs>(args?: SelectSubset<T, SingleFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SingleFee.
     * @param {SingleFeeCreateArgs} args - Arguments to create a SingleFee.
     * @example
     * // Create one SingleFee
     * const SingleFee = await prisma.singleFee.create({
     *   data: {
     *     // ... data to create a SingleFee
     *   }
     * })
     * 
     */
    create<T extends SingleFeeCreateArgs>(args: SelectSubset<T, SingleFeeCreateArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SingleFees.
     * @param {SingleFeeCreateManyArgs} args - Arguments to create many SingleFees.
     * @example
     * // Create many SingleFees
     * const singleFee = await prisma.singleFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SingleFeeCreateManyArgs>(args?: SelectSubset<T, SingleFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SingleFees and returns the data saved in the database.
     * @param {SingleFeeCreateManyAndReturnArgs} args - Arguments to create many SingleFees.
     * @example
     * // Create many SingleFees
     * const singleFee = await prisma.singleFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SingleFees and only return the `id`
     * const singleFeeWithIdOnly = await prisma.singleFee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SingleFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, SingleFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SingleFee.
     * @param {SingleFeeDeleteArgs} args - Arguments to delete one SingleFee.
     * @example
     * // Delete one SingleFee
     * const SingleFee = await prisma.singleFee.delete({
     *   where: {
     *     // ... filter to delete one SingleFee
     *   }
     * })
     * 
     */
    delete<T extends SingleFeeDeleteArgs>(args: SelectSubset<T, SingleFeeDeleteArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SingleFee.
     * @param {SingleFeeUpdateArgs} args - Arguments to update one SingleFee.
     * @example
     * // Update one SingleFee
     * const singleFee = await prisma.singleFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SingleFeeUpdateArgs>(args: SelectSubset<T, SingleFeeUpdateArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SingleFees.
     * @param {SingleFeeDeleteManyArgs} args - Arguments to filter SingleFees to delete.
     * @example
     * // Delete a few SingleFees
     * const { count } = await prisma.singleFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SingleFeeDeleteManyArgs>(args?: SelectSubset<T, SingleFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SingleFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SingleFees
     * const singleFee = await prisma.singleFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SingleFeeUpdateManyArgs>(args: SelectSubset<T, SingleFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SingleFees and returns the data updated in the database.
     * @param {SingleFeeUpdateManyAndReturnArgs} args - Arguments to update many SingleFees.
     * @example
     * // Update many SingleFees
     * const singleFee = await prisma.singleFee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SingleFees and only return the `id`
     * const singleFeeWithIdOnly = await prisma.singleFee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SingleFeeUpdateManyAndReturnArgs>(args: SelectSubset<T, SingleFeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SingleFee.
     * @param {SingleFeeUpsertArgs} args - Arguments to update or create a SingleFee.
     * @example
     * // Update or create a SingleFee
     * const singleFee = await prisma.singleFee.upsert({
     *   create: {
     *     // ... data to create a SingleFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SingleFee we want to update
     *   }
     * })
     */
    upsert<T extends SingleFeeUpsertArgs>(args: SelectSubset<T, SingleFeeUpsertArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SingleFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleFeeCountArgs} args - Arguments to filter SingleFees to count.
     * @example
     * // Count the number of SingleFees
     * const count = await prisma.singleFee.count({
     *   where: {
     *     // ... the filter for the SingleFees we want to count
     *   }
     * })
    **/
    count<T extends SingleFeeCountArgs>(
      args?: Subset<T, SingleFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SingleFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SingleFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SingleFeeAggregateArgs>(args: Subset<T, SingleFeeAggregateArgs>): Prisma.PrismaPromise<GetSingleFeeAggregateType<T>>

    /**
     * Group by SingleFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SingleFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SingleFeeGroupByArgs['orderBy'] }
        : { orderBy?: SingleFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SingleFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSingleFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SingleFee model
   */
  readonly fields: SingleFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SingleFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SingleFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends SingleFee$classArgs<ExtArgs> = {}>(args?: Subset<T, SingleFee$classArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends SingleFee$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, SingleFee$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatch_rules<T extends SingleFee$dispatch_rulesArgs<ExtArgs> = {}>(args?: Subset<T, SingleFee$dispatch_rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SingleFee model
   */
  interface SingleFeeFieldRefs {
    readonly id: FieldRef<"SingleFee", 'Int'>
    readonly name: FieldRef<"SingleFee", 'String'>
    readonly amount: FieldRef<"SingleFee", 'Float'>
    readonly due_date: FieldRef<"SingleFee", 'String'>
    readonly school_year: FieldRef<"SingleFee", 'String'>
    readonly level: FieldRef<"SingleFee", 'String'>
    readonly class_id: FieldRef<"SingleFee", 'Int'>
    readonly school_id: FieldRef<"SingleFee", 'String'>
    readonly supabase_id: FieldRef<"SingleFee", 'String'>
    readonly last_modified: FieldRef<"SingleFee", 'DateTime'>
    readonly needs_sync: FieldRef<"SingleFee", 'Boolean'>
    readonly is_deleted: FieldRef<"SingleFee", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SingleFee findUnique
   */
  export type SingleFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * Filter, which SingleFee to fetch.
     */
    where: SingleFeeWhereUniqueInput
  }

  /**
   * SingleFee findUniqueOrThrow
   */
  export type SingleFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * Filter, which SingleFee to fetch.
     */
    where: SingleFeeWhereUniqueInput
  }

  /**
   * SingleFee findFirst
   */
  export type SingleFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * Filter, which SingleFee to fetch.
     */
    where?: SingleFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleFees to fetch.
     */
    orderBy?: SingleFeeOrderByWithRelationInput | SingleFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SingleFees.
     */
    cursor?: SingleFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SingleFees.
     */
    distinct?: SingleFeeScalarFieldEnum | SingleFeeScalarFieldEnum[]
  }

  /**
   * SingleFee findFirstOrThrow
   */
  export type SingleFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * Filter, which SingleFee to fetch.
     */
    where?: SingleFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleFees to fetch.
     */
    orderBy?: SingleFeeOrderByWithRelationInput | SingleFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SingleFees.
     */
    cursor?: SingleFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SingleFees.
     */
    distinct?: SingleFeeScalarFieldEnum | SingleFeeScalarFieldEnum[]
  }

  /**
   * SingleFee findMany
   */
  export type SingleFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * Filter, which SingleFees to fetch.
     */
    where?: SingleFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleFees to fetch.
     */
    orderBy?: SingleFeeOrderByWithRelationInput | SingleFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SingleFees.
     */
    cursor?: SingleFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleFees.
     */
    skip?: number
    distinct?: SingleFeeScalarFieldEnum | SingleFeeScalarFieldEnum[]
  }

  /**
   * SingleFee create
   */
  export type SingleFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a SingleFee.
     */
    data?: XOR<SingleFeeCreateInput, SingleFeeUncheckedCreateInput>
  }

  /**
   * SingleFee createMany
   */
  export type SingleFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SingleFees.
     */
    data: SingleFeeCreateManyInput | SingleFeeCreateManyInput[]
  }

  /**
   * SingleFee createManyAndReturn
   */
  export type SingleFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * The data used to create many SingleFees.
     */
    data: SingleFeeCreateManyInput | SingleFeeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SingleFee update
   */
  export type SingleFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a SingleFee.
     */
    data: XOR<SingleFeeUpdateInput, SingleFeeUncheckedUpdateInput>
    /**
     * Choose, which SingleFee to update.
     */
    where: SingleFeeWhereUniqueInput
  }

  /**
   * SingleFee updateMany
   */
  export type SingleFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SingleFees.
     */
    data: XOR<SingleFeeUpdateManyMutationInput, SingleFeeUncheckedUpdateManyInput>
    /**
     * Filter which SingleFees to update
     */
    where?: SingleFeeWhereInput
    /**
     * Limit how many SingleFees to update.
     */
    limit?: number
  }

  /**
   * SingleFee updateManyAndReturn
   */
  export type SingleFeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * The data used to update SingleFees.
     */
    data: XOR<SingleFeeUpdateManyMutationInput, SingleFeeUncheckedUpdateManyInput>
    /**
     * Filter which SingleFees to update
     */
    where?: SingleFeeWhereInput
    /**
     * Limit how many SingleFees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SingleFee upsert
   */
  export type SingleFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the SingleFee to update in case it exists.
     */
    where: SingleFeeWhereUniqueInput
    /**
     * In case the SingleFee found by the `where` argument doesn't exist, create a new SingleFee with this data.
     */
    create: XOR<SingleFeeCreateInput, SingleFeeUncheckedCreateInput>
    /**
     * In case the SingleFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SingleFeeUpdateInput, SingleFeeUncheckedUpdateInput>
  }

  /**
   * SingleFee delete
   */
  export type SingleFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
    /**
     * Filter which SingleFee to delete.
     */
    where: SingleFeeWhereUniqueInput
  }

  /**
   * SingleFee deleteMany
   */
  export type SingleFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SingleFees to delete
     */
    where?: SingleFeeWhereInput
    /**
     * Limit how many SingleFees to delete.
     */
    limit?: number
  }

  /**
   * SingleFee.class
   */
  export type SingleFee$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    where?: ClassesWhereInput
  }

  /**
   * SingleFee.payments
   */
  export type SingleFee$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * SingleFee.dispatch_rules
   */
  export type SingleFee$dispatch_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    where?: DispatchRuleWhereInput
    orderBy?: DispatchRuleOrderByWithRelationInput | DispatchRuleOrderByWithRelationInput[]
    cursor?: DispatchRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchRuleScalarFieldEnum | DispatchRuleScalarFieldEnum[]
  }

  /**
   * SingleFee without action
   */
  export type SingleFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleFee
     */
    select?: SingleFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SingleFee
     */
    omit?: SingleFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SingleFeeInclude<ExtArgs> | null
  }


  /**
   * Model FeeTemplate
   */

  export type AggregateFeeTemplate = {
    _count: FeeTemplateCountAggregateOutputType | null
    _avg: FeeTemplateAvgAggregateOutputType | null
    _sum: FeeTemplateSumAggregateOutputType | null
    _min: FeeTemplateMinAggregateOutputType | null
    _max: FeeTemplateMaxAggregateOutputType | null
  }

  export type FeeTemplateAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    due_day: number | null
    applies_to_class_id: number | null
  }

  export type FeeTemplateSumAggregateOutputType = {
    id: number | null
    amount: number | null
    due_day: number | null
    applies_to_class_id: number | null
  }

  export type FeeTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    amount: number | null
    frequency: string | null
    due_day: number | null
    school_id: string | null
    applies_to_level: string | null
    applies_to_class_id: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FeeTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    amount: number | null
    frequency: string | null
    due_day: number | null
    school_id: string | null
    applies_to_level: string | null
    applies_to_class_id: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FeeTemplateCountAggregateOutputType = {
    id: number
    name: number
    amount: number
    frequency: number
    due_day: number
    applicable_months: number
    school_id: number
    applies_to_level: number
    applies_to_class_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type FeeTemplateAvgAggregateInputType = {
    id?: true
    amount?: true
    due_day?: true
    applies_to_class_id?: true
  }

  export type FeeTemplateSumAggregateInputType = {
    id?: true
    amount?: true
    due_day?: true
    applies_to_class_id?: true
  }

  export type FeeTemplateMinAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    frequency?: true
    due_day?: true
    school_id?: true
    applies_to_level?: true
    applies_to_class_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FeeTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    frequency?: true
    due_day?: true
    school_id?: true
    applies_to_level?: true
    applies_to_class_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FeeTemplateCountAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    frequency?: true
    due_day?: true
    applicable_months?: true
    school_id?: true
    applies_to_level?: true
    applies_to_class_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type FeeTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeTemplate to aggregate.
     */
    where?: FeeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeTemplates to fetch.
     */
    orderBy?: FeeTemplateOrderByWithRelationInput | FeeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeTemplates
    **/
    _count?: true | FeeTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeTemplateMaxAggregateInputType
  }

  export type GetFeeTemplateAggregateType<T extends FeeTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeTemplate[P]>
      : GetScalarType<T[P], AggregateFeeTemplate[P]>
  }




  export type FeeTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeTemplateWhereInput
    orderBy?: FeeTemplateOrderByWithAggregationInput | FeeTemplateOrderByWithAggregationInput[]
    by: FeeTemplateScalarFieldEnum[] | FeeTemplateScalarFieldEnum
    having?: FeeTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeTemplateCountAggregateInputType | true
    _avg?: FeeTemplateAvgAggregateInputType
    _sum?: FeeTemplateSumAggregateInputType
    _min?: FeeTemplateMinAggregateInputType
    _max?: FeeTemplateMaxAggregateInputType
  }

  export type FeeTemplateGroupByOutputType = {
    id: number
    name: string
    amount: number
    frequency: string
    due_day: number | null
    applicable_months: JsonValue | null
    school_id: string
    applies_to_level: string | null
    applies_to_class_id: number | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: FeeTemplateCountAggregateOutputType | null
    _avg: FeeTemplateAvgAggregateOutputType | null
    _sum: FeeTemplateSumAggregateOutputType | null
    _min: FeeTemplateMinAggregateOutputType | null
    _max: FeeTemplateMaxAggregateOutputType | null
  }

  type GetFeeTemplateGroupByPayload<T extends FeeTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], FeeTemplateGroupByOutputType[P]>
        }
      >
    >


  export type FeeTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    frequency?: boolean
    due_day?: boolean
    applicable_months?: boolean
    school_id?: boolean
    applies_to_level?: boolean
    applies_to_class_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | FeeTemplate$classArgs<ExtArgs>
    payments?: boolean | FeeTemplate$paymentsArgs<ExtArgs>
    _count?: boolean | FeeTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeTemplate"]>

  export type FeeTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    frequency?: boolean
    due_day?: boolean
    applicable_months?: boolean
    school_id?: boolean
    applies_to_level?: boolean
    applies_to_class_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | FeeTemplate$classArgs<ExtArgs>
  }, ExtArgs["result"]["feeTemplate"]>

  export type FeeTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    frequency?: boolean
    due_day?: boolean
    applicable_months?: boolean
    school_id?: boolean
    applies_to_level?: boolean
    applies_to_class_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | FeeTemplate$classArgs<ExtArgs>
  }, ExtArgs["result"]["feeTemplate"]>

  export type FeeTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    amount?: boolean
    frequency?: boolean
    due_day?: boolean
    applicable_months?: boolean
    school_id?: boolean
    applies_to_level?: boolean
    applies_to_class_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeeTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "amount" | "frequency" | "due_day" | "applicable_months" | "school_id" | "applies_to_level" | "applies_to_class_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["feeTemplate"]>
  export type FeeTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | FeeTemplate$classArgs<ExtArgs>
    payments?: boolean | FeeTemplate$paymentsArgs<ExtArgs>
    _count?: boolean | FeeTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | FeeTemplate$classArgs<ExtArgs>
  }
  export type FeeTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | FeeTemplate$classArgs<ExtArgs>
  }

  export type $FeeTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeTemplate"
    objects: {
      class: Prisma.$ClassesPayload<ExtArgs> | null
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      amount: number
      frequency: string
      due_day: number | null
      applicable_months: Prisma.JsonValue | null
      school_id: string
      applies_to_level: string | null
      applies_to_class_id: number | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["feeTemplate"]>
    composites: {}
  }

  type FeeTemplateGetPayload<S extends boolean | null | undefined | FeeTemplateDefaultArgs> = $Result.GetResult<Prisma.$FeeTemplatePayload, S>

  type FeeTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeTemplateCountAggregateInputType | true
    }

  export interface FeeTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeTemplate'], meta: { name: 'FeeTemplate' } }
    /**
     * Find zero or one FeeTemplate that matches the filter.
     * @param {FeeTemplateFindUniqueArgs} args - Arguments to find a FeeTemplate
     * @example
     * // Get one FeeTemplate
     * const feeTemplate = await prisma.feeTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeTemplateFindUniqueArgs>(args: SelectSubset<T, FeeTemplateFindUniqueArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeTemplateFindUniqueOrThrowArgs} args - Arguments to find a FeeTemplate
     * @example
     * // Get one FeeTemplate
     * const feeTemplate = await prisma.feeTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeTemplateFindFirstArgs} args - Arguments to find a FeeTemplate
     * @example
     * // Get one FeeTemplate
     * const feeTemplate = await prisma.feeTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeTemplateFindFirstArgs>(args?: SelectSubset<T, FeeTemplateFindFirstArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeTemplateFindFirstOrThrowArgs} args - Arguments to find a FeeTemplate
     * @example
     * // Get one FeeTemplate
     * const feeTemplate = await prisma.feeTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeTemplates
     * const feeTemplates = await prisma.feeTemplate.findMany()
     * 
     * // Get first 10 FeeTemplates
     * const feeTemplates = await prisma.feeTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeTemplateWithIdOnly = await prisma.feeTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeTemplateFindManyArgs>(args?: SelectSubset<T, FeeTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeTemplate.
     * @param {FeeTemplateCreateArgs} args - Arguments to create a FeeTemplate.
     * @example
     * // Create one FeeTemplate
     * const FeeTemplate = await prisma.feeTemplate.create({
     *   data: {
     *     // ... data to create a FeeTemplate
     *   }
     * })
     * 
     */
    create<T extends FeeTemplateCreateArgs>(args: SelectSubset<T, FeeTemplateCreateArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeTemplates.
     * @param {FeeTemplateCreateManyArgs} args - Arguments to create many FeeTemplates.
     * @example
     * // Create many FeeTemplates
     * const feeTemplate = await prisma.feeTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeTemplateCreateManyArgs>(args?: SelectSubset<T, FeeTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeTemplates and returns the data saved in the database.
     * @param {FeeTemplateCreateManyAndReturnArgs} args - Arguments to create many FeeTemplates.
     * @example
     * // Create many FeeTemplates
     * const feeTemplate = await prisma.feeTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeTemplates and only return the `id`
     * const feeTemplateWithIdOnly = await prisma.feeTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeTemplate.
     * @param {FeeTemplateDeleteArgs} args - Arguments to delete one FeeTemplate.
     * @example
     * // Delete one FeeTemplate
     * const FeeTemplate = await prisma.feeTemplate.delete({
     *   where: {
     *     // ... filter to delete one FeeTemplate
     *   }
     * })
     * 
     */
    delete<T extends FeeTemplateDeleteArgs>(args: SelectSubset<T, FeeTemplateDeleteArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeTemplate.
     * @param {FeeTemplateUpdateArgs} args - Arguments to update one FeeTemplate.
     * @example
     * // Update one FeeTemplate
     * const feeTemplate = await prisma.feeTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeTemplateUpdateArgs>(args: SelectSubset<T, FeeTemplateUpdateArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeTemplates.
     * @param {FeeTemplateDeleteManyArgs} args - Arguments to filter FeeTemplates to delete.
     * @example
     * // Delete a few FeeTemplates
     * const { count } = await prisma.feeTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeTemplateDeleteManyArgs>(args?: SelectSubset<T, FeeTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeTemplates
     * const feeTemplate = await prisma.feeTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeTemplateUpdateManyArgs>(args: SelectSubset<T, FeeTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeTemplates and returns the data updated in the database.
     * @param {FeeTemplateUpdateManyAndReturnArgs} args - Arguments to update many FeeTemplates.
     * @example
     * // Update many FeeTemplates
     * const feeTemplate = await prisma.feeTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeTemplates and only return the `id`
     * const feeTemplateWithIdOnly = await prisma.feeTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeTemplate.
     * @param {FeeTemplateUpsertArgs} args - Arguments to update or create a FeeTemplate.
     * @example
     * // Update or create a FeeTemplate
     * const feeTemplate = await prisma.feeTemplate.upsert({
     *   create: {
     *     // ... data to create a FeeTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeTemplate we want to update
     *   }
     * })
     */
    upsert<T extends FeeTemplateUpsertArgs>(args: SelectSubset<T, FeeTemplateUpsertArgs<ExtArgs>>): Prisma__FeeTemplateClient<$Result.GetResult<Prisma.$FeeTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeTemplateCountArgs} args - Arguments to filter FeeTemplates to count.
     * @example
     * // Count the number of FeeTemplates
     * const count = await prisma.feeTemplate.count({
     *   where: {
     *     // ... the filter for the FeeTemplates we want to count
     *   }
     * })
    **/
    count<T extends FeeTemplateCountArgs>(
      args?: Subset<T, FeeTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeTemplateAggregateArgs>(args: Subset<T, FeeTemplateAggregateArgs>): Prisma.PrismaPromise<GetFeeTemplateAggregateType<T>>

    /**
     * Group by FeeTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeTemplateGroupByArgs['orderBy'] }
        : { orderBy?: FeeTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeTemplate model
   */
  readonly fields: FeeTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends FeeTemplate$classArgs<ExtArgs> = {}>(args?: Subset<T, FeeTemplate$classArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends FeeTemplate$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, FeeTemplate$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeTemplate model
   */
  interface FeeTemplateFieldRefs {
    readonly id: FieldRef<"FeeTemplate", 'Int'>
    readonly name: FieldRef<"FeeTemplate", 'String'>
    readonly amount: FieldRef<"FeeTemplate", 'Float'>
    readonly frequency: FieldRef<"FeeTemplate", 'String'>
    readonly due_day: FieldRef<"FeeTemplate", 'Int'>
    readonly applicable_months: FieldRef<"FeeTemplate", 'Json'>
    readonly school_id: FieldRef<"FeeTemplate", 'String'>
    readonly applies_to_level: FieldRef<"FeeTemplate", 'String'>
    readonly applies_to_class_id: FieldRef<"FeeTemplate", 'Int'>
    readonly supabase_id: FieldRef<"FeeTemplate", 'String'>
    readonly last_modified: FieldRef<"FeeTemplate", 'DateTime'>
    readonly needs_sync: FieldRef<"FeeTemplate", 'Boolean'>
    readonly is_deleted: FieldRef<"FeeTemplate", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FeeTemplate findUnique
   */
  export type FeeTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FeeTemplate to fetch.
     */
    where: FeeTemplateWhereUniqueInput
  }

  /**
   * FeeTemplate findUniqueOrThrow
   */
  export type FeeTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FeeTemplate to fetch.
     */
    where: FeeTemplateWhereUniqueInput
  }

  /**
   * FeeTemplate findFirst
   */
  export type FeeTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FeeTemplate to fetch.
     */
    where?: FeeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeTemplates to fetch.
     */
    orderBy?: FeeTemplateOrderByWithRelationInput | FeeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeTemplates.
     */
    cursor?: FeeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeTemplates.
     */
    distinct?: FeeTemplateScalarFieldEnum | FeeTemplateScalarFieldEnum[]
  }

  /**
   * FeeTemplate findFirstOrThrow
   */
  export type FeeTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FeeTemplate to fetch.
     */
    where?: FeeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeTemplates to fetch.
     */
    orderBy?: FeeTemplateOrderByWithRelationInput | FeeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeTemplates.
     */
    cursor?: FeeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeTemplates.
     */
    distinct?: FeeTemplateScalarFieldEnum | FeeTemplateScalarFieldEnum[]
  }

  /**
   * FeeTemplate findMany
   */
  export type FeeTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FeeTemplates to fetch.
     */
    where?: FeeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeTemplates to fetch.
     */
    orderBy?: FeeTemplateOrderByWithRelationInput | FeeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeTemplates.
     */
    cursor?: FeeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeTemplates.
     */
    skip?: number
    distinct?: FeeTemplateScalarFieldEnum | FeeTemplateScalarFieldEnum[]
  }

  /**
   * FeeTemplate create
   */
  export type FeeTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeTemplate.
     */
    data: XOR<FeeTemplateCreateInput, FeeTemplateUncheckedCreateInput>
  }

  /**
   * FeeTemplate createMany
   */
  export type FeeTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeTemplates.
     */
    data: FeeTemplateCreateManyInput | FeeTemplateCreateManyInput[]
  }

  /**
   * FeeTemplate createManyAndReturn
   */
  export type FeeTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many FeeTemplates.
     */
    data: FeeTemplateCreateManyInput | FeeTemplateCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeTemplate update
   */
  export type FeeTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeTemplate.
     */
    data: XOR<FeeTemplateUpdateInput, FeeTemplateUncheckedUpdateInput>
    /**
     * Choose, which FeeTemplate to update.
     */
    where: FeeTemplateWhereUniqueInput
  }

  /**
   * FeeTemplate updateMany
   */
  export type FeeTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeTemplates.
     */
    data: XOR<FeeTemplateUpdateManyMutationInput, FeeTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FeeTemplates to update
     */
    where?: FeeTemplateWhereInput
    /**
     * Limit how many FeeTemplates to update.
     */
    limit?: number
  }

  /**
   * FeeTemplate updateManyAndReturn
   */
  export type FeeTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * The data used to update FeeTemplates.
     */
    data: XOR<FeeTemplateUpdateManyMutationInput, FeeTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FeeTemplates to update
     */
    where?: FeeTemplateWhereInput
    /**
     * Limit how many FeeTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeTemplate upsert
   */
  export type FeeTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeTemplate to update in case it exists.
     */
    where: FeeTemplateWhereUniqueInput
    /**
     * In case the FeeTemplate found by the `where` argument doesn't exist, create a new FeeTemplate with this data.
     */
    create: XOR<FeeTemplateCreateInput, FeeTemplateUncheckedCreateInput>
    /**
     * In case the FeeTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeTemplateUpdateInput, FeeTemplateUncheckedUpdateInput>
  }

  /**
   * FeeTemplate delete
   */
  export type FeeTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
    /**
     * Filter which FeeTemplate to delete.
     */
    where: FeeTemplateWhereUniqueInput
  }

  /**
   * FeeTemplate deleteMany
   */
  export type FeeTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeTemplates to delete
     */
    where?: FeeTemplateWhereInput
    /**
     * Limit how many FeeTemplates to delete.
     */
    limit?: number
  }

  /**
   * FeeTemplate.class
   */
  export type FeeTemplate$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    where?: ClassesWhereInput
  }

  /**
   * FeeTemplate.payments
   */
  export type FeeTemplate$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * FeeTemplate without action
   */
  export type FeeTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeTemplate
     */
    select?: FeeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeTemplate
     */
    omit?: FeeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Attendances
   */

  export type AggregateAttendances = {
    _count: AttendancesCountAggregateOutputType | null
    _avg: AttendancesAvgAggregateOutputType | null
    _sum: AttendancesSumAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  export type AttendancesAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
  }

  export type AttendancesSumAggregateOutputType = {
    id: number | null
    student_id: number | null
  }

  export type AttendancesMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    date: string | null
    state: string | null
    justification: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type AttendancesMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    date: string | null
    state: string | null
    justification: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type AttendancesCountAggregateOutputType = {
    id: number
    student_id: number
    date: number
    state: number
    justification: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type AttendancesAvgAggregateInputType = {
    id?: true
    student_id?: true
  }

  export type AttendancesSumAggregateInputType = {
    id?: true
    student_id?: true
  }

  export type AttendancesMinAggregateInputType = {
    id?: true
    student_id?: true
    date?: true
    state?: true
    justification?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type AttendancesMaxAggregateInputType = {
    id?: true
    student_id?: true
    date?: true
    state?: true
    justification?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type AttendancesCountAggregateInputType = {
    id?: true
    student_id?: true
    date?: true
    state?: true
    justification?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type AttendancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to aggregate.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendancesMaxAggregateInputType
  }

  export type GetAttendancesAggregateType<T extends AttendancesAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendances[P]>
      : GetScalarType<T[P], AggregateAttendances[P]>
  }




  export type AttendancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendancesWhereInput
    orderBy?: AttendancesOrderByWithAggregationInput | AttendancesOrderByWithAggregationInput[]
    by: AttendancesScalarFieldEnum[] | AttendancesScalarFieldEnum
    having?: AttendancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendancesCountAggregateInputType | true
    _avg?: AttendancesAvgAggregateInputType
    _sum?: AttendancesSumAggregateInputType
    _min?: AttendancesMinAggregateInputType
    _max?: AttendancesMaxAggregateInputType
  }

  export type AttendancesGroupByOutputType = {
    id: number
    student_id: number
    date: string | null
    state: string | null
    justification: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: AttendancesCountAggregateOutputType | null
    _avg: AttendancesAvgAggregateOutputType | null
    _sum: AttendancesSumAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  type GetAttendancesGroupByPayload<T extends AttendancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
            : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
        }
      >
    >


  export type AttendancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type AttendancesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type AttendancesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type AttendancesSelectScalar = {
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "date" | "state" | "justification" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["attendances"]>
  export type AttendancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type AttendancesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type AttendancesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $AttendancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendances"
    objects: {
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      date: string | null
      state: string | null
      justification: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["attendances"]>
    composites: {}
  }

  type AttendancesGetPayload<S extends boolean | null | undefined | AttendancesDefaultArgs> = $Result.GetResult<Prisma.$AttendancesPayload, S>

  type AttendancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendancesCountAggregateInputType | true
    }

  export interface AttendancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendances'], meta: { name: 'Attendances' } }
    /**
     * Find zero or one Attendances that matches the filter.
     * @param {AttendancesFindUniqueArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendancesFindUniqueArgs>(args: SelectSubset<T, AttendancesFindUniqueArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendancesFindUniqueOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendancesFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesFindFirstArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendancesFindFirstArgs>(args?: SelectSubset<T, AttendancesFindFirstArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesFindFirstOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendancesFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendances.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendancesWithIdOnly = await prisma.attendances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendancesFindManyArgs>(args?: SelectSubset<T, AttendancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendances.
     * @param {AttendancesCreateArgs} args - Arguments to create a Attendances.
     * @example
     * // Create one Attendances
     * const Attendances = await prisma.attendances.create({
     *   data: {
     *     // ... data to create a Attendances
     *   }
     * })
     * 
     */
    create<T extends AttendancesCreateArgs>(args: SelectSubset<T, AttendancesCreateArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendancesCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendances = await prisma.attendances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendancesCreateManyArgs>(args?: SelectSubset<T, AttendancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendancesCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendances = await prisma.attendances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendancesWithIdOnly = await prisma.attendances.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendancesCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendancesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendances.
     * @param {AttendancesDeleteArgs} args - Arguments to delete one Attendances.
     * @example
     * // Delete one Attendances
     * const Attendances = await prisma.attendances.delete({
     *   where: {
     *     // ... filter to delete one Attendances
     *   }
     * })
     * 
     */
    delete<T extends AttendancesDeleteArgs>(args: SelectSubset<T, AttendancesDeleteArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendances.
     * @param {AttendancesUpdateArgs} args - Arguments to update one Attendances.
     * @example
     * // Update one Attendances
     * const attendances = await prisma.attendances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendancesUpdateArgs>(args: SelectSubset<T, AttendancesUpdateArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendancesDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendancesDeleteManyArgs>(args?: SelectSubset<T, AttendancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendances = await prisma.attendances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendancesUpdateManyArgs>(args: SelectSubset<T, AttendancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendancesUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendances = await prisma.attendances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendancesWithIdOnly = await prisma.attendances.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendancesUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendancesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendances.
     * @param {AttendancesUpsertArgs} args - Arguments to update or create a Attendances.
     * @example
     * // Update or create a Attendances
     * const attendances = await prisma.attendances.upsert({
     *   create: {
     *     // ... data to create a Attendances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendances we want to update
     *   }
     * })
     */
    upsert<T extends AttendancesUpsertArgs>(args: SelectSubset<T, AttendancesUpsertArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendances.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendancesCountArgs>(
      args?: Subset<T, AttendancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendancesAggregateArgs>(args: Subset<T, AttendancesAggregateArgs>): Prisma.PrismaPromise<GetAttendancesAggregateType<T>>

    /**
     * Group by Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendancesGroupByArgs['orderBy'] }
        : { orderBy?: AttendancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendances model
   */
  readonly fields: AttendancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendances model
   */
  interface AttendancesFieldRefs {
    readonly id: FieldRef<"Attendances", 'Int'>
    readonly student_id: FieldRef<"Attendances", 'Int'>
    readonly date: FieldRef<"Attendances", 'String'>
    readonly state: FieldRef<"Attendances", 'String'>
    readonly justification: FieldRef<"Attendances", 'String'>
    readonly supabase_id: FieldRef<"Attendances", 'String'>
    readonly last_modified: FieldRef<"Attendances", 'DateTime'>
    readonly needs_sync: FieldRef<"Attendances", 'Boolean'>
    readonly is_deleted: FieldRef<"Attendances", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Attendances findUnique
   */
  export type AttendancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances findUniqueOrThrow
   */
  export type AttendancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances findFirst
   */
  export type AttendancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Attendances findFirstOrThrow
   */
  export type AttendancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Attendances findMany
   */
  export type AttendancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Attendances create
   */
  export type AttendancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendances.
     */
    data: XOR<AttendancesCreateInput, AttendancesUncheckedCreateInput>
  }

  /**
   * Attendances createMany
   */
  export type AttendancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendancesCreateManyInput | AttendancesCreateManyInput[]
  }

  /**
   * Attendances createManyAndReturn
   */
  export type AttendancesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendancesCreateManyInput | AttendancesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendances update
   */
  export type AttendancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendances.
     */
    data: XOR<AttendancesUpdateInput, AttendancesUncheckedUpdateInput>
    /**
     * Choose, which Attendances to update.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances updateMany
   */
  export type AttendancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendancesUpdateManyMutationInput, AttendancesUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendancesWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendances updateManyAndReturn
   */
  export type AttendancesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendancesUpdateManyMutationInput, AttendancesUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendancesWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendances upsert
   */
  export type AttendancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendances to update in case it exists.
     */
    where: AttendancesWhereUniqueInput
    /**
     * In case the Attendances found by the `where` argument doesn't exist, create a new Attendances with this data.
     */
    create: XOR<AttendancesCreateInput, AttendancesUncheckedCreateInput>
    /**
     * In case the Attendances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendancesUpdateInput, AttendancesUncheckedUpdateInput>
  }

  /**
   * Attendances delete
   */
  export type AttendancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter which Attendances to delete.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances deleteMany
   */
  export type AttendancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendancesWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendances without action
   */
  export type AttendancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
  }


  /**
   * Model Employees
   */

  export type AggregateEmployees = {
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesAvgAggregateOutputType = {
    id: number | null
    salary: number | null
  }

  export type EmployeesSumAggregateOutputType = {
    id: number | null
    salary: number | null
  }

  export type EmployeesMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    job_title: string | null
    salary: number | null
    matricule: string | null
    school_id: string | null
    password_hash: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EmployeesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    job_title: string | null
    salary: number | null
    matricule: string | null
    school_id: string | null
    password_hash: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EmployeesCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    phone: number
    email: number
    adress: number
    gender: number
    job_title: number
    salary: number
    matricule: number
    school_id: number
    password_hash: number
    supabase_id: number
    user_supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type EmployeesAvgAggregateInputType = {
    id?: true
    salary?: true
  }

  export type EmployeesSumAggregateInputType = {
    id?: true
    salary?: true
  }

  export type EmployeesMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    job_title?: true
    salary?: true
    matricule?: true
    school_id?: true
    password_hash?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EmployeesMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    job_title?: true
    salary?: true
    matricule?: true
    school_id?: true
    password_hash?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EmployeesCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    job_title?: true
    salary?: true
    matricule?: true
    school_id?: true
    password_hash?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type EmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to aggregate.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }




  export type EmployeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesWhereInput
    orderBy?: EmployeesOrderByWithAggregationInput | EmployeesOrderByWithAggregationInput[]
    by: EmployeesScalarFieldEnum[] | EmployeesScalarFieldEnum
    having?: EmployeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesCountAggregateInputType | true
    _avg?: EmployeesAvgAggregateInputType
    _sum?: EmployeesSumAggregateInputType
    _min?: EmployeesMinAggregateInputType
    _max?: EmployeesMaxAggregateInputType
  }

  export type EmployeesGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    job_title: string | null
    salary: number | null
    matricule: string | null
    school_id: string | null
    password_hash: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  type GetEmployeesGroupByPayload<T extends EmployeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: boolean | Employees$salary_paymentsArgs<ExtArgs>
    attendances?: boolean | Employees$attendancesArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "phone" | "email" | "adress" | "gender" | "job_title" | "salary" | "matricule" | "school_id" | "password_hash" | "supabase_id" | "user_supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["employees"]>
  export type EmployeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salary_payments?: boolean | Employees$salary_paymentsArgs<ExtArgs>
    attendances?: boolean | Employees$attendancesArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employees"
    objects: {
      salary_payments: Prisma.$SalaryPaymentsPayload<ExtArgs>[]
      attendances: Prisma.$EmployeeAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      phone: string | null
      email: string | null
      adress: string | null
      gender: string | null
      job_title: string | null
      salary: number | null
      matricule: string | null
      school_id: string | null
      password_hash: string | null
      supabase_id: string | null
      user_supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["employees"]>
    composites: {}
  }

  type EmployeesGetPayload<S extends boolean | null | undefined | EmployeesDefaultArgs> = $Result.GetResult<Prisma.$EmployeesPayload, S>

  type EmployeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeesCountAggregateInputType | true
    }

  export interface EmployeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employees'], meta: { name: 'Employees' } }
    /**
     * Find zero or one Employees that matches the filter.
     * @param {EmployeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesFindUniqueArgs>(args: SelectSubset<T, EmployeesFindUniqueArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeesFindUniqueOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesFindFirstArgs>(args?: SelectSubset<T, EmployeesFindFirstArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeesWithIdOnly = await prisma.employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeesFindManyArgs>(args?: SelectSubset<T, EmployeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employees.
     * @param {EmployeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
     */
    create<T extends EmployeesCreateArgs>(args: SelectSubset<T, EmployeesCreateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeesCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesCreateManyArgs>(args?: SelectSubset<T, EmployeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeesCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeesCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employees.
     * @param {EmployeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
     */
    delete<T extends EmployeesDeleteArgs>(args: SelectSubset<T, EmployeesDeleteArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employees.
     * @param {EmployeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesUpdateArgs>(args: SelectSubset<T, EmployeesUpdateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesDeleteManyArgs>(args?: SelectSubset<T, EmployeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesUpdateManyArgs>(args: SelectSubset<T, EmployeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeesUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeesUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employees.
     * @param {EmployeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesUpsertArgs>(args: SelectSubset<T, EmployeesUpsertArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeesCountArgs>(
      args?: Subset<T, EmployeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAggregateType<T>>

    /**
     * Group by Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employees model
   */
  readonly fields: EmployeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salary_payments<T extends Employees$salary_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Employees$salary_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Employees$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Employees$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employees model
   */
  interface EmployeesFieldRefs {
    readonly id: FieldRef<"Employees", 'Int'>
    readonly name: FieldRef<"Employees", 'String'>
    readonly first_name: FieldRef<"Employees", 'String'>
    readonly phone: FieldRef<"Employees", 'String'>
    readonly email: FieldRef<"Employees", 'String'>
    readonly adress: FieldRef<"Employees", 'String'>
    readonly gender: FieldRef<"Employees", 'String'>
    readonly job_title: FieldRef<"Employees", 'String'>
    readonly salary: FieldRef<"Employees", 'Float'>
    readonly matricule: FieldRef<"Employees", 'String'>
    readonly school_id: FieldRef<"Employees", 'String'>
    readonly password_hash: FieldRef<"Employees", 'String'>
    readonly supabase_id: FieldRef<"Employees", 'String'>
    readonly user_supabase_id: FieldRef<"Employees", 'String'>
    readonly last_modified: FieldRef<"Employees", 'DateTime'>
    readonly needs_sync: FieldRef<"Employees", 'Boolean'>
    readonly is_deleted: FieldRef<"Employees", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Employees findUnique
   */
  export type EmployeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findUniqueOrThrow
   */
  export type EmployeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findFirst
   */
  export type EmployeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findFirstOrThrow
   */
  export type EmployeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findMany
   */
  export type EmployeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees create
   */
  export type EmployeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to create a Employees.
     */
    data?: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
  }

  /**
   * Employees createMany
   */
  export type EmployeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
  }

  /**
   * Employees createManyAndReturn
   */
  export type EmployeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
  }

  /**
   * Employees update
   */
  export type EmployeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to update a Employees.
     */
    data: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
    /**
     * Choose, which Employees to update.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees updateMany
   */
  export type EmployeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employees updateManyAndReturn
   */
  export type EmployeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employees upsert
   */
  export type EmployeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The filter to search for the Employees to update in case it exists.
     */
    where: EmployeesWhereUniqueInput
    /**
     * In case the Employees found by the `where` argument doesn't exist, create a new Employees with this data.
     */
    create: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
    /**
     * In case the Employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
  }

  /**
   * Employees delete
   */
  export type EmployeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter which Employees to delete.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees deleteMany
   */
  export type EmployeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employees.salary_payments
   */
  export type Employees$salary_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    where?: SalaryPaymentsWhereInput
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    cursor?: SalaryPaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * Employees.attendances
   */
  export type Employees$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    where?: EmployeeAttendanceWhereInput
    orderBy?: EmployeeAttendanceOrderByWithRelationInput | EmployeeAttendanceOrderByWithRelationInput[]
    cursor?: EmployeeAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeAttendanceScalarFieldEnum | EmployeeAttendanceScalarFieldEnum[]
  }

  /**
   * Employees without action
   */
  export type EmployeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
  }


  /**
   * Model SalaryPayments
   */

  export type AggregateSalaryPayments = {
    _count: SalaryPaymentsCountAggregateOutputType | null
    _avg: SalaryPaymentsAvgAggregateOutputType | null
    _sum: SalaryPaymentsSumAggregateOutputType | null
    _min: SalaryPaymentsMinAggregateOutputType | null
    _max: SalaryPaymentsMaxAggregateOutputType | null
  }

  export type SalaryPaymentsAvgAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
  }

  export type SalaryPaymentsSumAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
  }

  export type SalaryPaymentsMinAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
    payment_date: string | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SalaryPaymentsMaxAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
    payment_date: string | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SalaryPaymentsCountAggregateOutputType = {
    id: number
    employee_id: number
    base_salary: number
    bonus_amount: number
    total_amount: number
    payment_date: number
    notes: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type SalaryPaymentsAvgAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
  }

  export type SalaryPaymentsSumAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
  }

  export type SalaryPaymentsMinAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
    payment_date?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SalaryPaymentsMaxAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
    payment_date?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SalaryPaymentsCountAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
    payment_date?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type SalaryPaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to aggregate.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryPayments
    **/
    _count?: true | SalaryPaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryPaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryPaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryPaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryPaymentsMaxAggregateInputType
  }

  export type GetSalaryPaymentsAggregateType<T extends SalaryPaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryPayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryPayments[P]>
      : GetScalarType<T[P], AggregateSalaryPayments[P]>
  }




  export type SalaryPaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentsWhereInput
    orderBy?: SalaryPaymentsOrderByWithAggregationInput | SalaryPaymentsOrderByWithAggregationInput[]
    by: SalaryPaymentsScalarFieldEnum[] | SalaryPaymentsScalarFieldEnum
    having?: SalaryPaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryPaymentsCountAggregateInputType | true
    _avg?: SalaryPaymentsAvgAggregateInputType
    _sum?: SalaryPaymentsSumAggregateInputType
    _min?: SalaryPaymentsMinAggregateInputType
    _max?: SalaryPaymentsMaxAggregateInputType
  }

  export type SalaryPaymentsGroupByOutputType = {
    id: number
    employee_id: number
    base_salary: number
    bonus_amount: number
    total_amount: number
    payment_date: string
    notes: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: SalaryPaymentsCountAggregateOutputType | null
    _avg: SalaryPaymentsAvgAggregateOutputType | null
    _sum: SalaryPaymentsSumAggregateOutputType | null
    _min: SalaryPaymentsMinAggregateOutputType | null
    _max: SalaryPaymentsMaxAggregateOutputType | null
  }

  type GetSalaryPaymentsGroupByPayload<T extends SalaryPaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryPaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryPaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryPaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryPaymentsGroupByOutputType[P]>
        }
      >
    >


  export type SalaryPaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayments"]>

  export type SalaryPaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayments"]>

  export type SalaryPaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayments"]>

  export type SalaryPaymentsSelectScalar = {
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "base_salary" | "bonus_amount" | "total_amount" | "payment_date" | "notes" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["salaryPayments"]>
  export type SalaryPaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }

  export type $SalaryPaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryPayments"
    objects: {
      employee: Prisma.$EmployeesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employee_id: number
      base_salary: number
      bonus_amount: number
      total_amount: number
      payment_date: string
      notes: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["salaryPayments"]>
    composites: {}
  }

  type SalaryPaymentsGetPayload<S extends boolean | null | undefined | SalaryPaymentsDefaultArgs> = $Result.GetResult<Prisma.$SalaryPaymentsPayload, S>

  type SalaryPaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryPaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryPaymentsCountAggregateInputType | true
    }

  export interface SalaryPaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryPayments'], meta: { name: 'SalaryPayments' } }
    /**
     * Find zero or one SalaryPayments that matches the filter.
     * @param {SalaryPaymentsFindUniqueArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryPaymentsFindUniqueArgs>(args: SelectSubset<T, SalaryPaymentsFindUniqueArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryPayments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryPaymentsFindUniqueOrThrowArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryPaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryPaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsFindFirstArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryPaymentsFindFirstArgs>(args?: SelectSubset<T, SalaryPaymentsFindFirstArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsFindFirstOrThrowArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryPaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryPaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findMany()
     * 
     * // Get first 10 SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryPaymentsWithIdOnly = await prisma.salaryPayments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryPaymentsFindManyArgs>(args?: SelectSubset<T, SalaryPaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryPayments.
     * @param {SalaryPaymentsCreateArgs} args - Arguments to create a SalaryPayments.
     * @example
     * // Create one SalaryPayments
     * const SalaryPayments = await prisma.salaryPayments.create({
     *   data: {
     *     // ... data to create a SalaryPayments
     *   }
     * })
     * 
     */
    create<T extends SalaryPaymentsCreateArgs>(args: SelectSubset<T, SalaryPaymentsCreateArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryPayments.
     * @param {SalaryPaymentsCreateManyArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryPaymentsCreateManyArgs>(args?: SelectSubset<T, SalaryPaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryPayments and returns the data saved in the database.
     * @param {SalaryPaymentsCreateManyAndReturnArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryPayments and only return the `id`
     * const salaryPaymentsWithIdOnly = await prisma.salaryPayments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryPaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryPaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryPayments.
     * @param {SalaryPaymentsDeleteArgs} args - Arguments to delete one SalaryPayments.
     * @example
     * // Delete one SalaryPayments
     * const SalaryPayments = await prisma.salaryPayments.delete({
     *   where: {
     *     // ... filter to delete one SalaryPayments
     *   }
     * })
     * 
     */
    delete<T extends SalaryPaymentsDeleteArgs>(args: SelectSubset<T, SalaryPaymentsDeleteArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryPayments.
     * @param {SalaryPaymentsUpdateArgs} args - Arguments to update one SalaryPayments.
     * @example
     * // Update one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryPaymentsUpdateArgs>(args: SelectSubset<T, SalaryPaymentsUpdateArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryPayments.
     * @param {SalaryPaymentsDeleteManyArgs} args - Arguments to filter SalaryPayments to delete.
     * @example
     * // Delete a few SalaryPayments
     * const { count } = await prisma.salaryPayments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryPaymentsDeleteManyArgs>(args?: SelectSubset<T, SalaryPaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryPaymentsUpdateManyArgs>(args: SelectSubset<T, SalaryPaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments and returns the data updated in the database.
     * @param {SalaryPaymentsUpdateManyAndReturnArgs} args - Arguments to update many SalaryPayments.
     * @example
     * // Update many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryPayments and only return the `id`
     * const salaryPaymentsWithIdOnly = await prisma.salaryPayments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryPaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryPaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryPayments.
     * @param {SalaryPaymentsUpsertArgs} args - Arguments to update or create a SalaryPayments.
     * @example
     * // Update or create a SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.upsert({
     *   create: {
     *     // ... data to create a SalaryPayments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryPayments we want to update
     *   }
     * })
     */
    upsert<T extends SalaryPaymentsUpsertArgs>(args: SelectSubset<T, SalaryPaymentsUpsertArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsCountArgs} args - Arguments to filter SalaryPayments to count.
     * @example
     * // Count the number of SalaryPayments
     * const count = await prisma.salaryPayments.count({
     *   where: {
     *     // ... the filter for the SalaryPayments we want to count
     *   }
     * })
    **/
    count<T extends SalaryPaymentsCountArgs>(
      args?: Subset<T, SalaryPaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryPaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryPaymentsAggregateArgs>(args: Subset<T, SalaryPaymentsAggregateArgs>): Prisma.PrismaPromise<GetSalaryPaymentsAggregateType<T>>

    /**
     * Group by SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryPaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryPaymentsGroupByArgs['orderBy'] }
        : { orderBy?: SalaryPaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryPaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryPayments model
   */
  readonly fields: SalaryPaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryPayments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryPaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeesDefaultArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryPayments model
   */
  interface SalaryPaymentsFieldRefs {
    readonly id: FieldRef<"SalaryPayments", 'Int'>
    readonly employee_id: FieldRef<"SalaryPayments", 'Int'>
    readonly base_salary: FieldRef<"SalaryPayments", 'Float'>
    readonly bonus_amount: FieldRef<"SalaryPayments", 'Float'>
    readonly total_amount: FieldRef<"SalaryPayments", 'Float'>
    readonly payment_date: FieldRef<"SalaryPayments", 'String'>
    readonly notes: FieldRef<"SalaryPayments", 'String'>
    readonly supabase_id: FieldRef<"SalaryPayments", 'String'>
    readonly last_modified: FieldRef<"SalaryPayments", 'DateTime'>
    readonly needs_sync: FieldRef<"SalaryPayments", 'Boolean'>
    readonly is_deleted: FieldRef<"SalaryPayments", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SalaryPayments findUnique
   */
  export type SalaryPaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments findUniqueOrThrow
   */
  export type SalaryPaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments findFirst
   */
  export type SalaryPaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * SalaryPayments findFirstOrThrow
   */
  export type SalaryPaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * SalaryPayments findMany
   */
  export type SalaryPaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryPayments.
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * SalaryPayments create
   */
  export type SalaryPaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryPayments.
     */
    data: XOR<SalaryPaymentsCreateInput, SalaryPaymentsUncheckedCreateInput>
  }

  /**
   * SalaryPayments createMany
   */
  export type SalaryPaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentsCreateManyInput | SalaryPaymentsCreateManyInput[]
  }

  /**
   * SalaryPayments createManyAndReturn
   */
  export type SalaryPaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentsCreateManyInput | SalaryPaymentsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayments update
   */
  export type SalaryPaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryPayments.
     */
    data: XOR<SalaryPaymentsUpdateInput, SalaryPaymentsUncheckedUpdateInput>
    /**
     * Choose, which SalaryPayments to update.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments updateMany
   */
  export type SalaryPaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentsUpdateManyMutationInput, SalaryPaymentsUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentsWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
  }

  /**
   * SalaryPayments updateManyAndReturn
   */
  export type SalaryPaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentsUpdateManyMutationInput, SalaryPaymentsUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentsWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayments upsert
   */
  export type SalaryPaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryPayments to update in case it exists.
     */
    where: SalaryPaymentsWhereUniqueInput
    /**
     * In case the SalaryPayments found by the `where` argument doesn't exist, create a new SalaryPayments with this data.
     */
    create: XOR<SalaryPaymentsCreateInput, SalaryPaymentsUncheckedCreateInput>
    /**
     * In case the SalaryPayments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryPaymentsUpdateInput, SalaryPaymentsUncheckedUpdateInput>
  }

  /**
   * SalaryPayments delete
   */
  export type SalaryPaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter which SalaryPayments to delete.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments deleteMany
   */
  export type SalaryPaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to delete
     */
    where?: SalaryPaymentsWhereInput
    /**
     * Limit how many SalaryPayments to delete.
     */
    limit?: number
  }

  /**
   * SalaryPayments without action
   */
  export type SalaryPaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
  }


  /**
   * Model Schedules
   */

  export type AggregateSchedules = {
    _count: SchedulesCountAggregateOutputType | null
    _avg: SchedulesAvgAggregateOutputType | null
    _sum: SchedulesSumAggregateOutputType | null
    _min: SchedulesMinAggregateOutputType | null
    _max: SchedulesMaxAggregateOutputType | null
  }

  export type SchedulesAvgAggregateOutputType = {
    id: number | null
    lesson_id: number | null
  }

  export type SchedulesSumAggregateOutputType = {
    id: number | null
    lesson_id: number | null
  }

  export type SchedulesMinAggregateOutputType = {
    id: number | null
    lesson_id: number | null
    day_of_week: string | null
    start_time: string | null
    end_time: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SchedulesMaxAggregateOutputType = {
    id: number | null
    lesson_id: number | null
    day_of_week: string | null
    start_time: string | null
    end_time: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SchedulesCountAggregateOutputType = {
    id: number
    lesson_id: number
    day_of_week: number
    start_time: number
    end_time: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type SchedulesAvgAggregateInputType = {
    id?: true
    lesson_id?: true
  }

  export type SchedulesSumAggregateInputType = {
    id?: true
    lesson_id?: true
  }

  export type SchedulesMinAggregateInputType = {
    id?: true
    lesson_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SchedulesMaxAggregateInputType = {
    id?: true
    lesson_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SchedulesCountAggregateInputType = {
    id?: true
    lesson_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type SchedulesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to aggregate.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | SchedulesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchedulesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchedulesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchedulesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchedulesMaxAggregateInputType
  }

  export type GetSchedulesAggregateType<T extends SchedulesAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedules]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedules[P]>
      : GetScalarType<T[P], AggregateSchedules[P]>
  }




  export type SchedulesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchedulesWhereInput
    orderBy?: SchedulesOrderByWithAggregationInput | SchedulesOrderByWithAggregationInput[]
    by: SchedulesScalarFieldEnum[] | SchedulesScalarFieldEnum
    having?: SchedulesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchedulesCountAggregateInputType | true
    _avg?: SchedulesAvgAggregateInputType
    _sum?: SchedulesSumAggregateInputType
    _min?: SchedulesMinAggregateInputType
    _max?: SchedulesMaxAggregateInputType
  }

  export type SchedulesGroupByOutputType = {
    id: number
    lesson_id: number
    day_of_week: string | null
    start_time: string | null
    end_time: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: SchedulesCountAggregateOutputType | null
    _avg: SchedulesAvgAggregateOutputType | null
    _sum: SchedulesSumAggregateOutputType | null
    _min: SchedulesMinAggregateOutputType | null
    _max: SchedulesMaxAggregateOutputType | null
  }

  type GetSchedulesGroupByPayload<T extends SchedulesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchedulesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchedulesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchedulesGroupByOutputType[P]>
            : GetScalarType<T[P], SchedulesGroupByOutputType[P]>
        }
      >
    >


  export type SchedulesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedules"]>

  export type SchedulesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedules"]>

  export type SchedulesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedules"]>

  export type SchedulesSelectScalar = {
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lesson_id" | "day_of_week" | "start_time" | "end_time" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["schedules"]>
  export type SchedulesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }
  export type SchedulesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }
  export type SchedulesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }

  export type $SchedulesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedules"
    objects: {
      lesson: Prisma.$LessonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lesson_id: number
      day_of_week: string | null
      start_time: string | null
      end_time: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["schedules"]>
    composites: {}
  }

  type SchedulesGetPayload<S extends boolean | null | undefined | SchedulesDefaultArgs> = $Result.GetResult<Prisma.$SchedulesPayload, S>

  type SchedulesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchedulesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchedulesCountAggregateInputType | true
    }

  export interface SchedulesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedules'], meta: { name: 'Schedules' } }
    /**
     * Find zero or one Schedules that matches the filter.
     * @param {SchedulesFindUniqueArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchedulesFindUniqueArgs>(args: SelectSubset<T, SchedulesFindUniqueArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedules that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchedulesFindUniqueOrThrowArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchedulesFindUniqueOrThrowArgs>(args: SelectSubset<T, SchedulesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesFindFirstArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchedulesFindFirstArgs>(args?: SelectSubset<T, SchedulesFindFirstArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedules that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesFindFirstOrThrowArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchedulesFindFirstOrThrowArgs>(args?: SelectSubset<T, SchedulesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedules.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedules.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schedulesWithIdOnly = await prisma.schedules.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchedulesFindManyArgs>(args?: SelectSubset<T, SchedulesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedules.
     * @param {SchedulesCreateArgs} args - Arguments to create a Schedules.
     * @example
     * // Create one Schedules
     * const Schedules = await prisma.schedules.create({
     *   data: {
     *     // ... data to create a Schedules
     *   }
     * })
     * 
     */
    create<T extends SchedulesCreateArgs>(args: SelectSubset<T, SchedulesCreateArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {SchedulesCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedules = await prisma.schedules.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchedulesCreateManyArgs>(args?: SelectSubset<T, SchedulesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {SchedulesCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedules = await prisma.schedules.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const schedulesWithIdOnly = await prisma.schedules.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchedulesCreateManyAndReturnArgs>(args?: SelectSubset<T, SchedulesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedules.
     * @param {SchedulesDeleteArgs} args - Arguments to delete one Schedules.
     * @example
     * // Delete one Schedules
     * const Schedules = await prisma.schedules.delete({
     *   where: {
     *     // ... filter to delete one Schedules
     *   }
     * })
     * 
     */
    delete<T extends SchedulesDeleteArgs>(args: SelectSubset<T, SchedulesDeleteArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedules.
     * @param {SchedulesUpdateArgs} args - Arguments to update one Schedules.
     * @example
     * // Update one Schedules
     * const schedules = await prisma.schedules.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchedulesUpdateArgs>(args: SelectSubset<T, SchedulesUpdateArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {SchedulesDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedules.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchedulesDeleteManyArgs>(args?: SelectSubset<T, SchedulesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedules = await prisma.schedules.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchedulesUpdateManyArgs>(args: SelectSubset<T, SchedulesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {SchedulesUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedules = await prisma.schedules.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const schedulesWithIdOnly = await prisma.schedules.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchedulesUpdateManyAndReturnArgs>(args: SelectSubset<T, SchedulesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedules.
     * @param {SchedulesUpsertArgs} args - Arguments to update or create a Schedules.
     * @example
     * // Update or create a Schedules
     * const schedules = await prisma.schedules.upsert({
     *   create: {
     *     // ... data to create a Schedules
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedules we want to update
     *   }
     * })
     */
    upsert<T extends SchedulesUpsertArgs>(args: SelectSubset<T, SchedulesUpsertArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedules.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends SchedulesCountArgs>(
      args?: Subset<T, SchedulesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchedulesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchedulesAggregateArgs>(args: Subset<T, SchedulesAggregateArgs>): Prisma.PrismaPromise<GetSchedulesAggregateType<T>>

    /**
     * Group by Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchedulesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchedulesGroupByArgs['orderBy'] }
        : { orderBy?: SchedulesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchedulesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchedulesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedules model
   */
  readonly fields: SchedulesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedules.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchedulesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonsDefaultArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedules model
   */
  interface SchedulesFieldRefs {
    readonly id: FieldRef<"Schedules", 'Int'>
    readonly lesson_id: FieldRef<"Schedules", 'Int'>
    readonly day_of_week: FieldRef<"Schedules", 'String'>
    readonly start_time: FieldRef<"Schedules", 'String'>
    readonly end_time: FieldRef<"Schedules", 'String'>
    readonly supabase_id: FieldRef<"Schedules", 'String'>
    readonly last_modified: FieldRef<"Schedules", 'DateTime'>
    readonly needs_sync: FieldRef<"Schedules", 'Boolean'>
    readonly is_deleted: FieldRef<"Schedules", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Schedules findUnique
   */
  export type SchedulesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules findUniqueOrThrow
   */
  export type SchedulesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules findFirst
   */
  export type SchedulesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Schedules findFirstOrThrow
   */
  export type SchedulesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Schedules findMany
   */
  export type SchedulesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Schedules create
   */
  export type SchedulesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedules.
     */
    data: XOR<SchedulesCreateInput, SchedulesUncheckedCreateInput>
  }

  /**
   * Schedules createMany
   */
  export type SchedulesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: SchedulesCreateManyInput | SchedulesCreateManyInput[]
  }

  /**
   * Schedules createManyAndReturn
   */
  export type SchedulesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: SchedulesCreateManyInput | SchedulesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedules update
   */
  export type SchedulesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedules.
     */
    data: XOR<SchedulesUpdateInput, SchedulesUncheckedUpdateInput>
    /**
     * Choose, which Schedules to update.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules updateMany
   */
  export type SchedulesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<SchedulesUpdateManyMutationInput, SchedulesUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: SchedulesWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedules updateManyAndReturn
   */
  export type SchedulesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<SchedulesUpdateManyMutationInput, SchedulesUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: SchedulesWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedules upsert
   */
  export type SchedulesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedules to update in case it exists.
     */
    where: SchedulesWhereUniqueInput
    /**
     * In case the Schedules found by the `where` argument doesn't exist, create a new Schedules with this data.
     */
    create: XOR<SchedulesCreateInput, SchedulesUncheckedCreateInput>
    /**
     * In case the Schedules was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchedulesUpdateInput, SchedulesUncheckedUpdateInput>
  }

  /**
   * Schedules delete
   */
  export type SchedulesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter which Schedules to delete.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules deleteMany
   */
  export type SchedulesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: SchedulesWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedules without action
   */
  export type SchedulesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
  }


  /**
   * Model FinancialCategory
   */

  export type AggregateFinancialCategory = {
    _count: FinancialCategoryCountAggregateOutputType | null
    _avg: FinancialCategoryAvgAggregateOutputType | null
    _sum: FinancialCategorySumAggregateOutputType | null
    _min: FinancialCategoryMinAggregateOutputType | null
    _max: FinancialCategoryMaxAggregateOutputType | null
  }

  export type FinancialCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type FinancialCategorySumAggregateOutputType = {
    id: number | null
  }

  export type FinancialCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FinancialCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FinancialCategoryCountAggregateOutputType = {
    id: number
    name: number
    type: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type FinancialCategoryAvgAggregateInputType = {
    id?: true
  }

  export type FinancialCategorySumAggregateInputType = {
    id?: true
  }

  export type FinancialCategoryMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FinancialCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FinancialCategoryCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type FinancialCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialCategory to aggregate.
     */
    where?: FinancialCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialCategories to fetch.
     */
    orderBy?: FinancialCategoryOrderByWithRelationInput | FinancialCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialCategories
    **/
    _count?: true | FinancialCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialCategoryMaxAggregateInputType
  }

  export type GetFinancialCategoryAggregateType<T extends FinancialCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialCategory[P]>
      : GetScalarType<T[P], AggregateFinancialCategory[P]>
  }




  export type FinancialCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialCategoryWhereInput
    orderBy?: FinancialCategoryOrderByWithAggregationInput | FinancialCategoryOrderByWithAggregationInput[]
    by: FinancialCategoryScalarFieldEnum[] | FinancialCategoryScalarFieldEnum
    having?: FinancialCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialCategoryCountAggregateInputType | true
    _avg?: FinancialCategoryAvgAggregateInputType
    _sum?: FinancialCategorySumAggregateInputType
    _min?: FinancialCategoryMinAggregateInputType
    _max?: FinancialCategoryMaxAggregateInputType
  }

  export type FinancialCategoryGroupByOutputType = {
    id: number
    name: string
    type: string
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: FinancialCategoryCountAggregateOutputType | null
    _avg: FinancialCategoryAvgAggregateOutputType | null
    _sum: FinancialCategorySumAggregateOutputType | null
    _min: FinancialCategoryMinAggregateOutputType | null
    _max: FinancialCategoryMaxAggregateOutputType | null
  }

  type GetFinancialCategoryGroupByPayload<T extends FinancialCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialCategoryGroupByOutputType[P]>
        }
      >
    >


  export type FinancialCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    transactions?: boolean | FinancialCategory$transactionsArgs<ExtArgs>
    dispatch_rule_details?: boolean | FinancialCategory$dispatch_rule_detailsArgs<ExtArgs>
    _count?: boolean | FinancialCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialCategory"]>

  export type FinancialCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["financialCategory"]>

  export type FinancialCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["financialCategory"]>

  export type FinancialCategorySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["financialCategory"]>
  export type FinancialCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | FinancialCategory$transactionsArgs<ExtArgs>
    dispatch_rule_details?: boolean | FinancialCategory$dispatch_rule_detailsArgs<ExtArgs>
    _count?: boolean | FinancialCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinancialCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FinancialCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FinancialCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialCategory"
    objects: {
      transactions: Prisma.$FinancialTransactionPayload<ExtArgs>[]
      dispatch_rule_details: Prisma.$DispatchRuleDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["financialCategory"]>
    composites: {}
  }

  type FinancialCategoryGetPayload<S extends boolean | null | undefined | FinancialCategoryDefaultArgs> = $Result.GetResult<Prisma.$FinancialCategoryPayload, S>

  type FinancialCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialCategoryCountAggregateInputType | true
    }

  export interface FinancialCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialCategory'], meta: { name: 'FinancialCategory' } }
    /**
     * Find zero or one FinancialCategory that matches the filter.
     * @param {FinancialCategoryFindUniqueArgs} args - Arguments to find a FinancialCategory
     * @example
     * // Get one FinancialCategory
     * const financialCategory = await prisma.financialCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialCategoryFindUniqueArgs>(args: SelectSubset<T, FinancialCategoryFindUniqueArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialCategoryFindUniqueOrThrowArgs} args - Arguments to find a FinancialCategory
     * @example
     * // Get one FinancialCategory
     * const financialCategory = await prisma.financialCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialCategoryFindFirstArgs} args - Arguments to find a FinancialCategory
     * @example
     * // Get one FinancialCategory
     * const financialCategory = await prisma.financialCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialCategoryFindFirstArgs>(args?: SelectSubset<T, FinancialCategoryFindFirstArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialCategoryFindFirstOrThrowArgs} args - Arguments to find a FinancialCategory
     * @example
     * // Get one FinancialCategory
     * const financialCategory = await prisma.financialCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialCategories
     * const financialCategories = await prisma.financialCategory.findMany()
     * 
     * // Get first 10 FinancialCategories
     * const financialCategories = await prisma.financialCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialCategoryWithIdOnly = await prisma.financialCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialCategoryFindManyArgs>(args?: SelectSubset<T, FinancialCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialCategory.
     * @param {FinancialCategoryCreateArgs} args - Arguments to create a FinancialCategory.
     * @example
     * // Create one FinancialCategory
     * const FinancialCategory = await prisma.financialCategory.create({
     *   data: {
     *     // ... data to create a FinancialCategory
     *   }
     * })
     * 
     */
    create<T extends FinancialCategoryCreateArgs>(args: SelectSubset<T, FinancialCategoryCreateArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialCategories.
     * @param {FinancialCategoryCreateManyArgs} args - Arguments to create many FinancialCategories.
     * @example
     * // Create many FinancialCategories
     * const financialCategory = await prisma.financialCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialCategoryCreateManyArgs>(args?: SelectSubset<T, FinancialCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialCategories and returns the data saved in the database.
     * @param {FinancialCategoryCreateManyAndReturnArgs} args - Arguments to create many FinancialCategories.
     * @example
     * // Create many FinancialCategories
     * const financialCategory = await prisma.financialCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialCategories and only return the `id`
     * const financialCategoryWithIdOnly = await prisma.financialCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialCategory.
     * @param {FinancialCategoryDeleteArgs} args - Arguments to delete one FinancialCategory.
     * @example
     * // Delete one FinancialCategory
     * const FinancialCategory = await prisma.financialCategory.delete({
     *   where: {
     *     // ... filter to delete one FinancialCategory
     *   }
     * })
     * 
     */
    delete<T extends FinancialCategoryDeleteArgs>(args: SelectSubset<T, FinancialCategoryDeleteArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialCategory.
     * @param {FinancialCategoryUpdateArgs} args - Arguments to update one FinancialCategory.
     * @example
     * // Update one FinancialCategory
     * const financialCategory = await prisma.financialCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialCategoryUpdateArgs>(args: SelectSubset<T, FinancialCategoryUpdateArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialCategories.
     * @param {FinancialCategoryDeleteManyArgs} args - Arguments to filter FinancialCategories to delete.
     * @example
     * // Delete a few FinancialCategories
     * const { count } = await prisma.financialCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialCategoryDeleteManyArgs>(args?: SelectSubset<T, FinancialCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialCategories
     * const financialCategory = await prisma.financialCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialCategoryUpdateManyArgs>(args: SelectSubset<T, FinancialCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialCategories and returns the data updated in the database.
     * @param {FinancialCategoryUpdateManyAndReturnArgs} args - Arguments to update many FinancialCategories.
     * @example
     * // Update many FinancialCategories
     * const financialCategory = await prisma.financialCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialCategories and only return the `id`
     * const financialCategoryWithIdOnly = await prisma.financialCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialCategory.
     * @param {FinancialCategoryUpsertArgs} args - Arguments to update or create a FinancialCategory.
     * @example
     * // Update or create a FinancialCategory
     * const financialCategory = await prisma.financialCategory.upsert({
     *   create: {
     *     // ... data to create a FinancialCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialCategory we want to update
     *   }
     * })
     */
    upsert<T extends FinancialCategoryUpsertArgs>(args: SelectSubset<T, FinancialCategoryUpsertArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialCategoryCountArgs} args - Arguments to filter FinancialCategories to count.
     * @example
     * // Count the number of FinancialCategories
     * const count = await prisma.financialCategory.count({
     *   where: {
     *     // ... the filter for the FinancialCategories we want to count
     *   }
     * })
    **/
    count<T extends FinancialCategoryCountArgs>(
      args?: Subset<T, FinancialCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialCategoryAggregateArgs>(args: Subset<T, FinancialCategoryAggregateArgs>): Prisma.PrismaPromise<GetFinancialCategoryAggregateType<T>>

    /**
     * Group by FinancialCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialCategoryGroupByArgs['orderBy'] }
        : { orderBy?: FinancialCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialCategory model
   */
  readonly fields: FinancialCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends FinancialCategory$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, FinancialCategory$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatch_rule_details<T extends FinancialCategory$dispatch_rule_detailsArgs<ExtArgs> = {}>(args?: Subset<T, FinancialCategory$dispatch_rule_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialCategory model
   */
  interface FinancialCategoryFieldRefs {
    readonly id: FieldRef<"FinancialCategory", 'Int'>
    readonly name: FieldRef<"FinancialCategory", 'String'>
    readonly type: FieldRef<"FinancialCategory", 'String'>
    readonly school_id: FieldRef<"FinancialCategory", 'String'>
    readonly supabase_id: FieldRef<"FinancialCategory", 'String'>
    readonly last_modified: FieldRef<"FinancialCategory", 'DateTime'>
    readonly needs_sync: FieldRef<"FinancialCategory", 'Boolean'>
    readonly is_deleted: FieldRef<"FinancialCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FinancialCategory findUnique
   */
  export type FinancialCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FinancialCategory to fetch.
     */
    where: FinancialCategoryWhereUniqueInput
  }

  /**
   * FinancialCategory findUniqueOrThrow
   */
  export type FinancialCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FinancialCategory to fetch.
     */
    where: FinancialCategoryWhereUniqueInput
  }

  /**
   * FinancialCategory findFirst
   */
  export type FinancialCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FinancialCategory to fetch.
     */
    where?: FinancialCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialCategories to fetch.
     */
    orderBy?: FinancialCategoryOrderByWithRelationInput | FinancialCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialCategories.
     */
    cursor?: FinancialCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialCategories.
     */
    distinct?: FinancialCategoryScalarFieldEnum | FinancialCategoryScalarFieldEnum[]
  }

  /**
   * FinancialCategory findFirstOrThrow
   */
  export type FinancialCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FinancialCategory to fetch.
     */
    where?: FinancialCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialCategories to fetch.
     */
    orderBy?: FinancialCategoryOrderByWithRelationInput | FinancialCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialCategories.
     */
    cursor?: FinancialCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialCategories.
     */
    distinct?: FinancialCategoryScalarFieldEnum | FinancialCategoryScalarFieldEnum[]
  }

  /**
   * FinancialCategory findMany
   */
  export type FinancialCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FinancialCategories to fetch.
     */
    where?: FinancialCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialCategories to fetch.
     */
    orderBy?: FinancialCategoryOrderByWithRelationInput | FinancialCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialCategories.
     */
    cursor?: FinancialCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialCategories.
     */
    skip?: number
    distinct?: FinancialCategoryScalarFieldEnum | FinancialCategoryScalarFieldEnum[]
  }

  /**
   * FinancialCategory create
   */
  export type FinancialCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialCategory.
     */
    data: XOR<FinancialCategoryCreateInput, FinancialCategoryUncheckedCreateInput>
  }

  /**
   * FinancialCategory createMany
   */
  export type FinancialCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialCategories.
     */
    data: FinancialCategoryCreateManyInput | FinancialCategoryCreateManyInput[]
  }

  /**
   * FinancialCategory createManyAndReturn
   */
  export type FinancialCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialCategories.
     */
    data: FinancialCategoryCreateManyInput | FinancialCategoryCreateManyInput[]
  }

  /**
   * FinancialCategory update
   */
  export type FinancialCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialCategory.
     */
    data: XOR<FinancialCategoryUpdateInput, FinancialCategoryUncheckedUpdateInput>
    /**
     * Choose, which FinancialCategory to update.
     */
    where: FinancialCategoryWhereUniqueInput
  }

  /**
   * FinancialCategory updateMany
   */
  export type FinancialCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialCategories.
     */
    data: XOR<FinancialCategoryUpdateManyMutationInput, FinancialCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FinancialCategories to update
     */
    where?: FinancialCategoryWhereInput
    /**
     * Limit how many FinancialCategories to update.
     */
    limit?: number
  }

  /**
   * FinancialCategory updateManyAndReturn
   */
  export type FinancialCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * The data used to update FinancialCategories.
     */
    data: XOR<FinancialCategoryUpdateManyMutationInput, FinancialCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FinancialCategories to update
     */
    where?: FinancialCategoryWhereInput
    /**
     * Limit how many FinancialCategories to update.
     */
    limit?: number
  }

  /**
   * FinancialCategory upsert
   */
  export type FinancialCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialCategory to update in case it exists.
     */
    where: FinancialCategoryWhereUniqueInput
    /**
     * In case the FinancialCategory found by the `where` argument doesn't exist, create a new FinancialCategory with this data.
     */
    create: XOR<FinancialCategoryCreateInput, FinancialCategoryUncheckedCreateInput>
    /**
     * In case the FinancialCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialCategoryUpdateInput, FinancialCategoryUncheckedUpdateInput>
  }

  /**
   * FinancialCategory delete
   */
  export type FinancialCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
    /**
     * Filter which FinancialCategory to delete.
     */
    where: FinancialCategoryWhereUniqueInput
  }

  /**
   * FinancialCategory deleteMany
   */
  export type FinancialCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialCategories to delete
     */
    where?: FinancialCategoryWhereInput
    /**
     * Limit how many FinancialCategories to delete.
     */
    limit?: number
  }

  /**
   * FinancialCategory.transactions
   */
  export type FinancialCategory$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    where?: FinancialTransactionWhereInput
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    cursor?: FinancialTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialCategory.dispatch_rule_details
   */
  export type FinancialCategory$dispatch_rule_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    where?: DispatchRuleDetailWhereInput
    orderBy?: DispatchRuleDetailOrderByWithRelationInput | DispatchRuleDetailOrderByWithRelationInput[]
    cursor?: DispatchRuleDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchRuleDetailScalarFieldEnum | DispatchRuleDetailScalarFieldEnum[]
  }

  /**
   * FinancialCategory without action
   */
  export type FinancialCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialCategory
     */
    select?: FinancialCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialCategory
     */
    omit?: FinancialCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialCategoryInclude<ExtArgs> | null
  }


  /**
   * Model FinancialTransaction
   */

  export type AggregateFinancialTransaction = {
    _count: FinancialTransactionCountAggregateOutputType | null
    _avg: FinancialTransactionAvgAggregateOutputType | null
    _sum: FinancialTransactionSumAggregateOutputType | null
    _min: FinancialTransactionMinAggregateOutputType | null
    _max: FinancialTransactionMaxAggregateOutputType | null
  }

  export type FinancialTransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    category_id: number | null
  }

  export type FinancialTransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    category_id: number | null
  }

  export type FinancialTransactionMinAggregateOutputType = {
    id: number | null
    date: Date | null
    description: string | null
    amount: number | null
    type: string | null
    category_id: number | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FinancialTransactionMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    description: string | null
    amount: number | null
    type: string | null
    category_id: number | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FinancialTransactionCountAggregateOutputType = {
    id: number
    date: number
    description: number
    amount: number
    type: number
    category_id: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type FinancialTransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    category_id?: true
  }

  export type FinancialTransactionSumAggregateInputType = {
    id?: true
    amount?: true
    category_id?: true
  }

  export type FinancialTransactionMinAggregateInputType = {
    id?: true
    date?: true
    description?: true
    amount?: true
    type?: true
    category_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FinancialTransactionMaxAggregateInputType = {
    id?: true
    date?: true
    description?: true
    amount?: true
    type?: true
    category_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FinancialTransactionCountAggregateInputType = {
    id?: true
    date?: true
    description?: true
    amount?: true
    type?: true
    category_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type FinancialTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialTransaction to aggregate.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialTransactions
    **/
    _count?: true | FinancialTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialTransactionMaxAggregateInputType
  }

  export type GetFinancialTransactionAggregateType<T extends FinancialTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialTransaction[P]>
      : GetScalarType<T[P], AggregateFinancialTransaction[P]>
  }




  export type FinancialTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialTransactionWhereInput
    orderBy?: FinancialTransactionOrderByWithAggregationInput | FinancialTransactionOrderByWithAggregationInput[]
    by: FinancialTransactionScalarFieldEnum[] | FinancialTransactionScalarFieldEnum
    having?: FinancialTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialTransactionCountAggregateInputType | true
    _avg?: FinancialTransactionAvgAggregateInputType
    _sum?: FinancialTransactionSumAggregateInputType
    _min?: FinancialTransactionMinAggregateInputType
    _max?: FinancialTransactionMaxAggregateInputType
  }

  export type FinancialTransactionGroupByOutputType = {
    id: number
    date: Date
    description: string
    amount: number
    type: string
    category_id: number
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: FinancialTransactionCountAggregateOutputType | null
    _avg: FinancialTransactionAvgAggregateOutputType | null
    _sum: FinancialTransactionSumAggregateOutputType | null
    _min: FinancialTransactionMinAggregateOutputType | null
    _max: FinancialTransactionMaxAggregateOutputType | null
  }

  type GetFinancialTransactionGroupByPayload<T extends FinancialTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialTransactionGroupByOutputType[P]>
        }
      >
    >


  export type FinancialTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    category_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialTransaction"]>

  export type FinancialTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    category_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialTransaction"]>

  export type FinancialTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    category_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialTransaction"]>

  export type FinancialTransactionSelectScalar = {
    id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    category_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "description" | "amount" | "type" | "category_id" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["financialTransaction"]>
  export type FinancialTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }
  export type FinancialTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }
  export type FinancialTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }

  export type $FinancialTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialTransaction"
    objects: {
      category: Prisma.$FinancialCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      description: string
      amount: number
      type: string
      category_id: number
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["financialTransaction"]>
    composites: {}
  }

  type FinancialTransactionGetPayload<S extends boolean | null | undefined | FinancialTransactionDefaultArgs> = $Result.GetResult<Prisma.$FinancialTransactionPayload, S>

  type FinancialTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialTransactionCountAggregateInputType | true
    }

  export interface FinancialTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialTransaction'], meta: { name: 'FinancialTransaction' } }
    /**
     * Find zero or one FinancialTransaction that matches the filter.
     * @param {FinancialTransactionFindUniqueArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialTransactionFindUniqueArgs>(args: SelectSubset<T, FinancialTransactionFindUniqueArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialTransactionFindUniqueOrThrowArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindFirstArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialTransactionFindFirstArgs>(args?: SelectSubset<T, FinancialTransactionFindFirstArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindFirstOrThrowArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialTransactions
     * const financialTransactions = await prisma.financialTransaction.findMany()
     * 
     * // Get first 10 FinancialTransactions
     * const financialTransactions = await prisma.financialTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialTransactionWithIdOnly = await prisma.financialTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialTransactionFindManyArgs>(args?: SelectSubset<T, FinancialTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialTransaction.
     * @param {FinancialTransactionCreateArgs} args - Arguments to create a FinancialTransaction.
     * @example
     * // Create one FinancialTransaction
     * const FinancialTransaction = await prisma.financialTransaction.create({
     *   data: {
     *     // ... data to create a FinancialTransaction
     *   }
     * })
     * 
     */
    create<T extends FinancialTransactionCreateArgs>(args: SelectSubset<T, FinancialTransactionCreateArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialTransactions.
     * @param {FinancialTransactionCreateManyArgs} args - Arguments to create many FinancialTransactions.
     * @example
     * // Create many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialTransactionCreateManyArgs>(args?: SelectSubset<T, FinancialTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialTransactions and returns the data saved in the database.
     * @param {FinancialTransactionCreateManyAndReturnArgs} args - Arguments to create many FinancialTransactions.
     * @example
     * // Create many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialTransactions and only return the `id`
     * const financialTransactionWithIdOnly = await prisma.financialTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialTransaction.
     * @param {FinancialTransactionDeleteArgs} args - Arguments to delete one FinancialTransaction.
     * @example
     * // Delete one FinancialTransaction
     * const FinancialTransaction = await prisma.financialTransaction.delete({
     *   where: {
     *     // ... filter to delete one FinancialTransaction
     *   }
     * })
     * 
     */
    delete<T extends FinancialTransactionDeleteArgs>(args: SelectSubset<T, FinancialTransactionDeleteArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialTransaction.
     * @param {FinancialTransactionUpdateArgs} args - Arguments to update one FinancialTransaction.
     * @example
     * // Update one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialTransactionUpdateArgs>(args: SelectSubset<T, FinancialTransactionUpdateArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialTransactions.
     * @param {FinancialTransactionDeleteManyArgs} args - Arguments to filter FinancialTransactions to delete.
     * @example
     * // Delete a few FinancialTransactions
     * const { count } = await prisma.financialTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialTransactionDeleteManyArgs>(args?: SelectSubset<T, FinancialTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialTransactionUpdateManyArgs>(args: SelectSubset<T, FinancialTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialTransactions and returns the data updated in the database.
     * @param {FinancialTransactionUpdateManyAndReturnArgs} args - Arguments to update many FinancialTransactions.
     * @example
     * // Update many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialTransactions and only return the `id`
     * const financialTransactionWithIdOnly = await prisma.financialTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialTransaction.
     * @param {FinancialTransactionUpsertArgs} args - Arguments to update or create a FinancialTransaction.
     * @example
     * // Update or create a FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.upsert({
     *   create: {
     *     // ... data to create a FinancialTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialTransaction we want to update
     *   }
     * })
     */
    upsert<T extends FinancialTransactionUpsertArgs>(args: SelectSubset<T, FinancialTransactionUpsertArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionCountArgs} args - Arguments to filter FinancialTransactions to count.
     * @example
     * // Count the number of FinancialTransactions
     * const count = await prisma.financialTransaction.count({
     *   where: {
     *     // ... the filter for the FinancialTransactions we want to count
     *   }
     * })
    **/
    count<T extends FinancialTransactionCountArgs>(
      args?: Subset<T, FinancialTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialTransactionAggregateArgs>(args: Subset<T, FinancialTransactionAggregateArgs>): Prisma.PrismaPromise<GetFinancialTransactionAggregateType<T>>

    /**
     * Group by FinancialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialTransactionGroupByArgs['orderBy'] }
        : { orderBy?: FinancialTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialTransaction model
   */
  readonly fields: FinancialTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends FinancialCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinancialCategoryDefaultArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialTransaction model
   */
  interface FinancialTransactionFieldRefs {
    readonly id: FieldRef<"FinancialTransaction", 'Int'>
    readonly date: FieldRef<"FinancialTransaction", 'DateTime'>
    readonly description: FieldRef<"FinancialTransaction", 'String'>
    readonly amount: FieldRef<"FinancialTransaction", 'Float'>
    readonly type: FieldRef<"FinancialTransaction", 'String'>
    readonly category_id: FieldRef<"FinancialTransaction", 'Int'>
    readonly school_id: FieldRef<"FinancialTransaction", 'String'>
    readonly supabase_id: FieldRef<"FinancialTransaction", 'String'>
    readonly last_modified: FieldRef<"FinancialTransaction", 'DateTime'>
    readonly needs_sync: FieldRef<"FinancialTransaction", 'Boolean'>
    readonly is_deleted: FieldRef<"FinancialTransaction", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FinancialTransaction findUnique
   */
  export type FinancialTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction findUniqueOrThrow
   */
  export type FinancialTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction findFirst
   */
  export type FinancialTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialTransactions.
     */
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction findFirstOrThrow
   */
  export type FinancialTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialTransactions.
     */
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction findMany
   */
  export type FinancialTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransactions to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction create
   */
  export type FinancialTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialTransaction.
     */
    data: XOR<FinancialTransactionCreateInput, FinancialTransactionUncheckedCreateInput>
  }

  /**
   * FinancialTransaction createMany
   */
  export type FinancialTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialTransactions.
     */
    data: FinancialTransactionCreateManyInput | FinancialTransactionCreateManyInput[]
  }

  /**
   * FinancialTransaction createManyAndReturn
   */
  export type FinancialTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialTransactions.
     */
    data: FinancialTransactionCreateManyInput | FinancialTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialTransaction update
   */
  export type FinancialTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialTransaction.
     */
    data: XOR<FinancialTransactionUpdateInput, FinancialTransactionUncheckedUpdateInput>
    /**
     * Choose, which FinancialTransaction to update.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction updateMany
   */
  export type FinancialTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialTransactions.
     */
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyInput>
    /**
     * Filter which FinancialTransactions to update
     */
    where?: FinancialTransactionWhereInput
    /**
     * Limit how many FinancialTransactions to update.
     */
    limit?: number
  }

  /**
   * FinancialTransaction updateManyAndReturn
   */
  export type FinancialTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * The data used to update FinancialTransactions.
     */
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyInput>
    /**
     * Filter which FinancialTransactions to update
     */
    where?: FinancialTransactionWhereInput
    /**
     * Limit how many FinancialTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialTransaction upsert
   */
  export type FinancialTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialTransaction to update in case it exists.
     */
    where: FinancialTransactionWhereUniqueInput
    /**
     * In case the FinancialTransaction found by the `where` argument doesn't exist, create a new FinancialTransaction with this data.
     */
    create: XOR<FinancialTransactionCreateInput, FinancialTransactionUncheckedCreateInput>
    /**
     * In case the FinancialTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialTransactionUpdateInput, FinancialTransactionUncheckedUpdateInput>
  }

  /**
   * FinancialTransaction delete
   */
  export type FinancialTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter which FinancialTransaction to delete.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction deleteMany
   */
  export type FinancialTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialTransactions to delete
     */
    where?: FinancialTransactionWhereInput
    /**
     * Limit how many FinancialTransactions to delete.
     */
    limit?: number
  }

  /**
   * FinancialTransaction without action
   */
  export type FinancialTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialTransaction
     */
    omit?: FinancialTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type BudgetSumAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: number | null
    category: string | null
    amount: number | null
    period_start: Date | null
    period_end: Date | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: number | null
    category: string | null
    amount: number | null
    period_start: Date | null
    period_end: Date | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    category: number
    amount: number
    period_start: number
    period_end: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type BudgetSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    category?: true
    amount?: true
    period_start?: true
    period_end?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    category?: true
    amount?: true
    period_start?: true
    period_end?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    category?: true
    amount?: true
    period_start?: true
    period_end?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: number
    category: string
    amount: number
    period_start: Date
    period_end: Date
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    amount?: boolean
    period_start?: boolean
    period_end?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    amount?: boolean
    period_start?: boolean
    period_end?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    amount?: boolean
    period_start?: boolean
    period_end?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    category?: boolean
    amount?: boolean
    period_start?: boolean
    period_end?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "amount" | "period_start" | "period_end" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["budget"]>

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      amount: number
      period_start: Date
      period_end: Date
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'Int'>
    readonly category: FieldRef<"Budget", 'String'>
    readonly amount: FieldRef<"Budget", 'Float'>
    readonly period_start: FieldRef<"Budget", 'DateTime'>
    readonly period_end: FieldRef<"Budget", 'DateTime'>
    readonly school_id: FieldRef<"Budget", 'String'>
    readonly supabase_id: FieldRef<"Budget", 'String'>
    readonly last_modified: FieldRef<"Budget", 'DateTime'>
    readonly needs_sync: FieldRef<"Budget", 'Boolean'>
    readonly is_deleted: FieldRef<"Budget", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
  }


  /**
   * Model FinancialReport
   */

  export type AggregateFinancialReport = {
    _count: FinancialReportCountAggregateOutputType | null
    _avg: FinancialReportAvgAggregateOutputType | null
    _sum: FinancialReportSumAggregateOutputType | null
    _min: FinancialReportMinAggregateOutputType | null
    _max: FinancialReportMaxAggregateOutputType | null
  }

  export type FinancialReportAvgAggregateOutputType = {
    id: number | null
  }

  export type FinancialReportSumAggregateOutputType = {
    id: number | null
  }

  export type FinancialReportMinAggregateOutputType = {
    id: number | null
    title: string | null
    generated_at: Date | null
    start_date: Date | null
    end_date: Date | null
    content: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FinancialReportMaxAggregateOutputType = {
    id: number | null
    title: string | null
    generated_at: Date | null
    start_date: Date | null
    end_date: Date | null
    content: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FinancialReportCountAggregateOutputType = {
    id: number
    title: number
    generated_at: number
    start_date: number
    end_date: number
    content: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type FinancialReportAvgAggregateInputType = {
    id?: true
  }

  export type FinancialReportSumAggregateInputType = {
    id?: true
  }

  export type FinancialReportMinAggregateInputType = {
    id?: true
    title?: true
    generated_at?: true
    start_date?: true
    end_date?: true
    content?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FinancialReportMaxAggregateInputType = {
    id?: true
    title?: true
    generated_at?: true
    start_date?: true
    end_date?: true
    content?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FinancialReportCountAggregateInputType = {
    id?: true
    title?: true
    generated_at?: true
    start_date?: true
    end_date?: true
    content?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type FinancialReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialReport to aggregate.
     */
    where?: FinancialReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialReports to fetch.
     */
    orderBy?: FinancialReportOrderByWithRelationInput | FinancialReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialReports
    **/
    _count?: true | FinancialReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialReportMaxAggregateInputType
  }

  export type GetFinancialReportAggregateType<T extends FinancialReportAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialReport[P]>
      : GetScalarType<T[P], AggregateFinancialReport[P]>
  }




  export type FinancialReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialReportWhereInput
    orderBy?: FinancialReportOrderByWithAggregationInput | FinancialReportOrderByWithAggregationInput[]
    by: FinancialReportScalarFieldEnum[] | FinancialReportScalarFieldEnum
    having?: FinancialReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialReportCountAggregateInputType | true
    _avg?: FinancialReportAvgAggregateInputType
    _sum?: FinancialReportSumAggregateInputType
    _min?: FinancialReportMinAggregateInputType
    _max?: FinancialReportMaxAggregateInputType
  }

  export type FinancialReportGroupByOutputType = {
    id: number
    title: string
    generated_at: Date
    start_date: Date
    end_date: Date
    content: string
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: FinancialReportCountAggregateOutputType | null
    _avg: FinancialReportAvgAggregateOutputType | null
    _sum: FinancialReportSumAggregateOutputType | null
    _min: FinancialReportMinAggregateOutputType | null
    _max: FinancialReportMaxAggregateOutputType | null
  }

  type GetFinancialReportGroupByPayload<T extends FinancialReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialReportGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialReportGroupByOutputType[P]>
        }
      >
    >


  export type FinancialReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    generated_at?: boolean
    start_date?: boolean
    end_date?: boolean
    content?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["financialReport"]>

  export type FinancialReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    generated_at?: boolean
    start_date?: boolean
    end_date?: boolean
    content?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["financialReport"]>

  export type FinancialReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    generated_at?: boolean
    start_date?: boolean
    end_date?: boolean
    content?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["financialReport"]>

  export type FinancialReportSelectScalar = {
    id?: boolean
    title?: boolean
    generated_at?: boolean
    start_date?: boolean
    end_date?: boolean
    content?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "generated_at" | "start_date" | "end_date" | "content" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["financialReport"]>

  export type $FinancialReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      generated_at: Date
      start_date: Date
      end_date: Date
      content: string
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["financialReport"]>
    composites: {}
  }

  type FinancialReportGetPayload<S extends boolean | null | undefined | FinancialReportDefaultArgs> = $Result.GetResult<Prisma.$FinancialReportPayload, S>

  type FinancialReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialReportCountAggregateInputType | true
    }

  export interface FinancialReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialReport'], meta: { name: 'FinancialReport' } }
    /**
     * Find zero or one FinancialReport that matches the filter.
     * @param {FinancialReportFindUniqueArgs} args - Arguments to find a FinancialReport
     * @example
     * // Get one FinancialReport
     * const financialReport = await prisma.financialReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialReportFindUniqueArgs>(args: SelectSubset<T, FinancialReportFindUniqueArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialReportFindUniqueOrThrowArgs} args - Arguments to find a FinancialReport
     * @example
     * // Get one FinancialReport
     * const financialReport = await prisma.financialReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialReportFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialReportFindFirstArgs} args - Arguments to find a FinancialReport
     * @example
     * // Get one FinancialReport
     * const financialReport = await prisma.financialReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialReportFindFirstArgs>(args?: SelectSubset<T, FinancialReportFindFirstArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialReportFindFirstOrThrowArgs} args - Arguments to find a FinancialReport
     * @example
     * // Get one FinancialReport
     * const financialReport = await prisma.financialReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialReportFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialReports
     * const financialReports = await prisma.financialReport.findMany()
     * 
     * // Get first 10 FinancialReports
     * const financialReports = await prisma.financialReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialReportWithIdOnly = await prisma.financialReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialReportFindManyArgs>(args?: SelectSubset<T, FinancialReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialReport.
     * @param {FinancialReportCreateArgs} args - Arguments to create a FinancialReport.
     * @example
     * // Create one FinancialReport
     * const FinancialReport = await prisma.financialReport.create({
     *   data: {
     *     // ... data to create a FinancialReport
     *   }
     * })
     * 
     */
    create<T extends FinancialReportCreateArgs>(args: SelectSubset<T, FinancialReportCreateArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialReports.
     * @param {FinancialReportCreateManyArgs} args - Arguments to create many FinancialReports.
     * @example
     * // Create many FinancialReports
     * const financialReport = await prisma.financialReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialReportCreateManyArgs>(args?: SelectSubset<T, FinancialReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialReports and returns the data saved in the database.
     * @param {FinancialReportCreateManyAndReturnArgs} args - Arguments to create many FinancialReports.
     * @example
     * // Create many FinancialReports
     * const financialReport = await prisma.financialReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialReports and only return the `id`
     * const financialReportWithIdOnly = await prisma.financialReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialReportCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialReport.
     * @param {FinancialReportDeleteArgs} args - Arguments to delete one FinancialReport.
     * @example
     * // Delete one FinancialReport
     * const FinancialReport = await prisma.financialReport.delete({
     *   where: {
     *     // ... filter to delete one FinancialReport
     *   }
     * })
     * 
     */
    delete<T extends FinancialReportDeleteArgs>(args: SelectSubset<T, FinancialReportDeleteArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialReport.
     * @param {FinancialReportUpdateArgs} args - Arguments to update one FinancialReport.
     * @example
     * // Update one FinancialReport
     * const financialReport = await prisma.financialReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialReportUpdateArgs>(args: SelectSubset<T, FinancialReportUpdateArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialReports.
     * @param {FinancialReportDeleteManyArgs} args - Arguments to filter FinancialReports to delete.
     * @example
     * // Delete a few FinancialReports
     * const { count } = await prisma.financialReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialReportDeleteManyArgs>(args?: SelectSubset<T, FinancialReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialReports
     * const financialReport = await prisma.financialReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialReportUpdateManyArgs>(args: SelectSubset<T, FinancialReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialReports and returns the data updated in the database.
     * @param {FinancialReportUpdateManyAndReturnArgs} args - Arguments to update many FinancialReports.
     * @example
     * // Update many FinancialReports
     * const financialReport = await prisma.financialReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialReports and only return the `id`
     * const financialReportWithIdOnly = await prisma.financialReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialReportUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialReport.
     * @param {FinancialReportUpsertArgs} args - Arguments to update or create a FinancialReport.
     * @example
     * // Update or create a FinancialReport
     * const financialReport = await prisma.financialReport.upsert({
     *   create: {
     *     // ... data to create a FinancialReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialReport we want to update
     *   }
     * })
     */
    upsert<T extends FinancialReportUpsertArgs>(args: SelectSubset<T, FinancialReportUpsertArgs<ExtArgs>>): Prisma__FinancialReportClient<$Result.GetResult<Prisma.$FinancialReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialReportCountArgs} args - Arguments to filter FinancialReports to count.
     * @example
     * // Count the number of FinancialReports
     * const count = await prisma.financialReport.count({
     *   where: {
     *     // ... the filter for the FinancialReports we want to count
     *   }
     * })
    **/
    count<T extends FinancialReportCountArgs>(
      args?: Subset<T, FinancialReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialReportAggregateArgs>(args: Subset<T, FinancialReportAggregateArgs>): Prisma.PrismaPromise<GetFinancialReportAggregateType<T>>

    /**
     * Group by FinancialReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialReportGroupByArgs['orderBy'] }
        : { orderBy?: FinancialReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialReport model
   */
  readonly fields: FinancialReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialReport model
   */
  interface FinancialReportFieldRefs {
    readonly id: FieldRef<"FinancialReport", 'Int'>
    readonly title: FieldRef<"FinancialReport", 'String'>
    readonly generated_at: FieldRef<"FinancialReport", 'DateTime'>
    readonly start_date: FieldRef<"FinancialReport", 'DateTime'>
    readonly end_date: FieldRef<"FinancialReport", 'DateTime'>
    readonly content: FieldRef<"FinancialReport", 'String'>
    readonly school_id: FieldRef<"FinancialReport", 'String'>
    readonly supabase_id: FieldRef<"FinancialReport", 'String'>
    readonly last_modified: FieldRef<"FinancialReport", 'DateTime'>
    readonly needs_sync: FieldRef<"FinancialReport", 'Boolean'>
    readonly is_deleted: FieldRef<"FinancialReport", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FinancialReport findUnique
   */
  export type FinancialReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * Filter, which FinancialReport to fetch.
     */
    where: FinancialReportWhereUniqueInput
  }

  /**
   * FinancialReport findUniqueOrThrow
   */
  export type FinancialReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * Filter, which FinancialReport to fetch.
     */
    where: FinancialReportWhereUniqueInput
  }

  /**
   * FinancialReport findFirst
   */
  export type FinancialReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * Filter, which FinancialReport to fetch.
     */
    where?: FinancialReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialReports to fetch.
     */
    orderBy?: FinancialReportOrderByWithRelationInput | FinancialReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialReports.
     */
    cursor?: FinancialReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialReports.
     */
    distinct?: FinancialReportScalarFieldEnum | FinancialReportScalarFieldEnum[]
  }

  /**
   * FinancialReport findFirstOrThrow
   */
  export type FinancialReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * Filter, which FinancialReport to fetch.
     */
    where?: FinancialReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialReports to fetch.
     */
    orderBy?: FinancialReportOrderByWithRelationInput | FinancialReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialReports.
     */
    cursor?: FinancialReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialReports.
     */
    distinct?: FinancialReportScalarFieldEnum | FinancialReportScalarFieldEnum[]
  }

  /**
   * FinancialReport findMany
   */
  export type FinancialReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * Filter, which FinancialReports to fetch.
     */
    where?: FinancialReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialReports to fetch.
     */
    orderBy?: FinancialReportOrderByWithRelationInput | FinancialReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialReports.
     */
    cursor?: FinancialReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialReports.
     */
    skip?: number
    distinct?: FinancialReportScalarFieldEnum | FinancialReportScalarFieldEnum[]
  }

  /**
   * FinancialReport create
   */
  export type FinancialReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * The data needed to create a FinancialReport.
     */
    data: XOR<FinancialReportCreateInput, FinancialReportUncheckedCreateInput>
  }

  /**
   * FinancialReport createMany
   */
  export type FinancialReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialReports.
     */
    data: FinancialReportCreateManyInput | FinancialReportCreateManyInput[]
  }

  /**
   * FinancialReport createManyAndReturn
   */
  export type FinancialReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialReports.
     */
    data: FinancialReportCreateManyInput | FinancialReportCreateManyInput[]
  }

  /**
   * FinancialReport update
   */
  export type FinancialReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * The data needed to update a FinancialReport.
     */
    data: XOR<FinancialReportUpdateInput, FinancialReportUncheckedUpdateInput>
    /**
     * Choose, which FinancialReport to update.
     */
    where: FinancialReportWhereUniqueInput
  }

  /**
   * FinancialReport updateMany
   */
  export type FinancialReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialReports.
     */
    data: XOR<FinancialReportUpdateManyMutationInput, FinancialReportUncheckedUpdateManyInput>
    /**
     * Filter which FinancialReports to update
     */
    where?: FinancialReportWhereInput
    /**
     * Limit how many FinancialReports to update.
     */
    limit?: number
  }

  /**
   * FinancialReport updateManyAndReturn
   */
  export type FinancialReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * The data used to update FinancialReports.
     */
    data: XOR<FinancialReportUpdateManyMutationInput, FinancialReportUncheckedUpdateManyInput>
    /**
     * Filter which FinancialReports to update
     */
    where?: FinancialReportWhereInput
    /**
     * Limit how many FinancialReports to update.
     */
    limit?: number
  }

  /**
   * FinancialReport upsert
   */
  export type FinancialReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * The filter to search for the FinancialReport to update in case it exists.
     */
    where: FinancialReportWhereUniqueInput
    /**
     * In case the FinancialReport found by the `where` argument doesn't exist, create a new FinancialReport with this data.
     */
    create: XOR<FinancialReportCreateInput, FinancialReportUncheckedCreateInput>
    /**
     * In case the FinancialReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialReportUpdateInput, FinancialReportUncheckedUpdateInput>
  }

  /**
   * FinancialReport delete
   */
  export type FinancialReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
    /**
     * Filter which FinancialReport to delete.
     */
    where: FinancialReportWhereUniqueInput
  }

  /**
   * FinancialReport deleteMany
   */
  export type FinancialReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialReports to delete
     */
    where?: FinancialReportWhereInput
    /**
     * Limit how many FinancialReports to delete.
     */
    limit?: number
  }

  /**
   * FinancialReport without action
   */
  export type FinancialReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialReport
     */
    select?: FinancialReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialReport
     */
    omit?: FinancialReportOmit<ExtArgs> | null
  }


  /**
   * Model DispatchRule
   */

  export type AggregateDispatchRule = {
    _count: DispatchRuleCountAggregateOutputType | null
    _avg: DispatchRuleAvgAggregateOutputType | null
    _sum: DispatchRuleSumAggregateOutputType | null
    _min: DispatchRuleMinAggregateOutputType | null
    _max: DispatchRuleMaxAggregateOutputType | null
  }

  export type DispatchRuleAvgAggregateOutputType = {
    id: number | null
    source_single_fee_id: number | null
  }

  export type DispatchRuleSumAggregateOutputType = {
    id: number | null
    source_single_fee_id: number | null
  }

  export type DispatchRuleMinAggregateOutputType = {
    id: number | null
    name: string | null
    source_single_fee_id: number | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type DispatchRuleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    source_single_fee_id: number | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type DispatchRuleCountAggregateOutputType = {
    id: number
    name: number
    source_single_fee_id: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type DispatchRuleAvgAggregateInputType = {
    id?: true
    source_single_fee_id?: true
  }

  export type DispatchRuleSumAggregateInputType = {
    id?: true
    source_single_fee_id?: true
  }

  export type DispatchRuleMinAggregateInputType = {
    id?: true
    name?: true
    source_single_fee_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type DispatchRuleMaxAggregateInputType = {
    id?: true
    name?: true
    source_single_fee_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type DispatchRuleCountAggregateInputType = {
    id?: true
    name?: true
    source_single_fee_id?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type DispatchRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatchRule to aggregate.
     */
    where?: DispatchRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRules to fetch.
     */
    orderBy?: DispatchRuleOrderByWithRelationInput | DispatchRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispatchRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DispatchRules
    **/
    _count?: true | DispatchRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispatchRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispatchRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispatchRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispatchRuleMaxAggregateInputType
  }

  export type GetDispatchRuleAggregateType<T extends DispatchRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateDispatchRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispatchRule[P]>
      : GetScalarType<T[P], AggregateDispatchRule[P]>
  }




  export type DispatchRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchRuleWhereInput
    orderBy?: DispatchRuleOrderByWithAggregationInput | DispatchRuleOrderByWithAggregationInput[]
    by: DispatchRuleScalarFieldEnum[] | DispatchRuleScalarFieldEnum
    having?: DispatchRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispatchRuleCountAggregateInputType | true
    _avg?: DispatchRuleAvgAggregateInputType
    _sum?: DispatchRuleSumAggregateInputType
    _min?: DispatchRuleMinAggregateInputType
    _max?: DispatchRuleMaxAggregateInputType
  }

  export type DispatchRuleGroupByOutputType = {
    id: number
    name: string
    source_single_fee_id: number
    school_id: string
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: DispatchRuleCountAggregateOutputType | null
    _avg: DispatchRuleAvgAggregateOutputType | null
    _sum: DispatchRuleSumAggregateOutputType | null
    _min: DispatchRuleMinAggregateOutputType | null
    _max: DispatchRuleMaxAggregateOutputType | null
  }

  type GetDispatchRuleGroupByPayload<T extends DispatchRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispatchRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispatchRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispatchRuleGroupByOutputType[P]>
            : GetScalarType<T[P], DispatchRuleGroupByOutputType[P]>
        }
      >
    >


  export type DispatchRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    source_single_fee_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    source_single_fee?: boolean | SingleFeeDefaultArgs<ExtArgs>
    details?: boolean | DispatchRule$detailsArgs<ExtArgs>
    _count?: boolean | DispatchRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchRule"]>

  export type DispatchRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    source_single_fee_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    source_single_fee?: boolean | SingleFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchRule"]>

  export type DispatchRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    source_single_fee_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    source_single_fee?: boolean | SingleFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchRule"]>

  export type DispatchRuleSelectScalar = {
    id?: boolean
    name?: boolean
    source_single_fee_id?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "source_single_fee_id" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["dispatchRule"]>
  export type DispatchRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source_single_fee?: boolean | SingleFeeDefaultArgs<ExtArgs>
    details?: boolean | DispatchRule$detailsArgs<ExtArgs>
    _count?: boolean | DispatchRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DispatchRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source_single_fee?: boolean | SingleFeeDefaultArgs<ExtArgs>
  }
  export type DispatchRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source_single_fee?: boolean | SingleFeeDefaultArgs<ExtArgs>
  }

  export type $DispatchRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DispatchRule"
    objects: {
      source_single_fee: Prisma.$SingleFeePayload<ExtArgs>
      details: Prisma.$DispatchRuleDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      source_single_fee_id: number
      school_id: string
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["dispatchRule"]>
    composites: {}
  }

  type DispatchRuleGetPayload<S extends boolean | null | undefined | DispatchRuleDefaultArgs> = $Result.GetResult<Prisma.$DispatchRulePayload, S>

  type DispatchRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispatchRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispatchRuleCountAggregateInputType | true
    }

  export interface DispatchRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DispatchRule'], meta: { name: 'DispatchRule' } }
    /**
     * Find zero or one DispatchRule that matches the filter.
     * @param {DispatchRuleFindUniqueArgs} args - Arguments to find a DispatchRule
     * @example
     * // Get one DispatchRule
     * const dispatchRule = await prisma.dispatchRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispatchRuleFindUniqueArgs>(args: SelectSubset<T, DispatchRuleFindUniqueArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DispatchRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispatchRuleFindUniqueOrThrowArgs} args - Arguments to find a DispatchRule
     * @example
     * // Get one DispatchRule
     * const dispatchRule = await prisma.dispatchRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispatchRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, DispatchRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatchRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleFindFirstArgs} args - Arguments to find a DispatchRule
     * @example
     * // Get one DispatchRule
     * const dispatchRule = await prisma.dispatchRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispatchRuleFindFirstArgs>(args?: SelectSubset<T, DispatchRuleFindFirstArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatchRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleFindFirstOrThrowArgs} args - Arguments to find a DispatchRule
     * @example
     * // Get one DispatchRule
     * const dispatchRule = await prisma.dispatchRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispatchRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, DispatchRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DispatchRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DispatchRules
     * const dispatchRules = await prisma.dispatchRule.findMany()
     * 
     * // Get first 10 DispatchRules
     * const dispatchRules = await prisma.dispatchRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispatchRuleWithIdOnly = await prisma.dispatchRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispatchRuleFindManyArgs>(args?: SelectSubset<T, DispatchRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DispatchRule.
     * @param {DispatchRuleCreateArgs} args - Arguments to create a DispatchRule.
     * @example
     * // Create one DispatchRule
     * const DispatchRule = await prisma.dispatchRule.create({
     *   data: {
     *     // ... data to create a DispatchRule
     *   }
     * })
     * 
     */
    create<T extends DispatchRuleCreateArgs>(args: SelectSubset<T, DispatchRuleCreateArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DispatchRules.
     * @param {DispatchRuleCreateManyArgs} args - Arguments to create many DispatchRules.
     * @example
     * // Create many DispatchRules
     * const dispatchRule = await prisma.dispatchRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispatchRuleCreateManyArgs>(args?: SelectSubset<T, DispatchRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DispatchRules and returns the data saved in the database.
     * @param {DispatchRuleCreateManyAndReturnArgs} args - Arguments to create many DispatchRules.
     * @example
     * // Create many DispatchRules
     * const dispatchRule = await prisma.dispatchRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DispatchRules and only return the `id`
     * const dispatchRuleWithIdOnly = await prisma.dispatchRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispatchRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, DispatchRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DispatchRule.
     * @param {DispatchRuleDeleteArgs} args - Arguments to delete one DispatchRule.
     * @example
     * // Delete one DispatchRule
     * const DispatchRule = await prisma.dispatchRule.delete({
     *   where: {
     *     // ... filter to delete one DispatchRule
     *   }
     * })
     * 
     */
    delete<T extends DispatchRuleDeleteArgs>(args: SelectSubset<T, DispatchRuleDeleteArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DispatchRule.
     * @param {DispatchRuleUpdateArgs} args - Arguments to update one DispatchRule.
     * @example
     * // Update one DispatchRule
     * const dispatchRule = await prisma.dispatchRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispatchRuleUpdateArgs>(args: SelectSubset<T, DispatchRuleUpdateArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DispatchRules.
     * @param {DispatchRuleDeleteManyArgs} args - Arguments to filter DispatchRules to delete.
     * @example
     * // Delete a few DispatchRules
     * const { count } = await prisma.dispatchRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispatchRuleDeleteManyArgs>(args?: SelectSubset<T, DispatchRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatchRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DispatchRules
     * const dispatchRule = await prisma.dispatchRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispatchRuleUpdateManyArgs>(args: SelectSubset<T, DispatchRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatchRules and returns the data updated in the database.
     * @param {DispatchRuleUpdateManyAndReturnArgs} args - Arguments to update many DispatchRules.
     * @example
     * // Update many DispatchRules
     * const dispatchRule = await prisma.dispatchRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DispatchRules and only return the `id`
     * const dispatchRuleWithIdOnly = await prisma.dispatchRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispatchRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, DispatchRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DispatchRule.
     * @param {DispatchRuleUpsertArgs} args - Arguments to update or create a DispatchRule.
     * @example
     * // Update or create a DispatchRule
     * const dispatchRule = await prisma.dispatchRule.upsert({
     *   create: {
     *     // ... data to create a DispatchRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DispatchRule we want to update
     *   }
     * })
     */
    upsert<T extends DispatchRuleUpsertArgs>(args: SelectSubset<T, DispatchRuleUpsertArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DispatchRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleCountArgs} args - Arguments to filter DispatchRules to count.
     * @example
     * // Count the number of DispatchRules
     * const count = await prisma.dispatchRule.count({
     *   where: {
     *     // ... the filter for the DispatchRules we want to count
     *   }
     * })
    **/
    count<T extends DispatchRuleCountArgs>(
      args?: Subset<T, DispatchRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispatchRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DispatchRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispatchRuleAggregateArgs>(args: Subset<T, DispatchRuleAggregateArgs>): Prisma.PrismaPromise<GetDispatchRuleAggregateType<T>>

    /**
     * Group by DispatchRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispatchRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispatchRuleGroupByArgs['orderBy'] }
        : { orderBy?: DispatchRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispatchRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispatchRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DispatchRule model
   */
  readonly fields: DispatchRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DispatchRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispatchRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source_single_fee<T extends SingleFeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SingleFeeDefaultArgs<ExtArgs>>): Prisma__SingleFeeClient<$Result.GetResult<Prisma.$SingleFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    details<T extends DispatchRule$detailsArgs<ExtArgs> = {}>(args?: Subset<T, DispatchRule$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DispatchRule model
   */
  interface DispatchRuleFieldRefs {
    readonly id: FieldRef<"DispatchRule", 'Int'>
    readonly name: FieldRef<"DispatchRule", 'String'>
    readonly source_single_fee_id: FieldRef<"DispatchRule", 'Int'>
    readonly school_id: FieldRef<"DispatchRule", 'String'>
    readonly supabase_id: FieldRef<"DispatchRule", 'String'>
    readonly last_modified: FieldRef<"DispatchRule", 'DateTime'>
    readonly needs_sync: FieldRef<"DispatchRule", 'Boolean'>
    readonly is_deleted: FieldRef<"DispatchRule", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DispatchRule findUnique
   */
  export type DispatchRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRule to fetch.
     */
    where: DispatchRuleWhereUniqueInput
  }

  /**
   * DispatchRule findUniqueOrThrow
   */
  export type DispatchRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRule to fetch.
     */
    where: DispatchRuleWhereUniqueInput
  }

  /**
   * DispatchRule findFirst
   */
  export type DispatchRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRule to fetch.
     */
    where?: DispatchRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRules to fetch.
     */
    orderBy?: DispatchRuleOrderByWithRelationInput | DispatchRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatchRules.
     */
    cursor?: DispatchRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatchRules.
     */
    distinct?: DispatchRuleScalarFieldEnum | DispatchRuleScalarFieldEnum[]
  }

  /**
   * DispatchRule findFirstOrThrow
   */
  export type DispatchRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRule to fetch.
     */
    where?: DispatchRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRules to fetch.
     */
    orderBy?: DispatchRuleOrderByWithRelationInput | DispatchRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatchRules.
     */
    cursor?: DispatchRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatchRules.
     */
    distinct?: DispatchRuleScalarFieldEnum | DispatchRuleScalarFieldEnum[]
  }

  /**
   * DispatchRule findMany
   */
  export type DispatchRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRules to fetch.
     */
    where?: DispatchRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRules to fetch.
     */
    orderBy?: DispatchRuleOrderByWithRelationInput | DispatchRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DispatchRules.
     */
    cursor?: DispatchRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRules.
     */
    skip?: number
    distinct?: DispatchRuleScalarFieldEnum | DispatchRuleScalarFieldEnum[]
  }

  /**
   * DispatchRule create
   */
  export type DispatchRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a DispatchRule.
     */
    data: XOR<DispatchRuleCreateInput, DispatchRuleUncheckedCreateInput>
  }

  /**
   * DispatchRule createMany
   */
  export type DispatchRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DispatchRules.
     */
    data: DispatchRuleCreateManyInput | DispatchRuleCreateManyInput[]
  }

  /**
   * DispatchRule createManyAndReturn
   */
  export type DispatchRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * The data used to create many DispatchRules.
     */
    data: DispatchRuleCreateManyInput | DispatchRuleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatchRule update
   */
  export type DispatchRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a DispatchRule.
     */
    data: XOR<DispatchRuleUpdateInput, DispatchRuleUncheckedUpdateInput>
    /**
     * Choose, which DispatchRule to update.
     */
    where: DispatchRuleWhereUniqueInput
  }

  /**
   * DispatchRule updateMany
   */
  export type DispatchRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DispatchRules.
     */
    data: XOR<DispatchRuleUpdateManyMutationInput, DispatchRuleUncheckedUpdateManyInput>
    /**
     * Filter which DispatchRules to update
     */
    where?: DispatchRuleWhereInput
    /**
     * Limit how many DispatchRules to update.
     */
    limit?: number
  }

  /**
   * DispatchRule updateManyAndReturn
   */
  export type DispatchRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * The data used to update DispatchRules.
     */
    data: XOR<DispatchRuleUpdateManyMutationInput, DispatchRuleUncheckedUpdateManyInput>
    /**
     * Filter which DispatchRules to update
     */
    where?: DispatchRuleWhereInput
    /**
     * Limit how many DispatchRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatchRule upsert
   */
  export type DispatchRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the DispatchRule to update in case it exists.
     */
    where: DispatchRuleWhereUniqueInput
    /**
     * In case the DispatchRule found by the `where` argument doesn't exist, create a new DispatchRule with this data.
     */
    create: XOR<DispatchRuleCreateInput, DispatchRuleUncheckedCreateInput>
    /**
     * In case the DispatchRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispatchRuleUpdateInput, DispatchRuleUncheckedUpdateInput>
  }

  /**
   * DispatchRule delete
   */
  export type DispatchRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
    /**
     * Filter which DispatchRule to delete.
     */
    where: DispatchRuleWhereUniqueInput
  }

  /**
   * DispatchRule deleteMany
   */
  export type DispatchRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatchRules to delete
     */
    where?: DispatchRuleWhereInput
    /**
     * Limit how many DispatchRules to delete.
     */
    limit?: number
  }

  /**
   * DispatchRule.details
   */
  export type DispatchRule$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    where?: DispatchRuleDetailWhereInput
    orderBy?: DispatchRuleDetailOrderByWithRelationInput | DispatchRuleDetailOrderByWithRelationInput[]
    cursor?: DispatchRuleDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchRuleDetailScalarFieldEnum | DispatchRuleDetailScalarFieldEnum[]
  }

  /**
   * DispatchRule without action
   */
  export type DispatchRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRule
     */
    select?: DispatchRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRule
     */
    omit?: DispatchRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleInclude<ExtArgs> | null
  }


  /**
   * Model DispatchRuleDetail
   */

  export type AggregateDispatchRuleDetail = {
    _count: DispatchRuleDetailCountAggregateOutputType | null
    _avg: DispatchRuleDetailAvgAggregateOutputType | null
    _sum: DispatchRuleDetailSumAggregateOutputType | null
    _min: DispatchRuleDetailMinAggregateOutputType | null
    _max: DispatchRuleDetailMaxAggregateOutputType | null
  }

  export type DispatchRuleDetailAvgAggregateOutputType = {
    id: number | null
    dispatch_rule_id: number | null
    destination_category_id: number | null
    percentage: number | null
  }

  export type DispatchRuleDetailSumAggregateOutputType = {
    id: number | null
    dispatch_rule_id: number | null
    destination_category_id: number | null
    percentage: number | null
  }

  export type DispatchRuleDetailMinAggregateOutputType = {
    id: number | null
    dispatch_rule_id: number | null
    destination_category_id: number | null
    percentage: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type DispatchRuleDetailMaxAggregateOutputType = {
    id: number | null
    dispatch_rule_id: number | null
    destination_category_id: number | null
    percentage: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type DispatchRuleDetailCountAggregateOutputType = {
    id: number
    dispatch_rule_id: number
    destination_category_id: number
    percentage: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type DispatchRuleDetailAvgAggregateInputType = {
    id?: true
    dispatch_rule_id?: true
    destination_category_id?: true
    percentage?: true
  }

  export type DispatchRuleDetailSumAggregateInputType = {
    id?: true
    dispatch_rule_id?: true
    destination_category_id?: true
    percentage?: true
  }

  export type DispatchRuleDetailMinAggregateInputType = {
    id?: true
    dispatch_rule_id?: true
    destination_category_id?: true
    percentage?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type DispatchRuleDetailMaxAggregateInputType = {
    id?: true
    dispatch_rule_id?: true
    destination_category_id?: true
    percentage?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type DispatchRuleDetailCountAggregateInputType = {
    id?: true
    dispatch_rule_id?: true
    destination_category_id?: true
    percentage?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type DispatchRuleDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatchRuleDetail to aggregate.
     */
    where?: DispatchRuleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRuleDetails to fetch.
     */
    orderBy?: DispatchRuleDetailOrderByWithRelationInput | DispatchRuleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispatchRuleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRuleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRuleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DispatchRuleDetails
    **/
    _count?: true | DispatchRuleDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispatchRuleDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispatchRuleDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispatchRuleDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispatchRuleDetailMaxAggregateInputType
  }

  export type GetDispatchRuleDetailAggregateType<T extends DispatchRuleDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateDispatchRuleDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispatchRuleDetail[P]>
      : GetScalarType<T[P], AggregateDispatchRuleDetail[P]>
  }




  export type DispatchRuleDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchRuleDetailWhereInput
    orderBy?: DispatchRuleDetailOrderByWithAggregationInput | DispatchRuleDetailOrderByWithAggregationInput[]
    by: DispatchRuleDetailScalarFieldEnum[] | DispatchRuleDetailScalarFieldEnum
    having?: DispatchRuleDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispatchRuleDetailCountAggregateInputType | true
    _avg?: DispatchRuleDetailAvgAggregateInputType
    _sum?: DispatchRuleDetailSumAggregateInputType
    _min?: DispatchRuleDetailMinAggregateInputType
    _max?: DispatchRuleDetailMaxAggregateInputType
  }

  export type DispatchRuleDetailGroupByOutputType = {
    id: number
    dispatch_rule_id: number
    destination_category_id: number
    percentage: number
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: DispatchRuleDetailCountAggregateOutputType | null
    _avg: DispatchRuleDetailAvgAggregateOutputType | null
    _sum: DispatchRuleDetailSumAggregateOutputType | null
    _min: DispatchRuleDetailMinAggregateOutputType | null
    _max: DispatchRuleDetailMaxAggregateOutputType | null
  }

  type GetDispatchRuleDetailGroupByPayload<T extends DispatchRuleDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispatchRuleDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispatchRuleDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispatchRuleDetailGroupByOutputType[P]>
            : GetScalarType<T[P], DispatchRuleDetailGroupByOutputType[P]>
        }
      >
    >


  export type DispatchRuleDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispatch_rule_id?: boolean
    destination_category_id?: boolean
    percentage?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rule?: boolean | DispatchRuleDefaultArgs<ExtArgs>
    destination_category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchRuleDetail"]>

  export type DispatchRuleDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispatch_rule_id?: boolean
    destination_category_id?: boolean
    percentage?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rule?: boolean | DispatchRuleDefaultArgs<ExtArgs>
    destination_category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchRuleDetail"]>

  export type DispatchRuleDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispatch_rule_id?: boolean
    destination_category_id?: boolean
    percentage?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rule?: boolean | DispatchRuleDefaultArgs<ExtArgs>
    destination_category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchRuleDetail"]>

  export type DispatchRuleDetailSelectScalar = {
    id?: boolean
    dispatch_rule_id?: boolean
    destination_category_id?: boolean
    percentage?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dispatch_rule_id" | "destination_category_id" | "percentage" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["dispatchRuleDetail"]>
  export type DispatchRuleDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispatch_rule?: boolean | DispatchRuleDefaultArgs<ExtArgs>
    destination_category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }
  export type DispatchRuleDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispatch_rule?: boolean | DispatchRuleDefaultArgs<ExtArgs>
    destination_category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }
  export type DispatchRuleDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispatch_rule?: boolean | DispatchRuleDefaultArgs<ExtArgs>
    destination_category?: boolean | FinancialCategoryDefaultArgs<ExtArgs>
  }

  export type $DispatchRuleDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DispatchRuleDetail"
    objects: {
      dispatch_rule: Prisma.$DispatchRulePayload<ExtArgs>
      destination_category: Prisma.$FinancialCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dispatch_rule_id: number
      destination_category_id: number
      percentage: number
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["dispatchRuleDetail"]>
    composites: {}
  }

  type DispatchRuleDetailGetPayload<S extends boolean | null | undefined | DispatchRuleDetailDefaultArgs> = $Result.GetResult<Prisma.$DispatchRuleDetailPayload, S>

  type DispatchRuleDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispatchRuleDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispatchRuleDetailCountAggregateInputType | true
    }

  export interface DispatchRuleDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DispatchRuleDetail'], meta: { name: 'DispatchRuleDetail' } }
    /**
     * Find zero or one DispatchRuleDetail that matches the filter.
     * @param {DispatchRuleDetailFindUniqueArgs} args - Arguments to find a DispatchRuleDetail
     * @example
     * // Get one DispatchRuleDetail
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispatchRuleDetailFindUniqueArgs>(args: SelectSubset<T, DispatchRuleDetailFindUniqueArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DispatchRuleDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispatchRuleDetailFindUniqueOrThrowArgs} args - Arguments to find a DispatchRuleDetail
     * @example
     * // Get one DispatchRuleDetail
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispatchRuleDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, DispatchRuleDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatchRuleDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleDetailFindFirstArgs} args - Arguments to find a DispatchRuleDetail
     * @example
     * // Get one DispatchRuleDetail
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispatchRuleDetailFindFirstArgs>(args?: SelectSubset<T, DispatchRuleDetailFindFirstArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatchRuleDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleDetailFindFirstOrThrowArgs} args - Arguments to find a DispatchRuleDetail
     * @example
     * // Get one DispatchRuleDetail
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispatchRuleDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, DispatchRuleDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DispatchRuleDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DispatchRuleDetails
     * const dispatchRuleDetails = await prisma.dispatchRuleDetail.findMany()
     * 
     * // Get first 10 DispatchRuleDetails
     * const dispatchRuleDetails = await prisma.dispatchRuleDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispatchRuleDetailWithIdOnly = await prisma.dispatchRuleDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispatchRuleDetailFindManyArgs>(args?: SelectSubset<T, DispatchRuleDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DispatchRuleDetail.
     * @param {DispatchRuleDetailCreateArgs} args - Arguments to create a DispatchRuleDetail.
     * @example
     * // Create one DispatchRuleDetail
     * const DispatchRuleDetail = await prisma.dispatchRuleDetail.create({
     *   data: {
     *     // ... data to create a DispatchRuleDetail
     *   }
     * })
     * 
     */
    create<T extends DispatchRuleDetailCreateArgs>(args: SelectSubset<T, DispatchRuleDetailCreateArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DispatchRuleDetails.
     * @param {DispatchRuleDetailCreateManyArgs} args - Arguments to create many DispatchRuleDetails.
     * @example
     * // Create many DispatchRuleDetails
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispatchRuleDetailCreateManyArgs>(args?: SelectSubset<T, DispatchRuleDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DispatchRuleDetails and returns the data saved in the database.
     * @param {DispatchRuleDetailCreateManyAndReturnArgs} args - Arguments to create many DispatchRuleDetails.
     * @example
     * // Create many DispatchRuleDetails
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DispatchRuleDetails and only return the `id`
     * const dispatchRuleDetailWithIdOnly = await prisma.dispatchRuleDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispatchRuleDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, DispatchRuleDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DispatchRuleDetail.
     * @param {DispatchRuleDetailDeleteArgs} args - Arguments to delete one DispatchRuleDetail.
     * @example
     * // Delete one DispatchRuleDetail
     * const DispatchRuleDetail = await prisma.dispatchRuleDetail.delete({
     *   where: {
     *     // ... filter to delete one DispatchRuleDetail
     *   }
     * })
     * 
     */
    delete<T extends DispatchRuleDetailDeleteArgs>(args: SelectSubset<T, DispatchRuleDetailDeleteArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DispatchRuleDetail.
     * @param {DispatchRuleDetailUpdateArgs} args - Arguments to update one DispatchRuleDetail.
     * @example
     * // Update one DispatchRuleDetail
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispatchRuleDetailUpdateArgs>(args: SelectSubset<T, DispatchRuleDetailUpdateArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DispatchRuleDetails.
     * @param {DispatchRuleDetailDeleteManyArgs} args - Arguments to filter DispatchRuleDetails to delete.
     * @example
     * // Delete a few DispatchRuleDetails
     * const { count } = await prisma.dispatchRuleDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispatchRuleDetailDeleteManyArgs>(args?: SelectSubset<T, DispatchRuleDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatchRuleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DispatchRuleDetails
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispatchRuleDetailUpdateManyArgs>(args: SelectSubset<T, DispatchRuleDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatchRuleDetails and returns the data updated in the database.
     * @param {DispatchRuleDetailUpdateManyAndReturnArgs} args - Arguments to update many DispatchRuleDetails.
     * @example
     * // Update many DispatchRuleDetails
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DispatchRuleDetails and only return the `id`
     * const dispatchRuleDetailWithIdOnly = await prisma.dispatchRuleDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispatchRuleDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, DispatchRuleDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DispatchRuleDetail.
     * @param {DispatchRuleDetailUpsertArgs} args - Arguments to update or create a DispatchRuleDetail.
     * @example
     * // Update or create a DispatchRuleDetail
     * const dispatchRuleDetail = await prisma.dispatchRuleDetail.upsert({
     *   create: {
     *     // ... data to create a DispatchRuleDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DispatchRuleDetail we want to update
     *   }
     * })
     */
    upsert<T extends DispatchRuleDetailUpsertArgs>(args: SelectSubset<T, DispatchRuleDetailUpsertArgs<ExtArgs>>): Prisma__DispatchRuleDetailClient<$Result.GetResult<Prisma.$DispatchRuleDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DispatchRuleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleDetailCountArgs} args - Arguments to filter DispatchRuleDetails to count.
     * @example
     * // Count the number of DispatchRuleDetails
     * const count = await prisma.dispatchRuleDetail.count({
     *   where: {
     *     // ... the filter for the DispatchRuleDetails we want to count
     *   }
     * })
    **/
    count<T extends DispatchRuleDetailCountArgs>(
      args?: Subset<T, DispatchRuleDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispatchRuleDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DispatchRuleDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispatchRuleDetailAggregateArgs>(args: Subset<T, DispatchRuleDetailAggregateArgs>): Prisma.PrismaPromise<GetDispatchRuleDetailAggregateType<T>>

    /**
     * Group by DispatchRuleDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchRuleDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispatchRuleDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispatchRuleDetailGroupByArgs['orderBy'] }
        : { orderBy?: DispatchRuleDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispatchRuleDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispatchRuleDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DispatchRuleDetail model
   */
  readonly fields: DispatchRuleDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DispatchRuleDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispatchRuleDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dispatch_rule<T extends DispatchRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DispatchRuleDefaultArgs<ExtArgs>>): Prisma__DispatchRuleClient<$Result.GetResult<Prisma.$DispatchRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destination_category<T extends FinancialCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinancialCategoryDefaultArgs<ExtArgs>>): Prisma__FinancialCategoryClient<$Result.GetResult<Prisma.$FinancialCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DispatchRuleDetail model
   */
  interface DispatchRuleDetailFieldRefs {
    readonly id: FieldRef<"DispatchRuleDetail", 'Int'>
    readonly dispatch_rule_id: FieldRef<"DispatchRuleDetail", 'Int'>
    readonly destination_category_id: FieldRef<"DispatchRuleDetail", 'Int'>
    readonly percentage: FieldRef<"DispatchRuleDetail", 'Float'>
    readonly supabase_id: FieldRef<"DispatchRuleDetail", 'String'>
    readonly last_modified: FieldRef<"DispatchRuleDetail", 'DateTime'>
    readonly needs_sync: FieldRef<"DispatchRuleDetail", 'Boolean'>
    readonly is_deleted: FieldRef<"DispatchRuleDetail", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DispatchRuleDetail findUnique
   */
  export type DispatchRuleDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRuleDetail to fetch.
     */
    where: DispatchRuleDetailWhereUniqueInput
  }

  /**
   * DispatchRuleDetail findUniqueOrThrow
   */
  export type DispatchRuleDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRuleDetail to fetch.
     */
    where: DispatchRuleDetailWhereUniqueInput
  }

  /**
   * DispatchRuleDetail findFirst
   */
  export type DispatchRuleDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRuleDetail to fetch.
     */
    where?: DispatchRuleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRuleDetails to fetch.
     */
    orderBy?: DispatchRuleDetailOrderByWithRelationInput | DispatchRuleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatchRuleDetails.
     */
    cursor?: DispatchRuleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRuleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRuleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatchRuleDetails.
     */
    distinct?: DispatchRuleDetailScalarFieldEnum | DispatchRuleDetailScalarFieldEnum[]
  }

  /**
   * DispatchRuleDetail findFirstOrThrow
   */
  export type DispatchRuleDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRuleDetail to fetch.
     */
    where?: DispatchRuleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRuleDetails to fetch.
     */
    orderBy?: DispatchRuleDetailOrderByWithRelationInput | DispatchRuleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatchRuleDetails.
     */
    cursor?: DispatchRuleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRuleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRuleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatchRuleDetails.
     */
    distinct?: DispatchRuleDetailScalarFieldEnum | DispatchRuleDetailScalarFieldEnum[]
  }

  /**
   * DispatchRuleDetail findMany
   */
  export type DispatchRuleDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * Filter, which DispatchRuleDetails to fetch.
     */
    where?: DispatchRuleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchRuleDetails to fetch.
     */
    orderBy?: DispatchRuleDetailOrderByWithRelationInput | DispatchRuleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DispatchRuleDetails.
     */
    cursor?: DispatchRuleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchRuleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchRuleDetails.
     */
    skip?: number
    distinct?: DispatchRuleDetailScalarFieldEnum | DispatchRuleDetailScalarFieldEnum[]
  }

  /**
   * DispatchRuleDetail create
   */
  export type DispatchRuleDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a DispatchRuleDetail.
     */
    data: XOR<DispatchRuleDetailCreateInput, DispatchRuleDetailUncheckedCreateInput>
  }

  /**
   * DispatchRuleDetail createMany
   */
  export type DispatchRuleDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DispatchRuleDetails.
     */
    data: DispatchRuleDetailCreateManyInput | DispatchRuleDetailCreateManyInput[]
  }

  /**
   * DispatchRuleDetail createManyAndReturn
   */
  export type DispatchRuleDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * The data used to create many DispatchRuleDetails.
     */
    data: DispatchRuleDetailCreateManyInput | DispatchRuleDetailCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatchRuleDetail update
   */
  export type DispatchRuleDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a DispatchRuleDetail.
     */
    data: XOR<DispatchRuleDetailUpdateInput, DispatchRuleDetailUncheckedUpdateInput>
    /**
     * Choose, which DispatchRuleDetail to update.
     */
    where: DispatchRuleDetailWhereUniqueInput
  }

  /**
   * DispatchRuleDetail updateMany
   */
  export type DispatchRuleDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DispatchRuleDetails.
     */
    data: XOR<DispatchRuleDetailUpdateManyMutationInput, DispatchRuleDetailUncheckedUpdateManyInput>
    /**
     * Filter which DispatchRuleDetails to update
     */
    where?: DispatchRuleDetailWhereInput
    /**
     * Limit how many DispatchRuleDetails to update.
     */
    limit?: number
  }

  /**
   * DispatchRuleDetail updateManyAndReturn
   */
  export type DispatchRuleDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * The data used to update DispatchRuleDetails.
     */
    data: XOR<DispatchRuleDetailUpdateManyMutationInput, DispatchRuleDetailUncheckedUpdateManyInput>
    /**
     * Filter which DispatchRuleDetails to update
     */
    where?: DispatchRuleDetailWhereInput
    /**
     * Limit how many DispatchRuleDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatchRuleDetail upsert
   */
  export type DispatchRuleDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the DispatchRuleDetail to update in case it exists.
     */
    where: DispatchRuleDetailWhereUniqueInput
    /**
     * In case the DispatchRuleDetail found by the `where` argument doesn't exist, create a new DispatchRuleDetail with this data.
     */
    create: XOR<DispatchRuleDetailCreateInput, DispatchRuleDetailUncheckedCreateInput>
    /**
     * In case the DispatchRuleDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispatchRuleDetailUpdateInput, DispatchRuleDetailUncheckedUpdateInput>
  }

  /**
   * DispatchRuleDetail delete
   */
  export type DispatchRuleDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
    /**
     * Filter which DispatchRuleDetail to delete.
     */
    where: DispatchRuleDetailWhereUniqueInput
  }

  /**
   * DispatchRuleDetail deleteMany
   */
  export type DispatchRuleDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatchRuleDetails to delete
     */
    where?: DispatchRuleDetailWhereInput
    /**
     * Limit how many DispatchRuleDetails to delete.
     */
    limit?: number
  }

  /**
   * DispatchRuleDetail without action
   */
  export type DispatchRuleDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchRuleDetail
     */
    select?: DispatchRuleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchRuleDetail
     */
    omit?: DispatchRuleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchRuleDetailInclude<ExtArgs> | null
  }


  /**
   * Model Events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: number | null
  }

  export type EventsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    location: string | null
    image_url: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EventsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    location: string | null
    image_url: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    location: number
    image_url: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
  }

  export type EventsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    location?: true
    image_url?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    location?: true
    image_url?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    location?: true
    image_url?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to aggregate.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithAggregationInput | EventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: number
    title: string
    description: string | null
    date: Date
    location: string | null
    image_url: string | null
    school_id: string
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    location?: boolean
    image_url?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["events"]>

  export type EventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    location?: boolean
    image_url?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["events"]>

  export type EventsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    location?: boolean
    image_url?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["events"]>

  export type EventsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    location?: boolean
    image_url?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EventsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "date" | "location" | "image_url" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["events"]>

  export type $EventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Events"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      date: Date
      location: string | null
      image_url: string | null
      school_id: string
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type EventsGetPayload<S extends boolean | null | undefined | EventsDefaultArgs> = $Result.GetResult<Prisma.$EventsPayload, S>

  type EventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface EventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Events'], meta: { name: 'Events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventsFindUniqueArgs>(args: SelectSubset<T, EventsFindUniqueArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventsFindFirstArgs>(args?: SelectSubset<T, EventsFindFirstArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventsFindManyArgs>(args?: SelectSubset<T, EventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends EventsCreateArgs>(args: SelectSubset<T, EventsCreateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventsCreateManyArgs>(args?: SelectSubset<T, EventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventsCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventsCreateManyAndReturnArgs>(args?: SelectSubset<T, EventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends EventsDeleteArgs>(args: SelectSubset<T, EventsDeleteArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventsUpdateArgs>(args: SelectSubset<T, EventsUpdateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventsDeleteManyArgs>(args?: SelectSubset<T, EventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventsUpdateManyArgs>(args: SelectSubset<T, EventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventsUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventsUpdateManyAndReturnArgs>(args: SelectSubset<T, EventsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends EventsUpsertArgs>(args: SelectSubset<T, EventsUpsertArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Events model
   */
  readonly fields: EventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Events model
   */
  interface EventsFieldRefs {
    readonly id: FieldRef<"Events", 'Int'>
    readonly title: FieldRef<"Events", 'String'>
    readonly description: FieldRef<"Events", 'String'>
    readonly date: FieldRef<"Events", 'DateTime'>
    readonly location: FieldRef<"Events", 'String'>
    readonly image_url: FieldRef<"Events", 'String'>
    readonly school_id: FieldRef<"Events", 'String'>
    readonly supabase_id: FieldRef<"Events", 'String'>
    readonly last_modified: FieldRef<"Events", 'DateTime'>
    readonly needs_sync: FieldRef<"Events", 'Boolean'>
    readonly is_deleted: FieldRef<"Events", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Events findUnique
   */
  export type EventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findUniqueOrThrow
   */
  export type EventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findFirst
   */
  export type EventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findFirstOrThrow
   */
  export type EventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findMany
   */
  export type EventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events create
   */
  export type EventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data needed to create a Events.
     */
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
  }

  /**
   * Events createMany
   */
  export type EventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
  }

  /**
   * Events createManyAndReturn
   */
  export type EventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
  }

  /**
   * Events update
   */
  export type EventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data needed to update a Events.
     */
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Events updateManyAndReturn
   */
  export type EventsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Events upsert
   */
  export type EventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The filter to search for the Events to update in case it exists.
     */
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     */
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
  }

  /**
   * Events delete
   */
  export type EventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter which Events to delete.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Events without action
   */
  export type EventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
  }


  /**
   * Model EmployeeAttendance
   */

  export type AggregateEmployeeAttendance = {
    _count: EmployeeAttendanceCountAggregateOutputType | null
    _avg: EmployeeAttendanceAvgAggregateOutputType | null
    _sum: EmployeeAttendanceSumAggregateOutputType | null
    _min: EmployeeAttendanceMinAggregateOutputType | null
    _max: EmployeeAttendanceMaxAggregateOutputType | null
  }

  export type EmployeeAttendanceAvgAggregateOutputType = {
    id: number | null
    employee_id: number | null
    teacher_id: number | null
  }

  export type EmployeeAttendanceSumAggregateOutputType = {
    id: number | null
    employee_id: number | null
    teacher_id: number | null
  }

  export type EmployeeAttendanceMinAggregateOutputType = {
    id: number | null
    employee_id: number | null
    teacher_id: number | null
    check_in: Date | null
    check_out: Date | null
    notes: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EmployeeAttendanceMaxAggregateOutputType = {
    id: number | null
    employee_id: number | null
    teacher_id: number | null
    check_in: Date | null
    check_out: Date | null
    notes: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EmployeeAttendanceCountAggregateOutputType = {
    id: number
    employee_id: number
    teacher_id: number
    check_in: number
    check_out: number
    notes: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type EmployeeAttendanceAvgAggregateInputType = {
    id?: true
    employee_id?: true
    teacher_id?: true
  }

  export type EmployeeAttendanceSumAggregateInputType = {
    id?: true
    employee_id?: true
    teacher_id?: true
  }

  export type EmployeeAttendanceMinAggregateInputType = {
    id?: true
    employee_id?: true
    teacher_id?: true
    check_in?: true
    check_out?: true
    notes?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EmployeeAttendanceMaxAggregateInputType = {
    id?: true
    employee_id?: true
    teacher_id?: true
    check_in?: true
    check_out?: true
    notes?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EmployeeAttendanceCountAggregateInputType = {
    id?: true
    employee_id?: true
    teacher_id?: true
    check_in?: true
    check_out?: true
    notes?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type EmployeeAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAttendance to aggregate.
     */
    where?: EmployeeAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttendances to fetch.
     */
    orderBy?: EmployeeAttendanceOrderByWithRelationInput | EmployeeAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeAttendances
    **/
    _count?: true | EmployeeAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeAttendanceMaxAggregateInputType
  }

  export type GetEmployeeAttendanceAggregateType<T extends EmployeeAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeAttendance[P]>
      : GetScalarType<T[P], AggregateEmployeeAttendance[P]>
  }




  export type EmployeeAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAttendanceWhereInput
    orderBy?: EmployeeAttendanceOrderByWithAggregationInput | EmployeeAttendanceOrderByWithAggregationInput[]
    by: EmployeeAttendanceScalarFieldEnum[] | EmployeeAttendanceScalarFieldEnum
    having?: EmployeeAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeAttendanceCountAggregateInputType | true
    _avg?: EmployeeAttendanceAvgAggregateInputType
    _sum?: EmployeeAttendanceSumAggregateInputType
    _min?: EmployeeAttendanceMinAggregateInputType
    _max?: EmployeeAttendanceMaxAggregateInputType
  }

  export type EmployeeAttendanceGroupByOutputType = {
    id: number
    employee_id: number | null
    teacher_id: number | null
    check_in: Date
    check_out: Date | null
    notes: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: EmployeeAttendanceCountAggregateOutputType | null
    _avg: EmployeeAttendanceAvgAggregateOutputType | null
    _sum: EmployeeAttendanceSumAggregateOutputType | null
    _min: EmployeeAttendanceMinAggregateOutputType | null
    _max: EmployeeAttendanceMaxAggregateOutputType | null
  }

  type GetEmployeeAttendanceGroupByPayload<T extends EmployeeAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    teacher_id?: boolean
    check_in?: boolean
    check_out?: boolean
    notes?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeeAttendance$employeeArgs<ExtArgs>
    teacher?: boolean | EmployeeAttendance$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAttendance"]>

  export type EmployeeAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    teacher_id?: boolean
    check_in?: boolean
    check_out?: boolean
    notes?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeeAttendance$employeeArgs<ExtArgs>
    teacher?: boolean | EmployeeAttendance$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAttendance"]>

  export type EmployeeAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    teacher_id?: boolean
    check_in?: boolean
    check_out?: boolean
    notes?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeeAttendance$employeeArgs<ExtArgs>
    teacher?: boolean | EmployeeAttendance$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAttendance"]>

  export type EmployeeAttendanceSelectScalar = {
    id?: boolean
    employee_id?: boolean
    teacher_id?: boolean
    check_in?: boolean
    check_out?: boolean
    notes?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeeAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "teacher_id" | "check_in" | "check_out" | "notes" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["employeeAttendance"]>
  export type EmployeeAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeAttendance$employeeArgs<ExtArgs>
    teacher?: boolean | EmployeeAttendance$teacherArgs<ExtArgs>
  }
  export type EmployeeAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeAttendance$employeeArgs<ExtArgs>
    teacher?: boolean | EmployeeAttendance$teacherArgs<ExtArgs>
  }
  export type EmployeeAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeAttendance$employeeArgs<ExtArgs>
    teacher?: boolean | EmployeeAttendance$teacherArgs<ExtArgs>
  }

  export type $EmployeeAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeAttendance"
    objects: {
      employee: Prisma.$EmployeesPayload<ExtArgs> | null
      teacher: Prisma.$TeachersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employee_id: number | null
      teacher_id: number | null
      check_in: Date
      check_out: Date | null
      notes: string | null
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["employeeAttendance"]>
    composites: {}
  }

  type EmployeeAttendanceGetPayload<S extends boolean | null | undefined | EmployeeAttendanceDefaultArgs> = $Result.GetResult<Prisma.$EmployeeAttendancePayload, S>

  type EmployeeAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeAttendanceCountAggregateInputType | true
    }

  export interface EmployeeAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeAttendance'], meta: { name: 'EmployeeAttendance' } }
    /**
     * Find zero or one EmployeeAttendance that matches the filter.
     * @param {EmployeeAttendanceFindUniqueArgs} args - Arguments to find a EmployeeAttendance
     * @example
     * // Get one EmployeeAttendance
     * const employeeAttendance = await prisma.employeeAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeAttendanceFindUniqueArgs>(args: SelectSubset<T, EmployeeAttendanceFindUniqueArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeAttendanceFindUniqueOrThrowArgs} args - Arguments to find a EmployeeAttendance
     * @example
     * // Get one EmployeeAttendance
     * const employeeAttendance = await prisma.employeeAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttendanceFindFirstArgs} args - Arguments to find a EmployeeAttendance
     * @example
     * // Get one EmployeeAttendance
     * const employeeAttendance = await prisma.employeeAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeAttendanceFindFirstArgs>(args?: SelectSubset<T, EmployeeAttendanceFindFirstArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttendanceFindFirstOrThrowArgs} args - Arguments to find a EmployeeAttendance
     * @example
     * // Get one EmployeeAttendance
     * const employeeAttendance = await prisma.employeeAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeAttendances
     * const employeeAttendances = await prisma.employeeAttendance.findMany()
     * 
     * // Get first 10 EmployeeAttendances
     * const employeeAttendances = await prisma.employeeAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeAttendanceWithIdOnly = await prisma.employeeAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeAttendanceFindManyArgs>(args?: SelectSubset<T, EmployeeAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeAttendance.
     * @param {EmployeeAttendanceCreateArgs} args - Arguments to create a EmployeeAttendance.
     * @example
     * // Create one EmployeeAttendance
     * const EmployeeAttendance = await prisma.employeeAttendance.create({
     *   data: {
     *     // ... data to create a EmployeeAttendance
     *   }
     * })
     * 
     */
    create<T extends EmployeeAttendanceCreateArgs>(args: SelectSubset<T, EmployeeAttendanceCreateArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeAttendances.
     * @param {EmployeeAttendanceCreateManyArgs} args - Arguments to create many EmployeeAttendances.
     * @example
     * // Create many EmployeeAttendances
     * const employeeAttendance = await prisma.employeeAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeAttendanceCreateManyArgs>(args?: SelectSubset<T, EmployeeAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeAttendances and returns the data saved in the database.
     * @param {EmployeeAttendanceCreateManyAndReturnArgs} args - Arguments to create many EmployeeAttendances.
     * @example
     * // Create many EmployeeAttendances
     * const employeeAttendance = await prisma.employeeAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeAttendances and only return the `id`
     * const employeeAttendanceWithIdOnly = await prisma.employeeAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeAttendance.
     * @param {EmployeeAttendanceDeleteArgs} args - Arguments to delete one EmployeeAttendance.
     * @example
     * // Delete one EmployeeAttendance
     * const EmployeeAttendance = await prisma.employeeAttendance.delete({
     *   where: {
     *     // ... filter to delete one EmployeeAttendance
     *   }
     * })
     * 
     */
    delete<T extends EmployeeAttendanceDeleteArgs>(args: SelectSubset<T, EmployeeAttendanceDeleteArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeAttendance.
     * @param {EmployeeAttendanceUpdateArgs} args - Arguments to update one EmployeeAttendance.
     * @example
     * // Update one EmployeeAttendance
     * const employeeAttendance = await prisma.employeeAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeAttendanceUpdateArgs>(args: SelectSubset<T, EmployeeAttendanceUpdateArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeAttendances.
     * @param {EmployeeAttendanceDeleteManyArgs} args - Arguments to filter EmployeeAttendances to delete.
     * @example
     * // Delete a few EmployeeAttendances
     * const { count } = await prisma.employeeAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeAttendanceDeleteManyArgs>(args?: SelectSubset<T, EmployeeAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeAttendances
     * const employeeAttendance = await prisma.employeeAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeAttendanceUpdateManyArgs>(args: SelectSubset<T, EmployeeAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAttendances and returns the data updated in the database.
     * @param {EmployeeAttendanceUpdateManyAndReturnArgs} args - Arguments to update many EmployeeAttendances.
     * @example
     * // Update many EmployeeAttendances
     * const employeeAttendance = await prisma.employeeAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeAttendances and only return the `id`
     * const employeeAttendanceWithIdOnly = await prisma.employeeAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeAttendance.
     * @param {EmployeeAttendanceUpsertArgs} args - Arguments to update or create a EmployeeAttendance.
     * @example
     * // Update or create a EmployeeAttendance
     * const employeeAttendance = await prisma.employeeAttendance.upsert({
     *   create: {
     *     // ... data to create a EmployeeAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeAttendance we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeAttendanceUpsertArgs>(args: SelectSubset<T, EmployeeAttendanceUpsertArgs<ExtArgs>>): Prisma__EmployeeAttendanceClient<$Result.GetResult<Prisma.$EmployeeAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttendanceCountArgs} args - Arguments to filter EmployeeAttendances to count.
     * @example
     * // Count the number of EmployeeAttendances
     * const count = await prisma.employeeAttendance.count({
     *   where: {
     *     // ... the filter for the EmployeeAttendances we want to count
     *   }
     * })
    **/
    count<T extends EmployeeAttendanceCountArgs>(
      args?: Subset<T, EmployeeAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAttendanceAggregateArgs>(args: Subset<T, EmployeeAttendanceAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAttendanceAggregateType<T>>

    /**
     * Group by EmployeeAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeAttendance model
   */
  readonly fields: EmployeeAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeAttendance$employeeArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeAttendance$employeeArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends EmployeeAttendance$teacherArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeAttendance$teacherArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeAttendance model
   */
  interface EmployeeAttendanceFieldRefs {
    readonly id: FieldRef<"EmployeeAttendance", 'Int'>
    readonly employee_id: FieldRef<"EmployeeAttendance", 'Int'>
    readonly teacher_id: FieldRef<"EmployeeAttendance", 'Int'>
    readonly check_in: FieldRef<"EmployeeAttendance", 'DateTime'>
    readonly check_out: FieldRef<"EmployeeAttendance", 'DateTime'>
    readonly notes: FieldRef<"EmployeeAttendance", 'String'>
    readonly school_id: FieldRef<"EmployeeAttendance", 'String'>
    readonly supabase_id: FieldRef<"EmployeeAttendance", 'String'>
    readonly last_modified: FieldRef<"EmployeeAttendance", 'DateTime'>
    readonly needs_sync: FieldRef<"EmployeeAttendance", 'Boolean'>
    readonly is_deleted: FieldRef<"EmployeeAttendance", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeAttendance findUnique
   */
  export type EmployeeAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttendance to fetch.
     */
    where: EmployeeAttendanceWhereUniqueInput
  }

  /**
   * EmployeeAttendance findUniqueOrThrow
   */
  export type EmployeeAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttendance to fetch.
     */
    where: EmployeeAttendanceWhereUniqueInput
  }

  /**
   * EmployeeAttendance findFirst
   */
  export type EmployeeAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttendance to fetch.
     */
    where?: EmployeeAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttendances to fetch.
     */
    orderBy?: EmployeeAttendanceOrderByWithRelationInput | EmployeeAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAttendances.
     */
    cursor?: EmployeeAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAttendances.
     */
    distinct?: EmployeeAttendanceScalarFieldEnum | EmployeeAttendanceScalarFieldEnum[]
  }

  /**
   * EmployeeAttendance findFirstOrThrow
   */
  export type EmployeeAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttendance to fetch.
     */
    where?: EmployeeAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttendances to fetch.
     */
    orderBy?: EmployeeAttendanceOrderByWithRelationInput | EmployeeAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAttendances.
     */
    cursor?: EmployeeAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAttendances.
     */
    distinct?: EmployeeAttendanceScalarFieldEnum | EmployeeAttendanceScalarFieldEnum[]
  }

  /**
   * EmployeeAttendance findMany
   */
  export type EmployeeAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttendances to fetch.
     */
    where?: EmployeeAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttendances to fetch.
     */
    orderBy?: EmployeeAttendanceOrderByWithRelationInput | EmployeeAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeAttendances.
     */
    cursor?: EmployeeAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttendances.
     */
    skip?: number
    distinct?: EmployeeAttendanceScalarFieldEnum | EmployeeAttendanceScalarFieldEnum[]
  }

  /**
   * EmployeeAttendance create
   */
  export type EmployeeAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeAttendance.
     */
    data: XOR<EmployeeAttendanceCreateInput, EmployeeAttendanceUncheckedCreateInput>
  }

  /**
   * EmployeeAttendance createMany
   */
  export type EmployeeAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeAttendances.
     */
    data: EmployeeAttendanceCreateManyInput | EmployeeAttendanceCreateManyInput[]
  }

  /**
   * EmployeeAttendance createManyAndReturn
   */
  export type EmployeeAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeAttendances.
     */
    data: EmployeeAttendanceCreateManyInput | EmployeeAttendanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAttendance update
   */
  export type EmployeeAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeAttendance.
     */
    data: XOR<EmployeeAttendanceUpdateInput, EmployeeAttendanceUncheckedUpdateInput>
    /**
     * Choose, which EmployeeAttendance to update.
     */
    where: EmployeeAttendanceWhereUniqueInput
  }

  /**
   * EmployeeAttendance updateMany
   */
  export type EmployeeAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeAttendances.
     */
    data: XOR<EmployeeAttendanceUpdateManyMutationInput, EmployeeAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAttendances to update
     */
    where?: EmployeeAttendanceWhereInput
    /**
     * Limit how many EmployeeAttendances to update.
     */
    limit?: number
  }

  /**
   * EmployeeAttendance updateManyAndReturn
   */
  export type EmployeeAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeAttendances.
     */
    data: XOR<EmployeeAttendanceUpdateManyMutationInput, EmployeeAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAttendances to update
     */
    where?: EmployeeAttendanceWhereInput
    /**
     * Limit how many EmployeeAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAttendance upsert
   */
  export type EmployeeAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeAttendance to update in case it exists.
     */
    where: EmployeeAttendanceWhereUniqueInput
    /**
     * In case the EmployeeAttendance found by the `where` argument doesn't exist, create a new EmployeeAttendance with this data.
     */
    create: XOR<EmployeeAttendanceCreateInput, EmployeeAttendanceUncheckedCreateInput>
    /**
     * In case the EmployeeAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeAttendanceUpdateInput, EmployeeAttendanceUncheckedUpdateInput>
  }

  /**
   * EmployeeAttendance delete
   */
  export type EmployeeAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
    /**
     * Filter which EmployeeAttendance to delete.
     */
    where: EmployeeAttendanceWhereUniqueInput
  }

  /**
   * EmployeeAttendance deleteMany
   */
  export type EmployeeAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAttendances to delete
     */
    where?: EmployeeAttendanceWhereInput
    /**
     * Limit how many EmployeeAttendances to delete.
     */
    limit?: number
  }

  /**
   * EmployeeAttendance.employee
   */
  export type EmployeeAttendance$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    where?: EmployeesWhereInput
  }

  /**
   * EmployeeAttendance.teacher
   */
  export type EmployeeAttendance$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    where?: TeachersWhereInput
  }

  /**
   * EmployeeAttendance without action
   */
  export type EmployeeAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttendance
     */
    select?: EmployeeAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttendance
     */
    omit?: EmployeeAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttendanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    schoolName: 'schoolName',
    schoolAddress: 'schoolAddress',
    loggedIn: 'loggedIn',
    userRole: 'userRole',
    schoolId: 'schoolId',
    userToken: 'userToken',
    last_sync: 'last_sync',
    activeSchoolYear: 'activeSchoolYear',
    roleId: 'roleId',
    permissions: 'permissions',
    schoolYearStartDate: 'schoolYearStartDate',
    directorName: 'directorName',
    directorGender: 'directorGender',
    schoolLogo: 'schoolLogo'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const ClassesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type ClassesScalarFieldEnum = (typeof ClassesScalarFieldEnum)[keyof typeof ClassesScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    genre: 'genre',
    birth_date: 'birth_date',
    picture_url: 'picture_url',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted',
    matricul: 'matricul'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const RegistrationsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    class_id: 'class_id',
    school_year: 'school_year',
    state: 'state',
    registration_date: 'registration_date',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type RegistrationsScalarFieldEnum = (typeof RegistrationsScalarFieldEnum)[keyof typeof RegistrationsScalarFieldEnum]


  export const TeachersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    phone: 'phone',
    email: 'email',
    adress: 'adress',
    password_hash: 'password_hash',
    role_id: 'role_id',
    speciality: 'speciality',
    matricule: 'matricule',
    supabase_id: 'supabase_id',
    user_supabase_id: 'user_supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted',
    hourlyRate: 'hourlyRate',
    school_id: 'school_id'
  };

  export type TeachersScalarFieldEnum = (typeof TeachersScalarFieldEnum)[keyof typeof TeachersScalarFieldEnum]


  export const TeacherWorkHoursScalarFieldEnum: {
    id: 'id',
    teacher_id: 'teacher_id',
    subject_id: 'subject_id',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    hours: 'hours',
    notes: 'notes',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type TeacherWorkHoursScalarFieldEnum = (typeof TeacherWorkHoursScalarFieldEnum)[keyof typeof TeacherWorkHoursScalarFieldEnum]


  export const LessonsScalarFieldEnum: {
    id: 'id',
    teacher_id: 'teacher_id',
    class_id: 'class_id',
    subject_id: 'subject_id',
    school_year: 'school_year',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type LessonsScalarFieldEnum = (typeof LessonsScalarFieldEnum)[keyof typeof LessonsScalarFieldEnum]


  export const SubjectsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    class_id: 'class_id',
    school_year: 'school_year',
    coefficient: 'coefficient',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type SubjectsScalarFieldEnum = (typeof SubjectsScalarFieldEnum)[keyof typeof SubjectsScalarFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    lesson_id: 'lesson_id',
    value: 'value',
    type: 'type',
    quarter: 'quarter',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const ParentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    phone: 'phone',
    email: 'email',
    adress: 'adress',
    gender: 'gender',
    profession: 'profession',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted',
    school_id: 'school_id'
  };

  export type ParentsScalarFieldEnum = (typeof ParentsScalarFieldEnum)[keyof typeof ParentsScalarFieldEnum]


  export const StudentParentsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    parent_id: 'parent_id',
    relation: 'relation',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type StudentParentsScalarFieldEnum = (typeof StudentParentsScalarFieldEnum)[keyof typeof StudentParentsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    registration_id: 'registration_id',
    amount: 'amount',
    method: 'method',
    date: 'date',
    reference: 'reference',
    emitter_id: 'emitter_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted',
    single_fee_id: 'single_fee_id',
    fee_template_id: 'fee_template_id',
    period_identifier: 'period_identifier'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const SingleFeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    amount: 'amount',
    due_date: 'due_date',
    school_year: 'school_year',
    level: 'level',
    class_id: 'class_id',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type SingleFeeScalarFieldEnum = (typeof SingleFeeScalarFieldEnum)[keyof typeof SingleFeeScalarFieldEnum]


  export const FeeTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    amount: 'amount',
    frequency: 'frequency',
    due_day: 'due_day',
    applicable_months: 'applicable_months',
    school_id: 'school_id',
    applies_to_level: 'applies_to_level',
    applies_to_class_id: 'applies_to_class_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type FeeTemplateScalarFieldEnum = (typeof FeeTemplateScalarFieldEnum)[keyof typeof FeeTemplateScalarFieldEnum]


  export const AttendancesScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    date: 'date',
    state: 'state',
    justification: 'justification',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type AttendancesScalarFieldEnum = (typeof AttendancesScalarFieldEnum)[keyof typeof AttendancesScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    phone: 'phone',
    email: 'email',
    adress: 'adress',
    gender: 'gender',
    job_title: 'job_title',
    salary: 'salary',
    matricule: 'matricule',
    school_id: 'school_id',
    password_hash: 'password_hash',
    supabase_id: 'supabase_id',
    user_supabase_id: 'user_supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const SalaryPaymentsScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    base_salary: 'base_salary',
    bonus_amount: 'bonus_amount',
    total_amount: 'total_amount',
    payment_date: 'payment_date',
    notes: 'notes',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type SalaryPaymentsScalarFieldEnum = (typeof SalaryPaymentsScalarFieldEnum)[keyof typeof SalaryPaymentsScalarFieldEnum]


  export const SchedulesScalarFieldEnum: {
    id: 'id',
    lesson_id: 'lesson_id',
    day_of_week: 'day_of_week',
    start_time: 'start_time',
    end_time: 'end_time',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type SchedulesScalarFieldEnum = (typeof SchedulesScalarFieldEnum)[keyof typeof SchedulesScalarFieldEnum]


  export const FinancialCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type FinancialCategoryScalarFieldEnum = (typeof FinancialCategoryScalarFieldEnum)[keyof typeof FinancialCategoryScalarFieldEnum]


  export const FinancialTransactionScalarFieldEnum: {
    id: 'id',
    date: 'date',
    description: 'description',
    amount: 'amount',
    type: 'type',
    category_id: 'category_id',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type FinancialTransactionScalarFieldEnum = (typeof FinancialTransactionScalarFieldEnum)[keyof typeof FinancialTransactionScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    category: 'category',
    amount: 'amount',
    period_start: 'period_start',
    period_end: 'period_end',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const FinancialReportScalarFieldEnum: {
    id: 'id',
    title: 'title',
    generated_at: 'generated_at',
    start_date: 'start_date',
    end_date: 'end_date',
    content: 'content',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type FinancialReportScalarFieldEnum = (typeof FinancialReportScalarFieldEnum)[keyof typeof FinancialReportScalarFieldEnum]


  export const DispatchRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    source_single_fee_id: 'source_single_fee_id',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type DispatchRuleScalarFieldEnum = (typeof DispatchRuleScalarFieldEnum)[keyof typeof DispatchRuleScalarFieldEnum]


  export const DispatchRuleDetailScalarFieldEnum: {
    id: 'id',
    dispatch_rule_id: 'dispatch_rule_id',
    destination_category_id: 'destination_category_id',
    percentage: 'percentage',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type DispatchRuleDetailScalarFieldEnum = (typeof DispatchRuleDetailScalarFieldEnum)[keyof typeof DispatchRuleDetailScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    location: 'location',
    image_url: 'image_url',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const EmployeeAttendanceScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    teacher_id: 'teacher_id',
    check_in: 'check_in',
    check_out: 'check_out',
    notes: 'notes',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type EmployeeAttendanceScalarFieldEnum = (typeof EmployeeAttendanceScalarFieldEnum)[keyof typeof EmployeeAttendanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: IntFilter<"Settings"> | number
    schoolName?: StringNullableFilter<"Settings"> | string | null
    schoolAddress?: StringNullableFilter<"Settings"> | string | null
    loggedIn?: IntNullableFilter<"Settings"> | number | null
    userRole?: StringNullableFilter<"Settings"> | string | null
    schoolId?: StringNullableFilter<"Settings"> | string | null
    userToken?: StringNullableFilter<"Settings"> | string | null
    last_sync?: DateTimeNullableFilter<"Settings"> | Date | string | null
    activeSchoolYear?: StringNullableFilter<"Settings"> | string | null
    roleId?: StringNullableFilter<"Settings"> | string | null
    permissions?: JsonNullableFilter<"Settings">
    schoolYearStartDate?: DateTimeNullableFilter<"Settings"> | Date | string | null
    directorName?: StringNullableFilter<"Settings"> | string | null
    directorGender?: StringNullableFilter<"Settings"> | string | null
    schoolLogo?: StringNullableFilter<"Settings"> | string | null
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    schoolName?: SortOrderInput | SortOrder
    schoolAddress?: SortOrderInput | SortOrder
    loggedIn?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    userToken?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    activeSchoolYear?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    schoolYearStartDate?: SortOrderInput | SortOrder
    directorName?: SortOrderInput | SortOrder
    directorGender?: SortOrderInput | SortOrder
    schoolLogo?: SortOrderInput | SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    schoolName?: StringNullableFilter<"Settings"> | string | null
    schoolAddress?: StringNullableFilter<"Settings"> | string | null
    loggedIn?: IntNullableFilter<"Settings"> | number | null
    userRole?: StringNullableFilter<"Settings"> | string | null
    schoolId?: StringNullableFilter<"Settings"> | string | null
    userToken?: StringNullableFilter<"Settings"> | string | null
    last_sync?: DateTimeNullableFilter<"Settings"> | Date | string | null
    activeSchoolYear?: StringNullableFilter<"Settings"> | string | null
    roleId?: StringNullableFilter<"Settings"> | string | null
    permissions?: JsonNullableFilter<"Settings">
    schoolYearStartDate?: DateTimeNullableFilter<"Settings"> | Date | string | null
    directorName?: StringNullableFilter<"Settings"> | string | null
    directorGender?: StringNullableFilter<"Settings"> | string | null
    schoolLogo?: StringNullableFilter<"Settings"> | string | null
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolName?: SortOrderInput | SortOrder
    schoolAddress?: SortOrderInput | SortOrder
    loggedIn?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    userToken?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    activeSchoolYear?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    schoolYearStartDate?: SortOrderInput | SortOrder
    directorName?: SortOrderInput | SortOrder
    directorGender?: SortOrderInput | SortOrder
    schoolLogo?: SortOrderInput | SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settings"> | number
    schoolName?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    schoolAddress?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    loggedIn?: IntNullableWithAggregatesFilter<"Settings"> | number | null
    userRole?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    schoolId?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    userToken?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    last_sync?: DateTimeNullableWithAggregatesFilter<"Settings"> | Date | string | null
    activeSchoolYear?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    roleId?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    permissions?: JsonNullableWithAggregatesFilter<"Settings">
    schoolYearStartDate?: DateTimeNullableWithAggregatesFilter<"Settings"> | Date | string | null
    directorName?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    directorGender?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    schoolLogo?: StringNullableWithAggregatesFilter<"Settings"> | string | null
  }

  export type ClassesWhereInput = {
    AND?: ClassesWhereInput | ClassesWhereInput[]
    OR?: ClassesWhereInput[]
    NOT?: ClassesWhereInput | ClassesWhereInput[]
    id?: IntFilter<"Classes"> | number
    name?: StringFilter<"Classes"> | string
    level?: StringNullableFilter<"Classes"> | string | null
    school_id?: StringNullableFilter<"Classes"> | string | null
    supabase_id?: StringNullableFilter<"Classes"> | string | null
    last_modified?: DateTimeFilter<"Classes"> | Date | string
    needs_sync?: BoolFilter<"Classes"> | boolean
    is_deleted?: BoolFilter<"Classes"> | boolean
    lessons?: LessonsListRelationFilter
    registrations?: RegistrationsListRelationFilter
    subjects?: SubjectsListRelationFilter
    single_fees?: SingleFeeListRelationFilter
    fee_templates?: FeeTemplateListRelationFilter
  }

  export type ClassesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lessons?: LessonsOrderByRelationAggregateInput
    registrations?: RegistrationsOrderByRelationAggregateInput
    subjects?: SubjectsOrderByRelationAggregateInput
    single_fees?: SingleFeeOrderByRelationAggregateInput
    fee_templates?: FeeTemplateOrderByRelationAggregateInput
  }

  export type ClassesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: ClassesWhereInput | ClassesWhereInput[]
    OR?: ClassesWhereInput[]
    NOT?: ClassesWhereInput | ClassesWhereInput[]
    name?: StringFilter<"Classes"> | string
    level?: StringNullableFilter<"Classes"> | string | null
    school_id?: StringNullableFilter<"Classes"> | string | null
    last_modified?: DateTimeFilter<"Classes"> | Date | string
    needs_sync?: BoolFilter<"Classes"> | boolean
    is_deleted?: BoolFilter<"Classes"> | boolean
    lessons?: LessonsListRelationFilter
    registrations?: RegistrationsListRelationFilter
    subjects?: SubjectsListRelationFilter
    single_fees?: SingleFeeListRelationFilter
    fee_templates?: FeeTemplateListRelationFilter
  }, "id" | "supabase_id">

  export type ClassesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: ClassesCountOrderByAggregateInput
    _avg?: ClassesAvgOrderByAggregateInput
    _max?: ClassesMaxOrderByAggregateInput
    _min?: ClassesMinOrderByAggregateInput
    _sum?: ClassesSumOrderByAggregateInput
  }

  export type ClassesScalarWhereWithAggregatesInput = {
    AND?: ClassesScalarWhereWithAggregatesInput | ClassesScalarWhereWithAggregatesInput[]
    OR?: ClassesScalarWhereWithAggregatesInput[]
    NOT?: ClassesScalarWhereWithAggregatesInput | ClassesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Classes"> | number
    name?: StringWithAggregatesFilter<"Classes"> | string
    level?: StringNullableWithAggregatesFilter<"Classes"> | string | null
    school_id?: StringNullableWithAggregatesFilter<"Classes"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Classes"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Classes"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Classes"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Classes"> | boolean
  }

  export type StudentsWhereInput = {
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    id?: IntFilter<"Students"> | number
    name?: StringNullableFilter<"Students"> | string | null
    first_name?: StringNullableFilter<"Students"> | string | null
    genre?: StringNullableFilter<"Students"> | string | null
    birth_date?: StringNullableFilter<"Students"> | string | null
    picture_url?: StringNullableFilter<"Students"> | string | null
    supabase_id?: StringNullableFilter<"Students"> | string | null
    last_modified?: DateTimeFilter<"Students"> | Date | string
    needs_sync?: BoolFilter<"Students"> | boolean
    is_deleted?: BoolFilter<"Students"> | boolean
    matricul?: StringNullableFilter<"Students"> | string | null
    attendances?: AttendancesListRelationFilter
    notes?: NotesListRelationFilter
    registrations?: RegistrationsListRelationFilter
    student_parents?: StudentParentsListRelationFilter
  }

  export type StudentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    picture_url?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrderInput | SortOrder
    attendances?: AttendancesOrderByRelationAggregateInput
    notes?: NotesOrderByRelationAggregateInput
    registrations?: RegistrationsOrderByRelationAggregateInput
    student_parents?: StudentParentsOrderByRelationAggregateInput
  }

  export type StudentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    matricul?: string
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    name?: StringNullableFilter<"Students"> | string | null
    first_name?: StringNullableFilter<"Students"> | string | null
    genre?: StringNullableFilter<"Students"> | string | null
    birth_date?: StringNullableFilter<"Students"> | string | null
    picture_url?: StringNullableFilter<"Students"> | string | null
    last_modified?: DateTimeFilter<"Students"> | Date | string
    needs_sync?: BoolFilter<"Students"> | boolean
    is_deleted?: BoolFilter<"Students"> | boolean
    attendances?: AttendancesListRelationFilter
    notes?: NotesListRelationFilter
    registrations?: RegistrationsListRelationFilter
    student_parents?: StudentParentsListRelationFilter
  }, "id" | "supabase_id" | "matricul">

  export type StudentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    picture_url?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrderInput | SortOrder
    _count?: StudentsCountOrderByAggregateInput
    _avg?: StudentsAvgOrderByAggregateInput
    _max?: StudentsMaxOrderByAggregateInput
    _min?: StudentsMinOrderByAggregateInput
    _sum?: StudentsSumOrderByAggregateInput
  }

  export type StudentsScalarWhereWithAggregatesInput = {
    AND?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    OR?: StudentsScalarWhereWithAggregatesInput[]
    NOT?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Students"> | number
    name?: StringNullableWithAggregatesFilter<"Students"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Students"> | string | null
    genre?: StringNullableWithAggregatesFilter<"Students"> | string | null
    birth_date?: StringNullableWithAggregatesFilter<"Students"> | string | null
    picture_url?: StringNullableWithAggregatesFilter<"Students"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Students"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Students"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Students"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Students"> | boolean
    matricul?: StringNullableWithAggregatesFilter<"Students"> | string | null
  }

  export type RegistrationsWhereInput = {
    AND?: RegistrationsWhereInput | RegistrationsWhereInput[]
    OR?: RegistrationsWhereInput[]
    NOT?: RegistrationsWhereInput | RegistrationsWhereInput[]
    id?: IntFilter<"Registrations"> | number
    student_id?: IntFilter<"Registrations"> | number
    class_id?: IntFilter<"Registrations"> | number
    school_year?: StringNullableFilter<"Registrations"> | string | null
    state?: StringNullableFilter<"Registrations"> | string | null
    registration_date?: StringNullableFilter<"Registrations"> | string | null
    supabase_id?: StringNullableFilter<"Registrations"> | string | null
    last_modified?: DateTimeFilter<"Registrations"> | Date | string
    needs_sync?: BoolFilter<"Registrations"> | boolean
    is_deleted?: BoolFilter<"Registrations"> | boolean
    payments?: PaymentsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type RegistrationsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    registration_date?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    payments?: PaymentsOrderByRelationAggregateInput
    class?: ClassesOrderByWithRelationInput
    student?: StudentsOrderByWithRelationInput
  }

  export type RegistrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: RegistrationsWhereInput | RegistrationsWhereInput[]
    OR?: RegistrationsWhereInput[]
    NOT?: RegistrationsWhereInput | RegistrationsWhereInput[]
    student_id?: IntFilter<"Registrations"> | number
    class_id?: IntFilter<"Registrations"> | number
    school_year?: StringNullableFilter<"Registrations"> | string | null
    state?: StringNullableFilter<"Registrations"> | string | null
    registration_date?: StringNullableFilter<"Registrations"> | string | null
    last_modified?: DateTimeFilter<"Registrations"> | Date | string
    needs_sync?: BoolFilter<"Registrations"> | boolean
    is_deleted?: BoolFilter<"Registrations"> | boolean
    payments?: PaymentsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id">

  export type RegistrationsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    registration_date?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: RegistrationsCountOrderByAggregateInput
    _avg?: RegistrationsAvgOrderByAggregateInput
    _max?: RegistrationsMaxOrderByAggregateInput
    _min?: RegistrationsMinOrderByAggregateInput
    _sum?: RegistrationsSumOrderByAggregateInput
  }

  export type RegistrationsScalarWhereWithAggregatesInput = {
    AND?: RegistrationsScalarWhereWithAggregatesInput | RegistrationsScalarWhereWithAggregatesInput[]
    OR?: RegistrationsScalarWhereWithAggregatesInput[]
    NOT?: RegistrationsScalarWhereWithAggregatesInput | RegistrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Registrations"> | number
    student_id?: IntWithAggregatesFilter<"Registrations"> | number
    class_id?: IntWithAggregatesFilter<"Registrations"> | number
    school_year?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    state?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    registration_date?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Registrations"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Registrations"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Registrations"> | boolean
  }

  export type TeachersWhereInput = {
    AND?: TeachersWhereInput | TeachersWhereInput[]
    OR?: TeachersWhereInput[]
    NOT?: TeachersWhereInput | TeachersWhereInput[]
    id?: IntFilter<"Teachers"> | number
    name?: StringNullableFilter<"Teachers"> | string | null
    first_name?: StringNullableFilter<"Teachers"> | string | null
    phone?: StringNullableFilter<"Teachers"> | string | null
    email?: StringNullableFilter<"Teachers"> | string | null
    adress?: StringNullableFilter<"Teachers"> | string | null
    password_hash?: StringNullableFilter<"Teachers"> | string | null
    role_id?: StringNullableFilter<"Teachers"> | string | null
    speciality?: StringNullableFilter<"Teachers"> | string | null
    matricule?: StringNullableFilter<"Teachers"> | string | null
    supabase_id?: StringNullableFilter<"Teachers"> | string | null
    user_supabase_id?: StringNullableFilter<"Teachers"> | string | null
    last_modified?: DateTimeFilter<"Teachers"> | Date | string
    needs_sync?: BoolFilter<"Teachers"> | boolean
    is_deleted?: BoolFilter<"Teachers"> | boolean
    hourlyRate?: FloatNullableFilter<"Teachers"> | number | null
    school_id?: StringNullableFilter<"Teachers"> | string | null
    lessons?: LessonsListRelationFilter
    workHours?: TeacherWorkHoursListRelationFilter
    attendances?: EmployeeAttendanceListRelationFilter
  }

  export type TeachersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    speciality?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    lessons?: LessonsOrderByRelationAggregateInput
    workHours?: TeacherWorkHoursOrderByRelationAggregateInput
    attendances?: EmployeeAttendanceOrderByRelationAggregateInput
  }

  export type TeachersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    supabase_id?: string
    AND?: TeachersWhereInput | TeachersWhereInput[]
    OR?: TeachersWhereInput[]
    NOT?: TeachersWhereInput | TeachersWhereInput[]
    name?: StringNullableFilter<"Teachers"> | string | null
    first_name?: StringNullableFilter<"Teachers"> | string | null
    phone?: StringNullableFilter<"Teachers"> | string | null
    adress?: StringNullableFilter<"Teachers"> | string | null
    password_hash?: StringNullableFilter<"Teachers"> | string | null
    role_id?: StringNullableFilter<"Teachers"> | string | null
    speciality?: StringNullableFilter<"Teachers"> | string | null
    matricule?: StringNullableFilter<"Teachers"> | string | null
    user_supabase_id?: StringNullableFilter<"Teachers"> | string | null
    last_modified?: DateTimeFilter<"Teachers"> | Date | string
    needs_sync?: BoolFilter<"Teachers"> | boolean
    is_deleted?: BoolFilter<"Teachers"> | boolean
    hourlyRate?: FloatNullableFilter<"Teachers"> | number | null
    school_id?: StringNullableFilter<"Teachers"> | string | null
    lessons?: LessonsListRelationFilter
    workHours?: TeacherWorkHoursListRelationFilter
    attendances?: EmployeeAttendanceListRelationFilter
  }, "id" | "email" | "supabase_id">

  export type TeachersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    speciality?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    _count?: TeachersCountOrderByAggregateInput
    _avg?: TeachersAvgOrderByAggregateInput
    _max?: TeachersMaxOrderByAggregateInput
    _min?: TeachersMinOrderByAggregateInput
    _sum?: TeachersSumOrderByAggregateInput
  }

  export type TeachersScalarWhereWithAggregatesInput = {
    AND?: TeachersScalarWhereWithAggregatesInput | TeachersScalarWhereWithAggregatesInput[]
    OR?: TeachersScalarWhereWithAggregatesInput[]
    NOT?: TeachersScalarWhereWithAggregatesInput | TeachersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Teachers"> | number
    name?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    email?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    adress?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    role_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    speciality?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    matricule?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    user_supabase_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Teachers"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Teachers"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Teachers"> | boolean
    hourlyRate?: FloatNullableWithAggregatesFilter<"Teachers"> | number | null
    school_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
  }

  export type TeacherWorkHoursWhereInput = {
    AND?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    OR?: TeacherWorkHoursWhereInput[]
    NOT?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    id?: IntFilter<"TeacherWorkHours"> | number
    teacher_id?: IntFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    hours?: FloatFilter<"TeacherWorkHours"> | number
    notes?: StringNullableFilter<"TeacherWorkHours"> | string | null
    supabase_id?: StringNullableFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolFilter<"TeacherWorkHours"> | boolean
    subject?: XOR<SubjectsNullableScalarRelationFilter, SubjectsWhereInput> | null
    teacher?: XOR<TeachersScalarRelationFilter, TeachersWhereInput>
  }

  export type TeacherWorkHoursOrderByWithRelationInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    hours?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    subject?: SubjectsOrderByWithRelationInput
    teacher?: TeachersOrderByWithRelationInput
  }

  export type TeacherWorkHoursWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    OR?: TeacherWorkHoursWhereInput[]
    NOT?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    teacher_id?: IntFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    hours?: FloatFilter<"TeacherWorkHours"> | number
    notes?: StringNullableFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolFilter<"TeacherWorkHours"> | boolean
    subject?: XOR<SubjectsNullableScalarRelationFilter, SubjectsWhereInput> | null
    teacher?: XOR<TeachersScalarRelationFilter, TeachersWhereInput>
  }, "id" | "supabase_id">

  export type TeacherWorkHoursOrderByWithAggregationInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    hours?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: TeacherWorkHoursCountOrderByAggregateInput
    _avg?: TeacherWorkHoursAvgOrderByAggregateInput
    _max?: TeacherWorkHoursMaxOrderByAggregateInput
    _min?: TeacherWorkHoursMinOrderByAggregateInput
    _sum?: TeacherWorkHoursSumOrderByAggregateInput
  }

  export type TeacherWorkHoursScalarWhereWithAggregatesInput = {
    AND?: TeacherWorkHoursScalarWhereWithAggregatesInput | TeacherWorkHoursScalarWhereWithAggregatesInput[]
    OR?: TeacherWorkHoursScalarWhereWithAggregatesInput[]
    NOT?: TeacherWorkHoursScalarWhereWithAggregatesInput | TeacherWorkHoursScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherWorkHours"> | number
    teacher_id?: IntWithAggregatesFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableWithAggregatesFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    hours?: FloatWithAggregatesFilter<"TeacherWorkHours"> | number
    notes?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"TeacherWorkHours"> | boolean
  }

  export type LessonsWhereInput = {
    AND?: LessonsWhereInput | LessonsWhereInput[]
    OR?: LessonsWhereInput[]
    NOT?: LessonsWhereInput | LessonsWhereInput[]
    id?: IntFilter<"Lessons"> | number
    teacher_id?: IntNullableFilter<"Lessons"> | number | null
    class_id?: IntFilter<"Lessons"> | number
    subject_id?: IntFilter<"Lessons"> | number
    school_year?: StringNullableFilter<"Lessons"> | string | null
    supabase_id?: StringNullableFilter<"Lessons"> | string | null
    last_modified?: DateTimeFilter<"Lessons"> | Date | string
    needs_sync?: BoolFilter<"Lessons"> | boolean
    is_deleted?: BoolFilter<"Lessons"> | boolean
    subject?: XOR<SubjectsScalarRelationFilter, SubjectsWhereInput>
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    teacher?: XOR<TeachersNullableScalarRelationFilter, TeachersWhereInput> | null
    notes?: NotesListRelationFilter
    schedules?: SchedulesListRelationFilter
  }

  export type LessonsOrderByWithRelationInput = {
    id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    subject?: SubjectsOrderByWithRelationInput
    class?: ClassesOrderByWithRelationInput
    teacher?: TeachersOrderByWithRelationInput
    notes?: NotesOrderByRelationAggregateInput
    schedules?: SchedulesOrderByRelationAggregateInput
  }

  export type LessonsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: LessonsWhereInput | LessonsWhereInput[]
    OR?: LessonsWhereInput[]
    NOT?: LessonsWhereInput | LessonsWhereInput[]
    teacher_id?: IntNullableFilter<"Lessons"> | number | null
    class_id?: IntFilter<"Lessons"> | number
    subject_id?: IntFilter<"Lessons"> | number
    school_year?: StringNullableFilter<"Lessons"> | string | null
    last_modified?: DateTimeFilter<"Lessons"> | Date | string
    needs_sync?: BoolFilter<"Lessons"> | boolean
    is_deleted?: BoolFilter<"Lessons"> | boolean
    subject?: XOR<SubjectsScalarRelationFilter, SubjectsWhereInput>
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    teacher?: XOR<TeachersNullableScalarRelationFilter, TeachersWhereInput> | null
    notes?: NotesListRelationFilter
    schedules?: SchedulesListRelationFilter
  }, "id" | "supabase_id">

  export type LessonsOrderByWithAggregationInput = {
    id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: LessonsCountOrderByAggregateInput
    _avg?: LessonsAvgOrderByAggregateInput
    _max?: LessonsMaxOrderByAggregateInput
    _min?: LessonsMinOrderByAggregateInput
    _sum?: LessonsSumOrderByAggregateInput
  }

  export type LessonsScalarWhereWithAggregatesInput = {
    AND?: LessonsScalarWhereWithAggregatesInput | LessonsScalarWhereWithAggregatesInput[]
    OR?: LessonsScalarWhereWithAggregatesInput[]
    NOT?: LessonsScalarWhereWithAggregatesInput | LessonsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lessons"> | number
    teacher_id?: IntNullableWithAggregatesFilter<"Lessons"> | number | null
    class_id?: IntWithAggregatesFilter<"Lessons"> | number
    subject_id?: IntWithAggregatesFilter<"Lessons"> | number
    school_year?: StringNullableWithAggregatesFilter<"Lessons"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Lessons"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Lessons"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Lessons"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Lessons"> | boolean
  }

  export type SubjectsWhereInput = {
    AND?: SubjectsWhereInput | SubjectsWhereInput[]
    OR?: SubjectsWhereInput[]
    NOT?: SubjectsWhereInput | SubjectsWhereInput[]
    id?: IntFilter<"Subjects"> | number
    name?: StringFilter<"Subjects"> | string
    class_id?: IntFilter<"Subjects"> | number
    school_year?: StringNullableFilter<"Subjects"> | string | null
    coefficient?: IntNullableFilter<"Subjects"> | number | null
    supabase_id?: StringNullableFilter<"Subjects"> | string | null
    last_modified?: DateTimeFilter<"Subjects"> | Date | string
    needs_sync?: BoolFilter<"Subjects"> | boolean
    is_deleted?: BoolFilter<"Subjects"> | boolean
    lessons?: LessonsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    workHours?: TeacherWorkHoursListRelationFilter
  }

  export type SubjectsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lessons?: LessonsOrderByRelationAggregateInput
    class?: ClassesOrderByWithRelationInput
    workHours?: TeacherWorkHoursOrderByRelationAggregateInput
  }

  export type SubjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: SubjectsWhereInput | SubjectsWhereInput[]
    OR?: SubjectsWhereInput[]
    NOT?: SubjectsWhereInput | SubjectsWhereInput[]
    name?: StringFilter<"Subjects"> | string
    class_id?: IntFilter<"Subjects"> | number
    school_year?: StringNullableFilter<"Subjects"> | string | null
    coefficient?: IntNullableFilter<"Subjects"> | number | null
    last_modified?: DateTimeFilter<"Subjects"> | Date | string
    needs_sync?: BoolFilter<"Subjects"> | boolean
    is_deleted?: BoolFilter<"Subjects"> | boolean
    lessons?: LessonsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    workHours?: TeacherWorkHoursListRelationFilter
  }, "id" | "supabase_id">

  export type SubjectsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: SubjectsCountOrderByAggregateInput
    _avg?: SubjectsAvgOrderByAggregateInput
    _max?: SubjectsMaxOrderByAggregateInput
    _min?: SubjectsMinOrderByAggregateInput
    _sum?: SubjectsSumOrderByAggregateInput
  }

  export type SubjectsScalarWhereWithAggregatesInput = {
    AND?: SubjectsScalarWhereWithAggregatesInput | SubjectsScalarWhereWithAggregatesInput[]
    OR?: SubjectsScalarWhereWithAggregatesInput[]
    NOT?: SubjectsScalarWhereWithAggregatesInput | SubjectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subjects"> | number
    name?: StringWithAggregatesFilter<"Subjects"> | string
    class_id?: IntWithAggregatesFilter<"Subjects"> | number
    school_year?: StringNullableWithAggregatesFilter<"Subjects"> | string | null
    coefficient?: IntNullableWithAggregatesFilter<"Subjects"> | number | null
    supabase_id?: StringNullableWithAggregatesFilter<"Subjects"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Subjects"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Subjects"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Subjects"> | boolean
  }

  export type NotesWhereInput = {
    AND?: NotesWhereInput | NotesWhereInput[]
    OR?: NotesWhereInput[]
    NOT?: NotesWhereInput | NotesWhereInput[]
    id?: IntFilter<"Notes"> | number
    student_id?: IntFilter<"Notes"> | number
    lesson_id?: IntFilter<"Notes"> | number
    value?: FloatNullableFilter<"Notes"> | number | null
    type?: StringNullableFilter<"Notes"> | string | null
    quarter?: IntNullableFilter<"Notes"> | number | null
    supabase_id?: StringNullableFilter<"Notes"> | string | null
    last_modified?: DateTimeFilter<"Notes"> | Date | string
    needs_sync?: BoolFilter<"Notes"> | boolean
    is_deleted?: BoolFilter<"Notes"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type NotesOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    quarter?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lesson?: LessonsOrderByWithRelationInput
    student?: StudentsOrderByWithRelationInput
  }

  export type NotesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    student_id_lesson_id_quarter_type?: NotesStudent_idLesson_idQuarterTypeCompoundUniqueInput
    AND?: NotesWhereInput | NotesWhereInput[]
    OR?: NotesWhereInput[]
    NOT?: NotesWhereInput | NotesWhereInput[]
    student_id?: IntFilter<"Notes"> | number
    lesson_id?: IntFilter<"Notes"> | number
    value?: FloatNullableFilter<"Notes"> | number | null
    type?: StringNullableFilter<"Notes"> | string | null
    quarter?: IntNullableFilter<"Notes"> | number | null
    last_modified?: DateTimeFilter<"Notes"> | Date | string
    needs_sync?: BoolFilter<"Notes"> | boolean
    is_deleted?: BoolFilter<"Notes"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id" | "student_id_lesson_id_quarter_type">

  export type NotesOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    quarter?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: NotesCountOrderByAggregateInput
    _avg?: NotesAvgOrderByAggregateInput
    _max?: NotesMaxOrderByAggregateInput
    _min?: NotesMinOrderByAggregateInput
    _sum?: NotesSumOrderByAggregateInput
  }

  export type NotesScalarWhereWithAggregatesInput = {
    AND?: NotesScalarWhereWithAggregatesInput | NotesScalarWhereWithAggregatesInput[]
    OR?: NotesScalarWhereWithAggregatesInput[]
    NOT?: NotesScalarWhereWithAggregatesInput | NotesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notes"> | number
    student_id?: IntWithAggregatesFilter<"Notes"> | number
    lesson_id?: IntWithAggregatesFilter<"Notes"> | number
    value?: FloatNullableWithAggregatesFilter<"Notes"> | number | null
    type?: StringNullableWithAggregatesFilter<"Notes"> | string | null
    quarter?: IntNullableWithAggregatesFilter<"Notes"> | number | null
    supabase_id?: StringNullableWithAggregatesFilter<"Notes"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Notes"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Notes"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Notes"> | boolean
  }

  export type ParentsWhereInput = {
    AND?: ParentsWhereInput | ParentsWhereInput[]
    OR?: ParentsWhereInput[]
    NOT?: ParentsWhereInput | ParentsWhereInput[]
    id?: IntFilter<"Parents"> | number
    name?: StringNullableFilter<"Parents"> | string | null
    first_name?: StringNullableFilter<"Parents"> | string | null
    phone?: StringNullableFilter<"Parents"> | string | null
    email?: StringNullableFilter<"Parents"> | string | null
    adress?: StringNullableFilter<"Parents"> | string | null
    gender?: StringNullableFilter<"Parents"> | string | null
    profession?: StringNullableFilter<"Parents"> | string | null
    supabase_id?: StringNullableFilter<"Parents"> | string | null
    last_modified?: DateTimeFilter<"Parents"> | Date | string
    needs_sync?: BoolFilter<"Parents"> | boolean
    is_deleted?: BoolFilter<"Parents"> | boolean
    school_id?: StringNullableFilter<"Parents"> | string | null
    student_parents?: StudentParentsListRelationFilter
  }

  export type ParentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrderInput | SortOrder
    student_parents?: StudentParentsOrderByRelationAggregateInput
  }

  export type ParentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: ParentsWhereInput | ParentsWhereInput[]
    OR?: ParentsWhereInput[]
    NOT?: ParentsWhereInput | ParentsWhereInput[]
    name?: StringNullableFilter<"Parents"> | string | null
    first_name?: StringNullableFilter<"Parents"> | string | null
    phone?: StringNullableFilter<"Parents"> | string | null
    email?: StringNullableFilter<"Parents"> | string | null
    adress?: StringNullableFilter<"Parents"> | string | null
    gender?: StringNullableFilter<"Parents"> | string | null
    profession?: StringNullableFilter<"Parents"> | string | null
    last_modified?: DateTimeFilter<"Parents"> | Date | string
    needs_sync?: BoolFilter<"Parents"> | boolean
    is_deleted?: BoolFilter<"Parents"> | boolean
    school_id?: StringNullableFilter<"Parents"> | string | null
    student_parents?: StudentParentsListRelationFilter
  }, "id" | "supabase_id">

  export type ParentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrderInput | SortOrder
    _count?: ParentsCountOrderByAggregateInput
    _avg?: ParentsAvgOrderByAggregateInput
    _max?: ParentsMaxOrderByAggregateInput
    _min?: ParentsMinOrderByAggregateInput
    _sum?: ParentsSumOrderByAggregateInput
  }

  export type ParentsScalarWhereWithAggregatesInput = {
    AND?: ParentsScalarWhereWithAggregatesInput | ParentsScalarWhereWithAggregatesInput[]
    OR?: ParentsScalarWhereWithAggregatesInput[]
    NOT?: ParentsScalarWhereWithAggregatesInput | ParentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parents"> | number
    name?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    email?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    adress?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    profession?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Parents"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Parents"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Parents"> | boolean
    school_id?: StringNullableWithAggregatesFilter<"Parents"> | string | null
  }

  export type StudentParentsWhereInput = {
    AND?: StudentParentsWhereInput | StudentParentsWhereInput[]
    OR?: StudentParentsWhereInput[]
    NOT?: StudentParentsWhereInput | StudentParentsWhereInput[]
    id?: IntFilter<"StudentParents"> | number
    student_id?: IntFilter<"StudentParents"> | number
    parent_id?: IntFilter<"StudentParents"> | number
    relation?: StringNullableFilter<"StudentParents"> | string | null
    supabase_id?: StringNullableFilter<"StudentParents"> | string | null
    last_modified?: DateTimeFilter<"StudentParents"> | Date | string
    needs_sync?: BoolFilter<"StudentParents"> | boolean
    is_deleted?: BoolFilter<"StudentParents"> | boolean
    parent?: XOR<ParentsScalarRelationFilter, ParentsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type StudentParentsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    parent?: ParentsOrderByWithRelationInput
    student?: StudentsOrderByWithRelationInput
  }

  export type StudentParentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    student_id_parent_id_unique?: StudentParentsStudent_id_parent_id_uniqueCompoundUniqueInput
    AND?: StudentParentsWhereInput | StudentParentsWhereInput[]
    OR?: StudentParentsWhereInput[]
    NOT?: StudentParentsWhereInput | StudentParentsWhereInput[]
    student_id?: IntFilter<"StudentParents"> | number
    parent_id?: IntFilter<"StudentParents"> | number
    relation?: StringNullableFilter<"StudentParents"> | string | null
    last_modified?: DateTimeFilter<"StudentParents"> | Date | string
    needs_sync?: BoolFilter<"StudentParents"> | boolean
    is_deleted?: BoolFilter<"StudentParents"> | boolean
    parent?: XOR<ParentsScalarRelationFilter, ParentsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id" | "student_id_parent_id_unique">

  export type StudentParentsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: StudentParentsCountOrderByAggregateInput
    _avg?: StudentParentsAvgOrderByAggregateInput
    _max?: StudentParentsMaxOrderByAggregateInput
    _min?: StudentParentsMinOrderByAggregateInput
    _sum?: StudentParentsSumOrderByAggregateInput
  }

  export type StudentParentsScalarWhereWithAggregatesInput = {
    AND?: StudentParentsScalarWhereWithAggregatesInput | StudentParentsScalarWhereWithAggregatesInput[]
    OR?: StudentParentsScalarWhereWithAggregatesInput[]
    NOT?: StudentParentsScalarWhereWithAggregatesInput | StudentParentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentParents"> | number
    student_id?: IntWithAggregatesFilter<"StudentParents"> | number
    parent_id?: IntWithAggregatesFilter<"StudentParents"> | number
    relation?: StringNullableWithAggregatesFilter<"StudentParents"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"StudentParents"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"StudentParents"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"StudentParents"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"StudentParents"> | boolean
  }

  export type PaymentsWhereInput = {
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    id?: IntFilter<"Payments"> | number
    registration_id?: IntNullableFilter<"Payments"> | number | null
    amount?: FloatNullableFilter<"Payments"> | number | null
    method?: StringNullableFilter<"Payments"> | string | null
    date?: StringNullableFilter<"Payments"> | string | null
    reference?: StringNullableFilter<"Payments"> | string | null
    emitter_id?: StringNullableFilter<"Payments"> | string | null
    supabase_id?: StringNullableFilter<"Payments"> | string | null
    last_modified?: DateTimeFilter<"Payments"> | Date | string
    needs_sync?: BoolFilter<"Payments"> | boolean
    is_deleted?: BoolFilter<"Payments"> | boolean
    single_fee_id?: IntNullableFilter<"Payments"> | number | null
    fee_template_id?: IntNullableFilter<"Payments"> | number | null
    period_identifier?: StringNullableFilter<"Payments"> | string | null
    registration?: XOR<RegistrationsNullableScalarRelationFilter, RegistrationsWhereInput> | null
    single_fee?: XOR<SingleFeeNullableScalarRelationFilter, SingleFeeWhereInput> | null
    fee_template?: XOR<FeeTemplateNullableScalarRelationFilter, FeeTemplateWhereInput> | null
  }

  export type PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    registration_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    emitter_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    single_fee_id?: SortOrderInput | SortOrder
    fee_template_id?: SortOrderInput | SortOrder
    period_identifier?: SortOrderInput | SortOrder
    registration?: RegistrationsOrderByWithRelationInput
    single_fee?: SingleFeeOrderByWithRelationInput
    fee_template?: FeeTemplateOrderByWithRelationInput
  }

  export type PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    registration_id?: IntNullableFilter<"Payments"> | number | null
    amount?: FloatNullableFilter<"Payments"> | number | null
    method?: StringNullableFilter<"Payments"> | string | null
    date?: StringNullableFilter<"Payments"> | string | null
    reference?: StringNullableFilter<"Payments"> | string | null
    emitter_id?: StringNullableFilter<"Payments"> | string | null
    last_modified?: DateTimeFilter<"Payments"> | Date | string
    needs_sync?: BoolFilter<"Payments"> | boolean
    is_deleted?: BoolFilter<"Payments"> | boolean
    single_fee_id?: IntNullableFilter<"Payments"> | number | null
    fee_template_id?: IntNullableFilter<"Payments"> | number | null
    period_identifier?: StringNullableFilter<"Payments"> | string | null
    registration?: XOR<RegistrationsNullableScalarRelationFilter, RegistrationsWhereInput> | null
    single_fee?: XOR<SingleFeeNullableScalarRelationFilter, SingleFeeWhereInput> | null
    fee_template?: XOR<FeeTemplateNullableScalarRelationFilter, FeeTemplateWhereInput> | null
  }, "id" | "supabase_id">

  export type PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    registration_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    emitter_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    single_fee_id?: SortOrderInput | SortOrder
    fee_template_id?: SortOrderInput | SortOrder
    period_identifier?: SortOrderInput | SortOrder
    _count?: PaymentsCountOrderByAggregateInput
    _avg?: PaymentsAvgOrderByAggregateInput
    _max?: PaymentsMaxOrderByAggregateInput
    _min?: PaymentsMinOrderByAggregateInput
    _sum?: PaymentsSumOrderByAggregateInput
  }

  export type PaymentsScalarWhereWithAggregatesInput = {
    AND?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    OR?: PaymentsScalarWhereWithAggregatesInput[]
    NOT?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payments"> | number
    registration_id?: IntNullableWithAggregatesFilter<"Payments"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"Payments"> | number | null
    method?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    date?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    emitter_id?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Payments"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Payments"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Payments"> | boolean
    single_fee_id?: IntNullableWithAggregatesFilter<"Payments"> | number | null
    fee_template_id?: IntNullableWithAggregatesFilter<"Payments"> | number | null
    period_identifier?: StringNullableWithAggregatesFilter<"Payments"> | string | null
  }

  export type SingleFeeWhereInput = {
    AND?: SingleFeeWhereInput | SingleFeeWhereInput[]
    OR?: SingleFeeWhereInput[]
    NOT?: SingleFeeWhereInput | SingleFeeWhereInput[]
    id?: IntFilter<"SingleFee"> | number
    name?: StringNullableFilter<"SingleFee"> | string | null
    amount?: FloatNullableFilter<"SingleFee"> | number | null
    due_date?: StringNullableFilter<"SingleFee"> | string | null
    school_year?: StringNullableFilter<"SingleFee"> | string | null
    level?: StringNullableFilter<"SingleFee"> | string | null
    class_id?: IntNullableFilter<"SingleFee"> | number | null
    school_id?: StringNullableFilter<"SingleFee"> | string | null
    supabase_id?: StringNullableFilter<"SingleFee"> | string | null
    last_modified?: DateTimeFilter<"SingleFee"> | Date | string
    needs_sync?: BoolFilter<"SingleFee"> | boolean
    is_deleted?: BoolFilter<"SingleFee"> | boolean
    class?: XOR<ClassesNullableScalarRelationFilter, ClassesWhereInput> | null
    payments?: PaymentsListRelationFilter
    dispatch_rules?: DispatchRuleListRelationFilter
  }

  export type SingleFeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    school_year?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    class_id?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    class?: ClassesOrderByWithRelationInput
    payments?: PaymentsOrderByRelationAggregateInput
    dispatch_rules?: DispatchRuleOrderByRelationAggregateInput
  }

  export type SingleFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: SingleFeeWhereInput | SingleFeeWhereInput[]
    OR?: SingleFeeWhereInput[]
    NOT?: SingleFeeWhereInput | SingleFeeWhereInput[]
    name?: StringNullableFilter<"SingleFee"> | string | null
    amount?: FloatNullableFilter<"SingleFee"> | number | null
    due_date?: StringNullableFilter<"SingleFee"> | string | null
    school_year?: StringNullableFilter<"SingleFee"> | string | null
    level?: StringNullableFilter<"SingleFee"> | string | null
    class_id?: IntNullableFilter<"SingleFee"> | number | null
    school_id?: StringNullableFilter<"SingleFee"> | string | null
    last_modified?: DateTimeFilter<"SingleFee"> | Date | string
    needs_sync?: BoolFilter<"SingleFee"> | boolean
    is_deleted?: BoolFilter<"SingleFee"> | boolean
    class?: XOR<ClassesNullableScalarRelationFilter, ClassesWhereInput> | null
    payments?: PaymentsListRelationFilter
    dispatch_rules?: DispatchRuleListRelationFilter
  }, "id" | "supabase_id">

  export type SingleFeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    school_year?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    class_id?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: SingleFeeCountOrderByAggregateInput
    _avg?: SingleFeeAvgOrderByAggregateInput
    _max?: SingleFeeMaxOrderByAggregateInput
    _min?: SingleFeeMinOrderByAggregateInput
    _sum?: SingleFeeSumOrderByAggregateInput
  }

  export type SingleFeeScalarWhereWithAggregatesInput = {
    AND?: SingleFeeScalarWhereWithAggregatesInput | SingleFeeScalarWhereWithAggregatesInput[]
    OR?: SingleFeeScalarWhereWithAggregatesInput[]
    NOT?: SingleFeeScalarWhereWithAggregatesInput | SingleFeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SingleFee"> | number
    name?: StringNullableWithAggregatesFilter<"SingleFee"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"SingleFee"> | number | null
    due_date?: StringNullableWithAggregatesFilter<"SingleFee"> | string | null
    school_year?: StringNullableWithAggregatesFilter<"SingleFee"> | string | null
    level?: StringNullableWithAggregatesFilter<"SingleFee"> | string | null
    class_id?: IntNullableWithAggregatesFilter<"SingleFee"> | number | null
    school_id?: StringNullableWithAggregatesFilter<"SingleFee"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"SingleFee"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"SingleFee"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"SingleFee"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"SingleFee"> | boolean
  }

  export type FeeTemplateWhereInput = {
    AND?: FeeTemplateWhereInput | FeeTemplateWhereInput[]
    OR?: FeeTemplateWhereInput[]
    NOT?: FeeTemplateWhereInput | FeeTemplateWhereInput[]
    id?: IntFilter<"FeeTemplate"> | number
    name?: StringFilter<"FeeTemplate"> | string
    amount?: FloatFilter<"FeeTemplate"> | number
    frequency?: StringFilter<"FeeTemplate"> | string
    due_day?: IntNullableFilter<"FeeTemplate"> | number | null
    applicable_months?: JsonNullableFilter<"FeeTemplate">
    school_id?: StringFilter<"FeeTemplate"> | string
    applies_to_level?: StringNullableFilter<"FeeTemplate"> | string | null
    applies_to_class_id?: IntNullableFilter<"FeeTemplate"> | number | null
    supabase_id?: StringNullableFilter<"FeeTemplate"> | string | null
    last_modified?: DateTimeFilter<"FeeTemplate"> | Date | string
    needs_sync?: BoolFilter<"FeeTemplate"> | boolean
    is_deleted?: BoolFilter<"FeeTemplate"> | boolean
    class?: XOR<ClassesNullableScalarRelationFilter, ClassesWhereInput> | null
    payments?: PaymentsListRelationFilter
  }

  export type FeeTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    due_day?: SortOrderInput | SortOrder
    applicable_months?: SortOrderInput | SortOrder
    school_id?: SortOrder
    applies_to_level?: SortOrderInput | SortOrder
    applies_to_class_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    class?: ClassesOrderByWithRelationInput
    payments?: PaymentsOrderByRelationAggregateInput
  }

  export type FeeTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: FeeTemplateWhereInput | FeeTemplateWhereInput[]
    OR?: FeeTemplateWhereInput[]
    NOT?: FeeTemplateWhereInput | FeeTemplateWhereInput[]
    name?: StringFilter<"FeeTemplate"> | string
    amount?: FloatFilter<"FeeTemplate"> | number
    frequency?: StringFilter<"FeeTemplate"> | string
    due_day?: IntNullableFilter<"FeeTemplate"> | number | null
    applicable_months?: JsonNullableFilter<"FeeTemplate">
    school_id?: StringFilter<"FeeTemplate"> | string
    applies_to_level?: StringNullableFilter<"FeeTemplate"> | string | null
    applies_to_class_id?: IntNullableFilter<"FeeTemplate"> | number | null
    last_modified?: DateTimeFilter<"FeeTemplate"> | Date | string
    needs_sync?: BoolFilter<"FeeTemplate"> | boolean
    is_deleted?: BoolFilter<"FeeTemplate"> | boolean
    class?: XOR<ClassesNullableScalarRelationFilter, ClassesWhereInput> | null
    payments?: PaymentsListRelationFilter
  }, "id" | "supabase_id">

  export type FeeTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    due_day?: SortOrderInput | SortOrder
    applicable_months?: SortOrderInput | SortOrder
    school_id?: SortOrder
    applies_to_level?: SortOrderInput | SortOrder
    applies_to_class_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: FeeTemplateCountOrderByAggregateInput
    _avg?: FeeTemplateAvgOrderByAggregateInput
    _max?: FeeTemplateMaxOrderByAggregateInput
    _min?: FeeTemplateMinOrderByAggregateInput
    _sum?: FeeTemplateSumOrderByAggregateInput
  }

  export type FeeTemplateScalarWhereWithAggregatesInput = {
    AND?: FeeTemplateScalarWhereWithAggregatesInput | FeeTemplateScalarWhereWithAggregatesInput[]
    OR?: FeeTemplateScalarWhereWithAggregatesInput[]
    NOT?: FeeTemplateScalarWhereWithAggregatesInput | FeeTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeeTemplate"> | number
    name?: StringWithAggregatesFilter<"FeeTemplate"> | string
    amount?: FloatWithAggregatesFilter<"FeeTemplate"> | number
    frequency?: StringWithAggregatesFilter<"FeeTemplate"> | string
    due_day?: IntNullableWithAggregatesFilter<"FeeTemplate"> | number | null
    applicable_months?: JsonNullableWithAggregatesFilter<"FeeTemplate">
    school_id?: StringWithAggregatesFilter<"FeeTemplate"> | string
    applies_to_level?: StringNullableWithAggregatesFilter<"FeeTemplate"> | string | null
    applies_to_class_id?: IntNullableWithAggregatesFilter<"FeeTemplate"> | number | null
    supabase_id?: StringNullableWithAggregatesFilter<"FeeTemplate"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"FeeTemplate"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"FeeTemplate"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"FeeTemplate"> | boolean
  }

  export type AttendancesWhereInput = {
    AND?: AttendancesWhereInput | AttendancesWhereInput[]
    OR?: AttendancesWhereInput[]
    NOT?: AttendancesWhereInput | AttendancesWhereInput[]
    id?: IntFilter<"Attendances"> | number
    student_id?: IntFilter<"Attendances"> | number
    date?: StringNullableFilter<"Attendances"> | string | null
    state?: StringNullableFilter<"Attendances"> | string | null
    justification?: StringNullableFilter<"Attendances"> | string | null
    supabase_id?: StringNullableFilter<"Attendances"> | string | null
    last_modified?: DateTimeFilter<"Attendances"> | Date | string
    needs_sync?: BoolFilter<"Attendances"> | boolean
    is_deleted?: BoolFilter<"Attendances"> | boolean
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type AttendancesOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    student?: StudentsOrderByWithRelationInput
  }

  export type AttendancesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: AttendancesWhereInput | AttendancesWhereInput[]
    OR?: AttendancesWhereInput[]
    NOT?: AttendancesWhereInput | AttendancesWhereInput[]
    student_id?: IntFilter<"Attendances"> | number
    date?: StringNullableFilter<"Attendances"> | string | null
    state?: StringNullableFilter<"Attendances"> | string | null
    justification?: StringNullableFilter<"Attendances"> | string | null
    last_modified?: DateTimeFilter<"Attendances"> | Date | string
    needs_sync?: BoolFilter<"Attendances"> | boolean
    is_deleted?: BoolFilter<"Attendances"> | boolean
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id">

  export type AttendancesOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: AttendancesCountOrderByAggregateInput
    _avg?: AttendancesAvgOrderByAggregateInput
    _max?: AttendancesMaxOrderByAggregateInput
    _min?: AttendancesMinOrderByAggregateInput
    _sum?: AttendancesSumOrderByAggregateInput
  }

  export type AttendancesScalarWhereWithAggregatesInput = {
    AND?: AttendancesScalarWhereWithAggregatesInput | AttendancesScalarWhereWithAggregatesInput[]
    OR?: AttendancesScalarWhereWithAggregatesInput[]
    NOT?: AttendancesScalarWhereWithAggregatesInput | AttendancesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attendances"> | number
    student_id?: IntWithAggregatesFilter<"Attendances"> | number
    date?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    state?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    justification?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Attendances"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Attendances"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Attendances"> | boolean
  }

  export type EmployeesWhereInput = {
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    id?: IntFilter<"Employees"> | number
    name?: StringNullableFilter<"Employees"> | string | null
    first_name?: StringNullableFilter<"Employees"> | string | null
    phone?: StringNullableFilter<"Employees"> | string | null
    email?: StringNullableFilter<"Employees"> | string | null
    adress?: StringNullableFilter<"Employees"> | string | null
    gender?: StringNullableFilter<"Employees"> | string | null
    job_title?: StringNullableFilter<"Employees"> | string | null
    salary?: FloatNullableFilter<"Employees"> | number | null
    matricule?: StringNullableFilter<"Employees"> | string | null
    school_id?: StringNullableFilter<"Employees"> | string | null
    password_hash?: StringNullableFilter<"Employees"> | string | null
    supabase_id?: StringNullableFilter<"Employees"> | string | null
    user_supabase_id?: StringNullableFilter<"Employees"> | string | null
    last_modified?: DateTimeFilter<"Employees"> | Date | string
    needs_sync?: BoolFilter<"Employees"> | boolean
    is_deleted?: BoolFilter<"Employees"> | boolean
    salary_payments?: SalaryPaymentsListRelationFilter
    attendances?: EmployeeAttendanceListRelationFilter
  }

  export type EmployeesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    job_title?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    salary_payments?: SalaryPaymentsOrderByRelationAggregateInput
    attendances?: EmployeeAttendanceOrderByRelationAggregateInput
  }

  export type EmployeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    name?: StringNullableFilter<"Employees"> | string | null
    first_name?: StringNullableFilter<"Employees"> | string | null
    phone?: StringNullableFilter<"Employees"> | string | null
    email?: StringNullableFilter<"Employees"> | string | null
    adress?: StringNullableFilter<"Employees"> | string | null
    gender?: StringNullableFilter<"Employees"> | string | null
    job_title?: StringNullableFilter<"Employees"> | string | null
    salary?: FloatNullableFilter<"Employees"> | number | null
    matricule?: StringNullableFilter<"Employees"> | string | null
    school_id?: StringNullableFilter<"Employees"> | string | null
    password_hash?: StringNullableFilter<"Employees"> | string | null
    user_supabase_id?: StringNullableFilter<"Employees"> | string | null
    last_modified?: DateTimeFilter<"Employees"> | Date | string
    needs_sync?: BoolFilter<"Employees"> | boolean
    is_deleted?: BoolFilter<"Employees"> | boolean
    salary_payments?: SalaryPaymentsListRelationFilter
    attendances?: EmployeeAttendanceListRelationFilter
  }, "id" | "supabase_id">

  export type EmployeesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    job_title?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: EmployeesCountOrderByAggregateInput
    _avg?: EmployeesAvgOrderByAggregateInput
    _max?: EmployeesMaxOrderByAggregateInput
    _min?: EmployeesMinOrderByAggregateInput
    _sum?: EmployeesSumOrderByAggregateInput
  }

  export type EmployeesScalarWhereWithAggregatesInput = {
    AND?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    OR?: EmployeesScalarWhereWithAggregatesInput[]
    NOT?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employees"> | number
    name?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    email?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    adress?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    job_title?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    salary?: FloatNullableWithAggregatesFilter<"Employees"> | number | null
    matricule?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    school_id?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    user_supabase_id?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Employees"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Employees"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Employees"> | boolean
  }

  export type SalaryPaymentsWhereInput = {
    AND?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    OR?: SalaryPaymentsWhereInput[]
    NOT?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    id?: IntFilter<"SalaryPayments"> | number
    employee_id?: IntFilter<"SalaryPayments"> | number
    base_salary?: FloatFilter<"SalaryPayments"> | number
    bonus_amount?: FloatFilter<"SalaryPayments"> | number
    total_amount?: FloatFilter<"SalaryPayments"> | number
    payment_date?: StringFilter<"SalaryPayments"> | string
    notes?: StringNullableFilter<"SalaryPayments"> | string | null
    supabase_id?: StringNullableFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolFilter<"SalaryPayments"> | boolean
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }

  export type SalaryPaymentsOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    employee?: EmployeesOrderByWithRelationInput
  }

  export type SalaryPaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    OR?: SalaryPaymentsWhereInput[]
    NOT?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    employee_id?: IntFilter<"SalaryPayments"> | number
    base_salary?: FloatFilter<"SalaryPayments"> | number
    bonus_amount?: FloatFilter<"SalaryPayments"> | number
    total_amount?: FloatFilter<"SalaryPayments"> | number
    payment_date?: StringFilter<"SalaryPayments"> | string
    notes?: StringNullableFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolFilter<"SalaryPayments"> | boolean
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }, "id" | "supabase_id">

  export type SalaryPaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: SalaryPaymentsCountOrderByAggregateInput
    _avg?: SalaryPaymentsAvgOrderByAggregateInput
    _max?: SalaryPaymentsMaxOrderByAggregateInput
    _min?: SalaryPaymentsMinOrderByAggregateInput
    _sum?: SalaryPaymentsSumOrderByAggregateInput
  }

  export type SalaryPaymentsScalarWhereWithAggregatesInput = {
    AND?: SalaryPaymentsScalarWhereWithAggregatesInput | SalaryPaymentsScalarWhereWithAggregatesInput[]
    OR?: SalaryPaymentsScalarWhereWithAggregatesInput[]
    NOT?: SalaryPaymentsScalarWhereWithAggregatesInput | SalaryPaymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryPayments"> | number
    employee_id?: IntWithAggregatesFilter<"SalaryPayments"> | number
    base_salary?: FloatWithAggregatesFilter<"SalaryPayments"> | number
    bonus_amount?: FloatWithAggregatesFilter<"SalaryPayments"> | number
    total_amount?: FloatWithAggregatesFilter<"SalaryPayments"> | number
    payment_date?: StringWithAggregatesFilter<"SalaryPayments"> | string
    notes?: StringNullableWithAggregatesFilter<"SalaryPayments"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"SalaryPayments"> | boolean
  }

  export type SchedulesWhereInput = {
    AND?: SchedulesWhereInput | SchedulesWhereInput[]
    OR?: SchedulesWhereInput[]
    NOT?: SchedulesWhereInput | SchedulesWhereInput[]
    id?: IntFilter<"Schedules"> | number
    lesson_id?: IntFilter<"Schedules"> | number
    day_of_week?: StringNullableFilter<"Schedules"> | string | null
    start_time?: StringNullableFilter<"Schedules"> | string | null
    end_time?: StringNullableFilter<"Schedules"> | string | null
    supabase_id?: StringNullableFilter<"Schedules"> | string | null
    last_modified?: DateTimeFilter<"Schedules"> | Date | string
    needs_sync?: BoolFilter<"Schedules"> | boolean
    is_deleted?: BoolFilter<"Schedules"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
  }

  export type SchedulesOrderByWithRelationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lesson?: LessonsOrderByWithRelationInput
  }

  export type SchedulesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: SchedulesWhereInput | SchedulesWhereInput[]
    OR?: SchedulesWhereInput[]
    NOT?: SchedulesWhereInput | SchedulesWhereInput[]
    lesson_id?: IntFilter<"Schedules"> | number
    day_of_week?: StringNullableFilter<"Schedules"> | string | null
    start_time?: StringNullableFilter<"Schedules"> | string | null
    end_time?: StringNullableFilter<"Schedules"> | string | null
    last_modified?: DateTimeFilter<"Schedules"> | Date | string
    needs_sync?: BoolFilter<"Schedules"> | boolean
    is_deleted?: BoolFilter<"Schedules"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
  }, "id" | "supabase_id">

  export type SchedulesOrderByWithAggregationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: SchedulesCountOrderByAggregateInput
    _avg?: SchedulesAvgOrderByAggregateInput
    _max?: SchedulesMaxOrderByAggregateInput
    _min?: SchedulesMinOrderByAggregateInput
    _sum?: SchedulesSumOrderByAggregateInput
  }

  export type SchedulesScalarWhereWithAggregatesInput = {
    AND?: SchedulesScalarWhereWithAggregatesInput | SchedulesScalarWhereWithAggregatesInput[]
    OR?: SchedulesScalarWhereWithAggregatesInput[]
    NOT?: SchedulesScalarWhereWithAggregatesInput | SchedulesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Schedules"> | number
    lesson_id?: IntWithAggregatesFilter<"Schedules"> | number
    day_of_week?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    start_time?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Schedules"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Schedules"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Schedules"> | boolean
  }

  export type FinancialCategoryWhereInput = {
    AND?: FinancialCategoryWhereInput | FinancialCategoryWhereInput[]
    OR?: FinancialCategoryWhereInput[]
    NOT?: FinancialCategoryWhereInput | FinancialCategoryWhereInput[]
    id?: IntFilter<"FinancialCategory"> | number
    name?: StringFilter<"FinancialCategory"> | string
    type?: StringFilter<"FinancialCategory"> | string
    school_id?: StringNullableFilter<"FinancialCategory"> | string | null
    supabase_id?: StringNullableFilter<"FinancialCategory"> | string | null
    last_modified?: DateTimeFilter<"FinancialCategory"> | Date | string
    needs_sync?: BoolFilter<"FinancialCategory"> | boolean
    is_deleted?: BoolFilter<"FinancialCategory"> | boolean
    transactions?: FinancialTransactionListRelationFilter
    dispatch_rule_details?: DispatchRuleDetailListRelationFilter
  }

  export type FinancialCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    transactions?: FinancialTransactionOrderByRelationAggregateInput
    dispatch_rule_details?: DispatchRuleDetailOrderByRelationAggregateInput
  }

  export type FinancialCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: FinancialCategoryWhereInput | FinancialCategoryWhereInput[]
    OR?: FinancialCategoryWhereInput[]
    NOT?: FinancialCategoryWhereInput | FinancialCategoryWhereInput[]
    name?: StringFilter<"FinancialCategory"> | string
    type?: StringFilter<"FinancialCategory"> | string
    school_id?: StringNullableFilter<"FinancialCategory"> | string | null
    last_modified?: DateTimeFilter<"FinancialCategory"> | Date | string
    needs_sync?: BoolFilter<"FinancialCategory"> | boolean
    is_deleted?: BoolFilter<"FinancialCategory"> | boolean
    transactions?: FinancialTransactionListRelationFilter
    dispatch_rule_details?: DispatchRuleDetailListRelationFilter
  }, "id" | "supabase_id">

  export type FinancialCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: FinancialCategoryCountOrderByAggregateInput
    _avg?: FinancialCategoryAvgOrderByAggregateInput
    _max?: FinancialCategoryMaxOrderByAggregateInput
    _min?: FinancialCategoryMinOrderByAggregateInput
    _sum?: FinancialCategorySumOrderByAggregateInput
  }

  export type FinancialCategoryScalarWhereWithAggregatesInput = {
    AND?: FinancialCategoryScalarWhereWithAggregatesInput | FinancialCategoryScalarWhereWithAggregatesInput[]
    OR?: FinancialCategoryScalarWhereWithAggregatesInput[]
    NOT?: FinancialCategoryScalarWhereWithAggregatesInput | FinancialCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinancialCategory"> | number
    name?: StringWithAggregatesFilter<"FinancialCategory"> | string
    type?: StringWithAggregatesFilter<"FinancialCategory"> | string
    school_id?: StringNullableWithAggregatesFilter<"FinancialCategory"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"FinancialCategory"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"FinancialCategory"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"FinancialCategory"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"FinancialCategory"> | boolean
  }

  export type FinancialTransactionWhereInput = {
    AND?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    OR?: FinancialTransactionWhereInput[]
    NOT?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    id?: IntFilter<"FinancialTransaction"> | number
    date?: DateTimeFilter<"FinancialTransaction"> | Date | string
    description?: StringFilter<"FinancialTransaction"> | string
    amount?: FloatFilter<"FinancialTransaction"> | number
    type?: StringFilter<"FinancialTransaction"> | string
    category_id?: IntFilter<"FinancialTransaction"> | number
    school_id?: StringNullableFilter<"FinancialTransaction"> | string | null
    supabase_id?: StringNullableFilter<"FinancialTransaction"> | string | null
    last_modified?: DateTimeFilter<"FinancialTransaction"> | Date | string
    needs_sync?: BoolFilter<"FinancialTransaction"> | boolean
    is_deleted?: BoolFilter<"FinancialTransaction"> | boolean
    category?: XOR<FinancialCategoryScalarRelationFilter, FinancialCategoryWhereInput>
  }

  export type FinancialTransactionOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category_id?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    category?: FinancialCategoryOrderByWithRelationInput
  }

  export type FinancialTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    OR?: FinancialTransactionWhereInput[]
    NOT?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    date?: DateTimeFilter<"FinancialTransaction"> | Date | string
    description?: StringFilter<"FinancialTransaction"> | string
    amount?: FloatFilter<"FinancialTransaction"> | number
    type?: StringFilter<"FinancialTransaction"> | string
    category_id?: IntFilter<"FinancialTransaction"> | number
    school_id?: StringNullableFilter<"FinancialTransaction"> | string | null
    last_modified?: DateTimeFilter<"FinancialTransaction"> | Date | string
    needs_sync?: BoolFilter<"FinancialTransaction"> | boolean
    is_deleted?: BoolFilter<"FinancialTransaction"> | boolean
    category?: XOR<FinancialCategoryScalarRelationFilter, FinancialCategoryWhereInput>
  }, "id" | "supabase_id">

  export type FinancialTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category_id?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: FinancialTransactionCountOrderByAggregateInput
    _avg?: FinancialTransactionAvgOrderByAggregateInput
    _max?: FinancialTransactionMaxOrderByAggregateInput
    _min?: FinancialTransactionMinOrderByAggregateInput
    _sum?: FinancialTransactionSumOrderByAggregateInput
  }

  export type FinancialTransactionScalarWhereWithAggregatesInput = {
    AND?: FinancialTransactionScalarWhereWithAggregatesInput | FinancialTransactionScalarWhereWithAggregatesInput[]
    OR?: FinancialTransactionScalarWhereWithAggregatesInput[]
    NOT?: FinancialTransactionScalarWhereWithAggregatesInput | FinancialTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinancialTransaction"> | number
    date?: DateTimeWithAggregatesFilter<"FinancialTransaction"> | Date | string
    description?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    amount?: FloatWithAggregatesFilter<"FinancialTransaction"> | number
    type?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    category_id?: IntWithAggregatesFilter<"FinancialTransaction"> | number
    school_id?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"FinancialTransaction"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"FinancialTransaction"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"FinancialTransaction"> | boolean
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: IntFilter<"Budget"> | number
    category?: StringFilter<"Budget"> | string
    amount?: FloatFilter<"Budget"> | number
    period_start?: DateTimeFilter<"Budget"> | Date | string
    period_end?: DateTimeFilter<"Budget"> | Date | string
    school_id?: StringNullableFilter<"Budget"> | string | null
    supabase_id?: StringNullableFilter<"Budget"> | string | null
    last_modified?: DateTimeFilter<"Budget"> | Date | string
    needs_sync?: BoolFilter<"Budget"> | boolean
    is_deleted?: BoolFilter<"Budget"> | boolean
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    category?: StringFilter<"Budget"> | string
    amount?: FloatFilter<"Budget"> | number
    period_start?: DateTimeFilter<"Budget"> | Date | string
    period_end?: DateTimeFilter<"Budget"> | Date | string
    school_id?: StringNullableFilter<"Budget"> | string | null
    last_modified?: DateTimeFilter<"Budget"> | Date | string
    needs_sync?: BoolFilter<"Budget"> | boolean
    is_deleted?: BoolFilter<"Budget"> | boolean
  }, "id" | "supabase_id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Budget"> | number
    category?: StringWithAggregatesFilter<"Budget"> | string
    amount?: FloatWithAggregatesFilter<"Budget"> | number
    period_start?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    period_end?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    school_id?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Budget"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Budget"> | boolean
  }

  export type FinancialReportWhereInput = {
    AND?: FinancialReportWhereInput | FinancialReportWhereInput[]
    OR?: FinancialReportWhereInput[]
    NOT?: FinancialReportWhereInput | FinancialReportWhereInput[]
    id?: IntFilter<"FinancialReport"> | number
    title?: StringFilter<"FinancialReport"> | string
    generated_at?: DateTimeFilter<"FinancialReport"> | Date | string
    start_date?: DateTimeFilter<"FinancialReport"> | Date | string
    end_date?: DateTimeFilter<"FinancialReport"> | Date | string
    content?: StringFilter<"FinancialReport"> | string
    school_id?: StringNullableFilter<"FinancialReport"> | string | null
    supabase_id?: StringNullableFilter<"FinancialReport"> | string | null
    last_modified?: DateTimeFilter<"FinancialReport"> | Date | string
    needs_sync?: BoolFilter<"FinancialReport"> | boolean
    is_deleted?: BoolFilter<"FinancialReport"> | boolean
  }

  export type FinancialReportOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    generated_at?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    content?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: FinancialReportWhereInput | FinancialReportWhereInput[]
    OR?: FinancialReportWhereInput[]
    NOT?: FinancialReportWhereInput | FinancialReportWhereInput[]
    title?: StringFilter<"FinancialReport"> | string
    generated_at?: DateTimeFilter<"FinancialReport"> | Date | string
    start_date?: DateTimeFilter<"FinancialReport"> | Date | string
    end_date?: DateTimeFilter<"FinancialReport"> | Date | string
    content?: StringFilter<"FinancialReport"> | string
    school_id?: StringNullableFilter<"FinancialReport"> | string | null
    last_modified?: DateTimeFilter<"FinancialReport"> | Date | string
    needs_sync?: BoolFilter<"FinancialReport"> | boolean
    is_deleted?: BoolFilter<"FinancialReport"> | boolean
  }, "id" | "supabase_id">

  export type FinancialReportOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    generated_at?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    content?: SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: FinancialReportCountOrderByAggregateInput
    _avg?: FinancialReportAvgOrderByAggregateInput
    _max?: FinancialReportMaxOrderByAggregateInput
    _min?: FinancialReportMinOrderByAggregateInput
    _sum?: FinancialReportSumOrderByAggregateInput
  }

  export type FinancialReportScalarWhereWithAggregatesInput = {
    AND?: FinancialReportScalarWhereWithAggregatesInput | FinancialReportScalarWhereWithAggregatesInput[]
    OR?: FinancialReportScalarWhereWithAggregatesInput[]
    NOT?: FinancialReportScalarWhereWithAggregatesInput | FinancialReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinancialReport"> | number
    title?: StringWithAggregatesFilter<"FinancialReport"> | string
    generated_at?: DateTimeWithAggregatesFilter<"FinancialReport"> | Date | string
    start_date?: DateTimeWithAggregatesFilter<"FinancialReport"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"FinancialReport"> | Date | string
    content?: StringWithAggregatesFilter<"FinancialReport"> | string
    school_id?: StringNullableWithAggregatesFilter<"FinancialReport"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"FinancialReport"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"FinancialReport"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"FinancialReport"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"FinancialReport"> | boolean
  }

  export type DispatchRuleWhereInput = {
    AND?: DispatchRuleWhereInput | DispatchRuleWhereInput[]
    OR?: DispatchRuleWhereInput[]
    NOT?: DispatchRuleWhereInput | DispatchRuleWhereInput[]
    id?: IntFilter<"DispatchRule"> | number
    name?: StringFilter<"DispatchRule"> | string
    source_single_fee_id?: IntFilter<"DispatchRule"> | number
    school_id?: StringFilter<"DispatchRule"> | string
    supabase_id?: StringNullableFilter<"DispatchRule"> | string | null
    last_modified?: DateTimeFilter<"DispatchRule"> | Date | string
    needs_sync?: BoolFilter<"DispatchRule"> | boolean
    is_deleted?: BoolFilter<"DispatchRule"> | boolean
    source_single_fee?: XOR<SingleFeeScalarRelationFilter, SingleFeeWhereInput>
    details?: DispatchRuleDetailListRelationFilter
  }

  export type DispatchRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    source_single_fee_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    source_single_fee?: SingleFeeOrderByWithRelationInput
    details?: DispatchRuleDetailOrderByRelationAggregateInput
  }

  export type DispatchRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    source_single_fee_id?: number
    supabase_id?: string
    AND?: DispatchRuleWhereInput | DispatchRuleWhereInput[]
    OR?: DispatchRuleWhereInput[]
    NOT?: DispatchRuleWhereInput | DispatchRuleWhereInput[]
    name?: StringFilter<"DispatchRule"> | string
    school_id?: StringFilter<"DispatchRule"> | string
    last_modified?: DateTimeFilter<"DispatchRule"> | Date | string
    needs_sync?: BoolFilter<"DispatchRule"> | boolean
    is_deleted?: BoolFilter<"DispatchRule"> | boolean
    source_single_fee?: XOR<SingleFeeScalarRelationFilter, SingleFeeWhereInput>
    details?: DispatchRuleDetailListRelationFilter
  }, "id" | "source_single_fee_id" | "supabase_id">

  export type DispatchRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    source_single_fee_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: DispatchRuleCountOrderByAggregateInput
    _avg?: DispatchRuleAvgOrderByAggregateInput
    _max?: DispatchRuleMaxOrderByAggregateInput
    _min?: DispatchRuleMinOrderByAggregateInput
    _sum?: DispatchRuleSumOrderByAggregateInput
  }

  export type DispatchRuleScalarWhereWithAggregatesInput = {
    AND?: DispatchRuleScalarWhereWithAggregatesInput | DispatchRuleScalarWhereWithAggregatesInput[]
    OR?: DispatchRuleScalarWhereWithAggregatesInput[]
    NOT?: DispatchRuleScalarWhereWithAggregatesInput | DispatchRuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DispatchRule"> | number
    name?: StringWithAggregatesFilter<"DispatchRule"> | string
    source_single_fee_id?: IntWithAggregatesFilter<"DispatchRule"> | number
    school_id?: StringWithAggregatesFilter<"DispatchRule"> | string
    supabase_id?: StringNullableWithAggregatesFilter<"DispatchRule"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"DispatchRule"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"DispatchRule"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"DispatchRule"> | boolean
  }

  export type DispatchRuleDetailWhereInput = {
    AND?: DispatchRuleDetailWhereInput | DispatchRuleDetailWhereInput[]
    OR?: DispatchRuleDetailWhereInput[]
    NOT?: DispatchRuleDetailWhereInput | DispatchRuleDetailWhereInput[]
    id?: IntFilter<"DispatchRuleDetail"> | number
    dispatch_rule_id?: IntFilter<"DispatchRuleDetail"> | number
    destination_category_id?: IntFilter<"DispatchRuleDetail"> | number
    percentage?: FloatFilter<"DispatchRuleDetail"> | number
    supabase_id?: StringNullableFilter<"DispatchRuleDetail"> | string | null
    last_modified?: DateTimeFilter<"DispatchRuleDetail"> | Date | string
    needs_sync?: BoolFilter<"DispatchRuleDetail"> | boolean
    is_deleted?: BoolFilter<"DispatchRuleDetail"> | boolean
    dispatch_rule?: XOR<DispatchRuleScalarRelationFilter, DispatchRuleWhereInput>
    destination_category?: XOR<FinancialCategoryScalarRelationFilter, FinancialCategoryWhereInput>
  }

  export type DispatchRuleDetailOrderByWithRelationInput = {
    id?: SortOrder
    dispatch_rule_id?: SortOrder
    destination_category_id?: SortOrder
    percentage?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    dispatch_rule?: DispatchRuleOrderByWithRelationInput
    destination_category?: FinancialCategoryOrderByWithRelationInput
  }

  export type DispatchRuleDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: DispatchRuleDetailWhereInput | DispatchRuleDetailWhereInput[]
    OR?: DispatchRuleDetailWhereInput[]
    NOT?: DispatchRuleDetailWhereInput | DispatchRuleDetailWhereInput[]
    dispatch_rule_id?: IntFilter<"DispatchRuleDetail"> | number
    destination_category_id?: IntFilter<"DispatchRuleDetail"> | number
    percentage?: FloatFilter<"DispatchRuleDetail"> | number
    last_modified?: DateTimeFilter<"DispatchRuleDetail"> | Date | string
    needs_sync?: BoolFilter<"DispatchRuleDetail"> | boolean
    is_deleted?: BoolFilter<"DispatchRuleDetail"> | boolean
    dispatch_rule?: XOR<DispatchRuleScalarRelationFilter, DispatchRuleWhereInput>
    destination_category?: XOR<FinancialCategoryScalarRelationFilter, FinancialCategoryWhereInput>
  }, "id" | "supabase_id">

  export type DispatchRuleDetailOrderByWithAggregationInput = {
    id?: SortOrder
    dispatch_rule_id?: SortOrder
    destination_category_id?: SortOrder
    percentage?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: DispatchRuleDetailCountOrderByAggregateInput
    _avg?: DispatchRuleDetailAvgOrderByAggregateInput
    _max?: DispatchRuleDetailMaxOrderByAggregateInput
    _min?: DispatchRuleDetailMinOrderByAggregateInput
    _sum?: DispatchRuleDetailSumOrderByAggregateInput
  }

  export type DispatchRuleDetailScalarWhereWithAggregatesInput = {
    AND?: DispatchRuleDetailScalarWhereWithAggregatesInput | DispatchRuleDetailScalarWhereWithAggregatesInput[]
    OR?: DispatchRuleDetailScalarWhereWithAggregatesInput[]
    NOT?: DispatchRuleDetailScalarWhereWithAggregatesInput | DispatchRuleDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DispatchRuleDetail"> | number
    dispatch_rule_id?: IntWithAggregatesFilter<"DispatchRuleDetail"> | number
    destination_category_id?: IntWithAggregatesFilter<"DispatchRuleDetail"> | number
    percentage?: FloatWithAggregatesFilter<"DispatchRuleDetail"> | number
    supabase_id?: StringNullableWithAggregatesFilter<"DispatchRuleDetail"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"DispatchRuleDetail"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"DispatchRuleDetail"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"DispatchRuleDetail"> | boolean
  }

  export type EventsWhereInput = {
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    id?: IntFilter<"Events"> | number
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    date?: DateTimeFilter<"Events"> | Date | string
    location?: StringNullableFilter<"Events"> | string | null
    image_url?: StringNullableFilter<"Events"> | string | null
    school_id?: StringFilter<"Events"> | string
    supabase_id?: StringNullableFilter<"Events"> | string | null
    last_modified?: DateTimeFilter<"Events"> | Date | string
    needs_sync?: BoolFilter<"Events"> | boolean
    is_deleted?: BoolFilter<"Events"> | boolean
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    location?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    date?: DateTimeFilter<"Events"> | Date | string
    location?: StringNullableFilter<"Events"> | string | null
    image_url?: StringNullableFilter<"Events"> | string | null
    school_id?: StringFilter<"Events"> | string
    last_modified?: DateTimeFilter<"Events"> | Date | string
    needs_sync?: BoolFilter<"Events"> | boolean
    is_deleted?: BoolFilter<"Events"> | boolean
  }, "id" | "supabase_id">

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    location?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: EventsCountOrderByAggregateInput
    _avg?: EventsAvgOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
    _sum?: EventsSumOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    OR?: EventsScalarWhereWithAggregatesInput[]
    NOT?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Events"> | number
    title?: StringWithAggregatesFilter<"Events"> | string
    description?: StringNullableWithAggregatesFilter<"Events"> | string | null
    date?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Events"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"Events"> | string | null
    school_id?: StringWithAggregatesFilter<"Events"> | string
    supabase_id?: StringNullableWithAggregatesFilter<"Events"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Events"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Events"> | boolean
  }

  export type EmployeeAttendanceWhereInput = {
    AND?: EmployeeAttendanceWhereInput | EmployeeAttendanceWhereInput[]
    OR?: EmployeeAttendanceWhereInput[]
    NOT?: EmployeeAttendanceWhereInput | EmployeeAttendanceWhereInput[]
    id?: IntFilter<"EmployeeAttendance"> | number
    employee_id?: IntNullableFilter<"EmployeeAttendance"> | number | null
    teacher_id?: IntNullableFilter<"EmployeeAttendance"> | number | null
    check_in?: DateTimeFilter<"EmployeeAttendance"> | Date | string
    check_out?: DateTimeNullableFilter<"EmployeeAttendance"> | Date | string | null
    notes?: StringNullableFilter<"EmployeeAttendance"> | string | null
    school_id?: StringNullableFilter<"EmployeeAttendance"> | string | null
    supabase_id?: StringNullableFilter<"EmployeeAttendance"> | string | null
    last_modified?: DateTimeFilter<"EmployeeAttendance"> | Date | string
    needs_sync?: BoolFilter<"EmployeeAttendance"> | boolean
    is_deleted?: BoolFilter<"EmployeeAttendance"> | boolean
    employee?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    teacher?: XOR<TeachersNullableScalarRelationFilter, TeachersWhereInput> | null
  }

  export type EmployeeAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrderInput | SortOrder
    teacher_id?: SortOrderInput | SortOrder
    check_in?: SortOrder
    check_out?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    employee?: EmployeesOrderByWithRelationInput
    teacher?: TeachersOrderByWithRelationInput
  }

  export type EmployeeAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: EmployeeAttendanceWhereInput | EmployeeAttendanceWhereInput[]
    OR?: EmployeeAttendanceWhereInput[]
    NOT?: EmployeeAttendanceWhereInput | EmployeeAttendanceWhereInput[]
    employee_id?: IntNullableFilter<"EmployeeAttendance"> | number | null
    teacher_id?: IntNullableFilter<"EmployeeAttendance"> | number | null
    check_in?: DateTimeFilter<"EmployeeAttendance"> | Date | string
    check_out?: DateTimeNullableFilter<"EmployeeAttendance"> | Date | string | null
    notes?: StringNullableFilter<"EmployeeAttendance"> | string | null
    school_id?: StringNullableFilter<"EmployeeAttendance"> | string | null
    last_modified?: DateTimeFilter<"EmployeeAttendance"> | Date | string
    needs_sync?: BoolFilter<"EmployeeAttendance"> | boolean
    is_deleted?: BoolFilter<"EmployeeAttendance"> | boolean
    employee?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    teacher?: XOR<TeachersNullableScalarRelationFilter, TeachersWhereInput> | null
  }, "id" | "supabase_id">

  export type EmployeeAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrderInput | SortOrder
    teacher_id?: SortOrderInput | SortOrder
    check_in?: SortOrder
    check_out?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: EmployeeAttendanceCountOrderByAggregateInput
    _avg?: EmployeeAttendanceAvgOrderByAggregateInput
    _max?: EmployeeAttendanceMaxOrderByAggregateInput
    _min?: EmployeeAttendanceMinOrderByAggregateInput
    _sum?: EmployeeAttendanceSumOrderByAggregateInput
  }

  export type EmployeeAttendanceScalarWhereWithAggregatesInput = {
    AND?: EmployeeAttendanceScalarWhereWithAggregatesInput | EmployeeAttendanceScalarWhereWithAggregatesInput[]
    OR?: EmployeeAttendanceScalarWhereWithAggregatesInput[]
    NOT?: EmployeeAttendanceScalarWhereWithAggregatesInput | EmployeeAttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeAttendance"> | number
    employee_id?: IntNullableWithAggregatesFilter<"EmployeeAttendance"> | number | null
    teacher_id?: IntNullableWithAggregatesFilter<"EmployeeAttendance"> | number | null
    check_in?: DateTimeWithAggregatesFilter<"EmployeeAttendance"> | Date | string
    check_out?: DateTimeNullableWithAggregatesFilter<"EmployeeAttendance"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"EmployeeAttendance"> | string | null
    school_id?: StringNullableWithAggregatesFilter<"EmployeeAttendance"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"EmployeeAttendance"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"EmployeeAttendance"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"EmployeeAttendance"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"EmployeeAttendance"> | boolean
  }

  export type SettingsCreateInput = {
    schoolName?: string | null
    schoolAddress?: string | null
    loggedIn?: number | null
    userRole?: string | null
    schoolId?: string | null
    userToken?: string | null
    last_sync?: Date | string | null
    activeSchoolYear?: string | null
    roleId?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    schoolYearStartDate?: Date | string | null
    directorName?: string | null
    directorGender?: string | null
    schoolLogo?: string | null
  }

  export type SettingsUncheckedCreateInput = {
    id?: number
    schoolName?: string | null
    schoolAddress?: string | null
    loggedIn?: number | null
    userRole?: string | null
    schoolId?: string | null
    userToken?: string | null
    last_sync?: Date | string | null
    activeSchoolYear?: string | null
    roleId?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    schoolYearStartDate?: Date | string | null
    directorName?: string | null
    directorGender?: string | null
    schoolLogo?: string | null
  }

  export type SettingsUpdateInput = {
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeSchoolYear?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    schoolYearStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorName?: NullableStringFieldUpdateOperationsInput | string | null
    directorGender?: NullableStringFieldUpdateOperationsInput | string | null
    schoolLogo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeSchoolYear?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    schoolYearStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorName?: NullableStringFieldUpdateOperationsInput | string | null
    directorGender?: NullableStringFieldUpdateOperationsInput | string | null
    schoolLogo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsCreateManyInput = {
    id?: number
    schoolName?: string | null
    schoolAddress?: string | null
    loggedIn?: number | null
    userRole?: string | null
    schoolId?: string | null
    userToken?: string | null
    last_sync?: Date | string | null
    activeSchoolYear?: string | null
    roleId?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    schoolYearStartDate?: Date | string | null
    directorName?: string | null
    directorGender?: string | null
    schoolLogo?: string | null
  }

  export type SettingsUpdateManyMutationInput = {
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeSchoolYear?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    schoolYearStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorName?: NullableStringFieldUpdateOperationsInput | string | null
    directorGender?: NullableStringFieldUpdateOperationsInput | string | null
    schoolLogo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeSchoolYear?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    schoolYearStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorName?: NullableStringFieldUpdateOperationsInput | string | null
    directorGender?: NullableStringFieldUpdateOperationsInput | string | null
    schoolLogo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassesCreateInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeUncheckedCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUncheckedUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassesCreateManyInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type ClassesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentsCreateInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    notes?: NotesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    notes?: NotesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentsCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
  }

  export type StudentsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegistrationsCreateInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutRegistrationInput
    class: ClassesCreateNestedOneWithoutRegistrationsInput
    student: StudentsCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateInput = {
    id?: number
    student_id: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type RegistrationsUpdateInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutRegistrationNestedInput
    class?: ClassesUpdateOneRequiredWithoutRegistrationsNestedInput
    student?: StudentsUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type RegistrationsCreateManyInput = {
    id?: number
    student_id: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsUpdateManyMutationInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegistrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeachersCreateInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsCreateNestedManyWithoutTeacherInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutTeacherInput
    attendances?: EmployeeAttendanceCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsUncheckedCreateNestedManyWithoutTeacherInput
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutTeacherInput
    attendances?: EmployeeAttendanceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUpdateManyWithoutTeacherNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutTeacherNestedInput
    attendances?: EmployeeAttendanceUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUncheckedUpdateManyWithoutTeacherNestedInput
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutTeacherNestedInput
    attendances?: EmployeeAttendanceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
  }

  export type TeachersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeacherWorkHoursCreateInput = {
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: SubjectsCreateNestedOneWithoutWorkHoursInput
    teacher: TeachersCreateNestedOneWithoutWorkHoursInput
  }

  export type TeacherWorkHoursUncheckedCreateInput = {
    id?: number
    teacher_id: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneWithoutWorkHoursNestedInput
    teacher?: TeachersUpdateOneRequiredWithoutWorkHoursNestedInput
  }

  export type TeacherWorkHoursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursCreateManyInput = {
    id?: number
    teacher_id: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsCreateInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsUpdateInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsCreateManyInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateManyMutationInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubjectsCreateInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutSubjectInput
    class: ClassesCreateNestedOneWithoutSubjectsInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUncheckedCreateInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutSubjectInput
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutSubjectNestedInput
    class?: ClassesUpdateOneRequiredWithoutSubjectsNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutSubjectNestedInput
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsCreateManyInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SubjectsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubjectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesCreateInput = {
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lesson: LessonsCreateNestedOneWithoutNotesInput
    student: StudentsCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateInput = {
    id?: number
    student_id: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesUpdateInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson?: LessonsUpdateOneRequiredWithoutNotesNestedInput
    student?: StudentsUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesCreateManyInput = {
    id?: number
    student_id: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesUpdateManyMutationInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParentsCreateInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
    student_parents?: StudentParentsCreateNestedManyWithoutParentInput
  }

  export type ParentsUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    student_parents?: StudentParentsUpdateManyWithoutParentNestedInput
  }

  export type ParentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    student_parents?: StudentParentsUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentsCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
  }

  export type ParentsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentParentsCreateInput = {
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    parent: ParentsCreateNestedOneWithoutStudent_parentsInput
    student: StudentsCreateNestedOneWithoutStudent_parentsInput
  }

  export type StudentParentsUncheckedCreateInput = {
    id?: number
    student_id: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsUpdateInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    parent?: ParentsUpdateOneRequiredWithoutStudent_parentsNestedInput
    student?: StudentsUpdateOneRequiredWithoutStudent_parentsNestedInput
  }

  export type StudentParentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsCreateManyInput = {
    id?: number
    student_id: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsUpdateManyMutationInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateInput = {
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    period_identifier?: string | null
    registration?: RegistrationsCreateNestedOneWithoutPaymentsInput
    single_fee?: SingleFeeCreateNestedOneWithoutPaymentsInput
    fee_template?: FeeTemplateCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: number | null
    fee_template_id?: number | null
    period_identifier?: string | null
  }

  export type PaymentsUpdateInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    registration?: RegistrationsUpdateOneWithoutPaymentsNestedInput
    single_fee?: SingleFeeUpdateOneWithoutPaymentsNestedInput
    fee_template?: FeeTemplateUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    single_fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    fee_template_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsCreateManyInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: number | null
    fee_template_id?: number | null
    period_identifier?: string | null
  }

  export type PaymentsUpdateManyMutationInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    single_fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    fee_template_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SingleFeeCreateInput = {
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class?: ClassesCreateNestedOneWithoutSingle_feesInput
    payments?: PaymentsCreateNestedManyWithoutSingle_feeInput
    dispatch_rules?: DispatchRuleCreateNestedManyWithoutSource_single_feeInput
  }

  export type SingleFeeUncheckedCreateInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    class_id?: number | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutSingle_feeInput
    dispatch_rules?: DispatchRuleUncheckedCreateNestedManyWithoutSource_single_feeInput
  }

  export type SingleFeeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneWithoutSingle_feesNestedInput
    payments?: PaymentsUpdateManyWithoutSingle_feeNestedInput
    dispatch_rules?: DispatchRuleUpdateManyWithoutSource_single_feeNestedInput
  }

  export type SingleFeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    class_id?: NullableIntFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutSingle_feeNestedInput
    dispatch_rules?: DispatchRuleUncheckedUpdateManyWithoutSource_single_feeNestedInput
  }

  export type SingleFeeCreateManyInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    class_id?: number | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SingleFeeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SingleFeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    class_id?: NullableIntFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeeTemplateCreateInput = {
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class?: ClassesCreateNestedOneWithoutFee_templatesInput
    payments?: PaymentsCreateNestedManyWithoutFee_templateInput
  }

  export type FeeTemplateUncheckedCreateInput = {
    id?: number
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    applies_to_class_id?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutFee_templateInput
  }

  export type FeeTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneWithoutFee_templatesNestedInput
    payments?: PaymentsUpdateManyWithoutFee_templateNestedInput
  }

  export type FeeTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutFee_templateNestedInput
  }

  export type FeeTemplateCreateManyInput = {
    id?: number
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    applies_to_class_id?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeeTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeeTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesCreateInput = {
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    student: StudentsCreateNestedOneWithoutAttendancesInput
  }

  export type AttendancesUncheckedCreateInput = {
    id?: number
    student_id: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentsUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendancesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesCreateManyInput = {
    id?: number
    student_id: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesCreateInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: SalaryPaymentsCreateNestedManyWithoutEmployeeInput
    attendances?: EmployeeAttendanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: SalaryPaymentsUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: EmployeeAttendanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    salary_payments?: SalaryPaymentsUpdateManyWithoutEmployeeNestedInput
    attendances?: EmployeeAttendanceUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    salary_payments?: SalaryPaymentsUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: EmployeeAttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsCreateInput = {
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    employee: EmployeesCreateNestedOneWithoutSalary_paymentsInput
  }

  export type SalaryPaymentsUncheckedCreateInput = {
    id?: number
    employee_id: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUpdateInput = {
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    employee?: EmployeesUpdateOneRequiredWithoutSalary_paymentsNestedInput
  }

  export type SalaryPaymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsCreateManyInput = {
    id?: number
    employee_id: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUpdateManyMutationInput = {
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesCreateInput = {
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lesson: LessonsCreateNestedOneWithoutSchedulesInput
  }

  export type SchedulesUncheckedCreateInput = {
    id?: number
    lesson_id: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesUpdateInput = {
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson?: LessonsUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type SchedulesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesCreateManyInput = {
    id?: number
    lesson_id: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesUpdateManyMutationInput = {
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialCategoryCreateInput = {
    name: string
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    transactions?: FinancialTransactionCreateNestedManyWithoutCategoryInput
    dispatch_rule_details?: DispatchRuleDetailCreateNestedManyWithoutDestination_categoryInput
  }

  export type FinancialCategoryUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutCategoryInput
    dispatch_rule_details?: DispatchRuleDetailUncheckedCreateNestedManyWithoutDestination_categoryInput
  }

  export type FinancialCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    transactions?: FinancialTransactionUpdateManyWithoutCategoryNestedInput
    dispatch_rule_details?: DispatchRuleDetailUpdateManyWithoutDestination_categoryNestedInput
  }

  export type FinancialCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    dispatch_rule_details?: DispatchRuleDetailUncheckedUpdateManyWithoutDestination_categoryNestedInput
  }

  export type FinancialCategoryCreateManyInput = {
    id?: number
    name: string
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialTransactionCreateInput = {
    date: Date | string
    description: string
    amount: number
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    category: FinancialCategoryCreateNestedOneWithoutTransactionsInput
  }

  export type FinancialTransactionUncheckedCreateInput = {
    id?: number
    date: Date | string
    description: string
    amount: number
    type: string
    category_id: number
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialTransactionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    category?: FinancialCategoryUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type FinancialTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialTransactionCreateManyInput = {
    id?: number
    date: Date | string
    description: string
    amount: number
    type: string
    category_id: number
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialTransactionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BudgetCreateInput = {
    category: string
    amount: number
    period_start: Date | string
    period_end: Date | string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type BudgetUncheckedCreateInput = {
    id?: number
    category: string
    amount: number
    period_start: Date | string
    period_end: Date | string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type BudgetUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BudgetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BudgetCreateManyInput = {
    id?: number
    category: string
    amount: number
    period_start: Date | string
    period_end: Date | string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type BudgetUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialReportCreateInput = {
    title: string
    generated_at: Date | string
    start_date: Date | string
    end_date: Date | string
    content: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialReportUncheckedCreateInput = {
    id?: number
    title: string
    generated_at: Date | string
    start_date: Date | string
    end_date: Date | string
    content: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialReportUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialReportCreateManyInput = {
    id?: number
    title: string
    generated_at: Date | string
    start_date: Date | string
    end_date: Date | string
    content: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialReportUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleCreateInput = {
    name: string
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    source_single_fee: SingleFeeCreateNestedOneWithoutDispatch_rulesInput
    details?: DispatchRuleDetailCreateNestedManyWithoutDispatch_ruleInput
  }

  export type DispatchRuleUncheckedCreateInput = {
    id?: number
    name: string
    source_single_fee_id: number
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    details?: DispatchRuleDetailUncheckedCreateNestedManyWithoutDispatch_ruleInput
  }

  export type DispatchRuleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    source_single_fee?: SingleFeeUpdateOneRequiredWithoutDispatch_rulesNestedInput
    details?: DispatchRuleDetailUpdateManyWithoutDispatch_ruleNestedInput
  }

  export type DispatchRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    source_single_fee_id?: IntFieldUpdateOperationsInput | number
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    details?: DispatchRuleDetailUncheckedUpdateManyWithoutDispatch_ruleNestedInput
  }

  export type DispatchRuleCreateManyInput = {
    id?: number
    name: string
    source_single_fee_id: number
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    source_single_fee_id?: IntFieldUpdateOperationsInput | number
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleDetailCreateInput = {
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rule: DispatchRuleCreateNestedOneWithoutDetailsInput
    destination_category: FinancialCategoryCreateNestedOneWithoutDispatch_rule_detailsInput
  }

  export type DispatchRuleDetailUncheckedCreateInput = {
    id?: number
    dispatch_rule_id: number
    destination_category_id: number
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleDetailUpdateInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    dispatch_rule?: DispatchRuleUpdateOneRequiredWithoutDetailsNestedInput
    destination_category?: FinancialCategoryUpdateOneRequiredWithoutDispatch_rule_detailsNestedInput
  }

  export type DispatchRuleDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispatch_rule_id?: IntFieldUpdateOperationsInput | number
    destination_category_id?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleDetailCreateManyInput = {
    id?: number
    dispatch_rule_id: number
    destination_category_id: number
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleDetailUpdateManyMutationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispatch_rule_id?: IntFieldUpdateOperationsInput | number
    destination_category_id?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventsCreateInput = {
    title: string
    description?: string | null
    date: Date | string
    location?: string | null
    image_url?: string | null
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EventsUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    location?: string | null
    image_url?: string | null
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EventsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventsCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    location?: string | null
    image_url?: string | null
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EventsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeAttendanceCreateInput = {
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: EmployeesCreateNestedOneWithoutAttendancesInput
    teacher?: TeachersCreateNestedOneWithoutAttendancesInput
  }

  export type EmployeeAttendanceUncheckedCreateInput = {
    id?: number
    employee_id?: number | null
    teacher_id?: number | null
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeeAttendanceUpdateInput = {
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    employee?: EmployeesUpdateOneWithoutAttendancesNestedInput
    teacher?: TeachersUpdateOneWithoutAttendancesNestedInput
  }

  export type EmployeeAttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeAttendanceCreateManyInput = {
    id?: number
    employee_id?: number | null
    teacher_id?: number | null
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeeAttendanceUpdateManyMutationInput = {
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeAttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    schoolAddress?: SortOrder
    loggedIn?: SortOrder
    userRole?: SortOrder
    schoolId?: SortOrder
    userToken?: SortOrder
    last_sync?: SortOrder
    activeSchoolYear?: SortOrder
    roleId?: SortOrder
    permissions?: SortOrder
    schoolYearStartDate?: SortOrder
    directorName?: SortOrder
    directorGender?: SortOrder
    schoolLogo?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    loggedIn?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    schoolAddress?: SortOrder
    loggedIn?: SortOrder
    userRole?: SortOrder
    schoolId?: SortOrder
    userToken?: SortOrder
    last_sync?: SortOrder
    activeSchoolYear?: SortOrder
    roleId?: SortOrder
    schoolYearStartDate?: SortOrder
    directorName?: SortOrder
    directorGender?: SortOrder
    schoolLogo?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    schoolAddress?: SortOrder
    loggedIn?: SortOrder
    userRole?: SortOrder
    schoolId?: SortOrder
    userToken?: SortOrder
    last_sync?: SortOrder
    activeSchoolYear?: SortOrder
    roleId?: SortOrder
    schoolYearStartDate?: SortOrder
    directorName?: SortOrder
    directorGender?: SortOrder
    schoolLogo?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    id?: SortOrder
    loggedIn?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LessonsListRelationFilter = {
    every?: LessonsWhereInput
    some?: LessonsWhereInput
    none?: LessonsWhereInput
  }

  export type RegistrationsListRelationFilter = {
    every?: RegistrationsWhereInput
    some?: RegistrationsWhereInput
    none?: RegistrationsWhereInput
  }

  export type SubjectsListRelationFilter = {
    every?: SubjectsWhereInput
    some?: SubjectsWhereInput
    none?: SubjectsWhereInput
  }

  export type SingleFeeListRelationFilter = {
    every?: SingleFeeWhereInput
    some?: SingleFeeWhereInput
    none?: SingleFeeWhereInput
  }

  export type FeeTemplateListRelationFilter = {
    every?: FeeTemplateWhereInput
    some?: FeeTemplateWhereInput
    none?: FeeTemplateWhereInput
  }

  export type LessonsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegistrationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SingleFeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type ClassesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClassesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type ClassesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type ClassesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AttendancesListRelationFilter = {
    every?: AttendancesWhereInput
    some?: AttendancesWhereInput
    none?: AttendancesWhereInput
  }

  export type NotesListRelationFilter = {
    every?: NotesWhereInput
    some?: NotesWhereInput
    none?: NotesWhereInput
  }

  export type StudentParentsListRelationFilter = {
    every?: StudentParentsWhereInput
    some?: StudentParentsWhereInput
    none?: StudentParentsWhereInput
  }

  export type AttendancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentParentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    genre?: SortOrder
    birth_date?: SortOrder
    picture_url?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrder
  }

  export type StudentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StudentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    genre?: SortOrder
    birth_date?: SortOrder
    picture_url?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrder
  }

  export type StudentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    genre?: SortOrder
    birth_date?: SortOrder
    picture_url?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrder
  }

  export type StudentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaymentsListRelationFilter = {
    every?: PaymentsWhereInput
    some?: PaymentsWhereInput
    none?: PaymentsWhereInput
  }

  export type ClassesScalarRelationFilter = {
    is?: ClassesWhereInput
    isNot?: ClassesWhereInput
  }

  export type StudentsScalarRelationFilter = {
    is?: StudentsWhereInput
    isNot?: StudentsWhereInput
  }

  export type PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegistrationsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    state?: SortOrder
    registration_date?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type RegistrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
  }

  export type RegistrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    state?: SortOrder
    registration_date?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type RegistrationsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    state?: SortOrder
    registration_date?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type RegistrationsSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TeacherWorkHoursListRelationFilter = {
    every?: TeacherWorkHoursWhereInput
    some?: TeacherWorkHoursWhereInput
    none?: TeacherWorkHoursWhereInput
  }

  export type EmployeeAttendanceListRelationFilter = {
    every?: EmployeeAttendanceWhereInput
    some?: EmployeeAttendanceWhereInput
    none?: EmployeeAttendanceWhereInput
  }

  export type TeacherWorkHoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeachersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    password_hash?: SortOrder
    role_id?: SortOrder
    speciality?: SortOrder
    matricule?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrder
    school_id?: SortOrder
  }

  export type TeachersAvgOrderByAggregateInput = {
    id?: SortOrder
    hourlyRate?: SortOrder
  }

  export type TeachersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    password_hash?: SortOrder
    role_id?: SortOrder
    speciality?: SortOrder
    matricule?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrder
    school_id?: SortOrder
  }

  export type TeachersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    password_hash?: SortOrder
    role_id?: SortOrder
    speciality?: SortOrder
    matricule?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrder
    school_id?: SortOrder
  }

  export type TeachersSumOrderByAggregateInput = {
    id?: SortOrder
    hourlyRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SubjectsNullableScalarRelationFilter = {
    is?: SubjectsWhereInput | null
    isNot?: SubjectsWhereInput | null
  }

  export type TeachersScalarRelationFilter = {
    is?: TeachersWhereInput
    isNot?: TeachersWhereInput
  }

  export type TeacherWorkHoursCountOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    hours?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type TeacherWorkHoursAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    hours?: SortOrder
  }

  export type TeacherWorkHoursMaxOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    hours?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type TeacherWorkHoursMinOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    hours?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type TeacherWorkHoursSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    hours?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SubjectsScalarRelationFilter = {
    is?: SubjectsWhereInput
    isNot?: SubjectsWhereInput
  }

  export type TeachersNullableScalarRelationFilter = {
    is?: TeachersWhereInput | null
    isNot?: TeachersWhereInput | null
  }

  export type SchedulesListRelationFilter = {
    every?: SchedulesWhereInput
    some?: SchedulesWhereInput
    none?: SchedulesWhereInput
  }

  export type SchedulesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonsCountOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type LessonsAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
  }

  export type LessonsMaxOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type LessonsMinOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type LessonsSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
  }

  export type SubjectsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    coefficient?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SubjectsAvgOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
    coefficient?: SortOrder
  }

  export type SubjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    coefficient?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SubjectsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    coefficient?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SubjectsSumOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
    coefficient?: SortOrder
  }

  export type LessonsScalarRelationFilter = {
    is?: LessonsWhereInput
    isNot?: LessonsWhereInput
  }

  export type NotesStudent_idLesson_idQuarterTypeCompoundUniqueInput = {
    student_id: number
    lesson_id: number
    quarter: number
    type: string
  }

  export type NotesCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    type?: SortOrder
    quarter?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type NotesAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    quarter?: SortOrder
  }

  export type NotesMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    type?: SortOrder
    quarter?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type NotesMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    type?: SortOrder
    quarter?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type NotesSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    quarter?: SortOrder
  }

  export type ParentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    profession?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrder
  }

  export type ParentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    profession?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrder
  }

  export type ParentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    profession?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrder
  }

  export type ParentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParentsScalarRelationFilter = {
    is?: ParentsWhereInput
    isNot?: ParentsWhereInput
  }

  export type StudentParentsStudent_id_parent_id_uniqueCompoundUniqueInput = {
    student_id: number
    parent_id: number
  }

  export type StudentParentsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type StudentParentsAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
  }

  export type StudentParentsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type StudentParentsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type StudentParentsSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
  }

  export type RegistrationsNullableScalarRelationFilter = {
    is?: RegistrationsWhereInput | null
    isNot?: RegistrationsWhereInput | null
  }

  export type SingleFeeNullableScalarRelationFilter = {
    is?: SingleFeeWhereInput | null
    isNot?: SingleFeeWhereInput | null
  }

  export type FeeTemplateNullableScalarRelationFilter = {
    is?: FeeTemplateWhereInput | null
    isNot?: FeeTemplateWhereInput | null
  }

  export type PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    emitter_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    single_fee_id?: SortOrder
    fee_template_id?: SortOrder
    period_identifier?: SortOrder
  }

  export type PaymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    amount?: SortOrder
    single_fee_id?: SortOrder
    fee_template_id?: SortOrder
  }

  export type PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    emitter_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    single_fee_id?: SortOrder
    fee_template_id?: SortOrder
    period_identifier?: SortOrder
  }

  export type PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    emitter_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    single_fee_id?: SortOrder
    fee_template_id?: SortOrder
    period_identifier?: SortOrder
  }

  export type PaymentsSumOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    amount?: SortOrder
    single_fee_id?: SortOrder
    fee_template_id?: SortOrder
  }

  export type ClassesNullableScalarRelationFilter = {
    is?: ClassesWhereInput | null
    isNot?: ClassesWhereInput | null
  }

  export type DispatchRuleListRelationFilter = {
    every?: DispatchRuleWhereInput
    some?: DispatchRuleWhereInput
    none?: DispatchRuleWhereInput
  }

  export type DispatchRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SingleFeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    school_year?: SortOrder
    level?: SortOrder
    class_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SingleFeeAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    class_id?: SortOrder
  }

  export type SingleFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    school_year?: SortOrder
    level?: SortOrder
    class_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SingleFeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    school_year?: SortOrder
    level?: SortOrder
    class_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SingleFeeSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    class_id?: SortOrder
  }

  export type FeeTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    due_day?: SortOrder
    applicable_months?: SortOrder
    school_id?: SortOrder
    applies_to_level?: SortOrder
    applies_to_class_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FeeTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    due_day?: SortOrder
    applies_to_class_id?: SortOrder
  }

  export type FeeTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    due_day?: SortOrder
    school_id?: SortOrder
    applies_to_level?: SortOrder
    applies_to_class_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FeeTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    due_day?: SortOrder
    school_id?: SortOrder
    applies_to_level?: SortOrder
    applies_to_class_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FeeTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    due_day?: SortOrder
    applies_to_class_id?: SortOrder
  }

  export type AttendancesCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrder
    state?: SortOrder
    justification?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type AttendancesAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
  }

  export type AttendancesMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrder
    state?: SortOrder
    justification?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type AttendancesMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrder
    state?: SortOrder
    justification?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type AttendancesSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
  }

  export type SalaryPaymentsListRelationFilter = {
    every?: SalaryPaymentsWhereInput
    some?: SalaryPaymentsWhereInput
    none?: SalaryPaymentsWhereInput
  }

  export type SalaryPaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    job_title?: SortOrder
    salary?: SortOrder
    matricule?: SortOrder
    school_id?: SortOrder
    password_hash?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeesAvgOrderByAggregateInput = {
    id?: SortOrder
    salary?: SortOrder
  }

  export type EmployeesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    job_title?: SortOrder
    salary?: SortOrder
    matricule?: SortOrder
    school_id?: SortOrder
    password_hash?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    job_title?: SortOrder
    salary?: SortOrder
    matricule?: SortOrder
    school_id?: SortOrder
    password_hash?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeesSumOrderByAggregateInput = {
    id?: SortOrder
    salary?: SortOrder
  }

  export type EmployeesScalarRelationFilter = {
    is?: EmployeesWhereInput
    isNot?: EmployeesWhereInput
  }

  export type SalaryPaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SalaryPaymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type SalaryPaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SalaryPaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SalaryPaymentsSumOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type SchedulesCountOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SchedulesAvgOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
  }

  export type SchedulesMaxOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SchedulesMinOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SchedulesSumOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
  }

  export type FinancialTransactionListRelationFilter = {
    every?: FinancialTransactionWhereInput
    some?: FinancialTransactionWhereInput
    none?: FinancialTransactionWhereInput
  }

  export type DispatchRuleDetailListRelationFilter = {
    every?: DispatchRuleDetailWhereInput
    some?: DispatchRuleDetailWhereInput
    none?: DispatchRuleDetailWhereInput
  }

  export type FinancialTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DispatchRuleDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FinancialCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FinancialCategoryScalarRelationFilter = {
    is?: FinancialCategoryWhereInput
    isNot?: FinancialCategoryWhereInput
  }

  export type FinancialTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    category_id?: SortOrder
  }

  export type FinancialTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    category_id?: SortOrder
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type FinancialReportCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    generated_at?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    content?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialReportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FinancialReportMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    generated_at?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    content?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialReportMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    generated_at?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    content?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FinancialReportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SingleFeeScalarRelationFilter = {
    is?: SingleFeeWhereInput
    isNot?: SingleFeeWhereInput
  }

  export type DispatchRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source_single_fee_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type DispatchRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    source_single_fee_id?: SortOrder
  }

  export type DispatchRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source_single_fee_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type DispatchRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source_single_fee_id?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type DispatchRuleSumOrderByAggregateInput = {
    id?: SortOrder
    source_single_fee_id?: SortOrder
  }

  export type DispatchRuleScalarRelationFilter = {
    is?: DispatchRuleWhereInput
    isNot?: DispatchRuleWhereInput
  }

  export type DispatchRuleDetailCountOrderByAggregateInput = {
    id?: SortOrder
    dispatch_rule_id?: SortOrder
    destination_category_id?: SortOrder
    percentage?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type DispatchRuleDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    dispatch_rule_id?: SortOrder
    destination_category_id?: SortOrder
    percentage?: SortOrder
  }

  export type DispatchRuleDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    dispatch_rule_id?: SortOrder
    destination_category_id?: SortOrder
    percentage?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type DispatchRuleDetailMinOrderByAggregateInput = {
    id?: SortOrder
    dispatch_rule_id?: SortOrder
    destination_category_id?: SortOrder
    percentage?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type DispatchRuleDetailSumOrderByAggregateInput = {
    id?: SortOrder
    dispatch_rule_id?: SortOrder
    destination_category_id?: SortOrder
    percentage?: SortOrder
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    location?: SortOrder
    image_url?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EventsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    location?: SortOrder
    image_url?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    location?: SortOrder
    image_url?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EventsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeesNullableScalarRelationFilter = {
    is?: EmployeesWhereInput | null
    isNot?: EmployeesWhereInput | null
  }

  export type EmployeeAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    teacher_id?: SortOrder
    check_in?: SortOrder
    check_out?: SortOrder
    notes?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeeAttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type EmployeeAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    teacher_id?: SortOrder
    check_in?: SortOrder
    check_out?: SortOrder
    notes?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeeAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    teacher_id?: SortOrder
    check_in?: SortOrder
    check_out?: SortOrder
    notes?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeeAttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LessonsCreateNestedManyWithoutClassInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type RegistrationsCreateNestedManyWithoutClassInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type SubjectsCreateNestedManyWithoutClassInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
  }

  export type SingleFeeCreateNestedManyWithoutClassInput = {
    create?: XOR<SingleFeeCreateWithoutClassInput, SingleFeeUncheckedCreateWithoutClassInput> | SingleFeeCreateWithoutClassInput[] | SingleFeeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SingleFeeCreateOrConnectWithoutClassInput | SingleFeeCreateOrConnectWithoutClassInput[]
    createMany?: SingleFeeCreateManyClassInputEnvelope
    connect?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
  }

  export type FeeTemplateCreateNestedManyWithoutClassInput = {
    create?: XOR<FeeTemplateCreateWithoutClassInput, FeeTemplateUncheckedCreateWithoutClassInput> | FeeTemplateCreateWithoutClassInput[] | FeeTemplateUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeeTemplateCreateOrConnectWithoutClassInput | FeeTemplateCreateOrConnectWithoutClassInput[]
    createMany?: FeeTemplateCreateManyClassInputEnvelope
    connect?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
  }

  export type LessonsUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type RegistrationsUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type SubjectsUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
  }

  export type SingleFeeUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SingleFeeCreateWithoutClassInput, SingleFeeUncheckedCreateWithoutClassInput> | SingleFeeCreateWithoutClassInput[] | SingleFeeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SingleFeeCreateOrConnectWithoutClassInput | SingleFeeCreateOrConnectWithoutClassInput[]
    createMany?: SingleFeeCreateManyClassInputEnvelope
    connect?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
  }

  export type FeeTemplateUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<FeeTemplateCreateWithoutClassInput, FeeTemplateUncheckedCreateWithoutClassInput> | FeeTemplateCreateWithoutClassInput[] | FeeTemplateUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeeTemplateCreateOrConnectWithoutClassInput | FeeTemplateCreateOrConnectWithoutClassInput[]
    createMany?: FeeTemplateCreateManyClassInputEnvelope
    connect?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type LessonsUpdateManyWithoutClassNestedInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutClassInput | LessonsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutClassInput | LessonsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutClassInput | LessonsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type RegistrationsUpdateManyWithoutClassNestedInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutClassInput | RegistrationsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutClassInput | RegistrationsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutClassInput | RegistrationsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type SubjectsUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    upsert?: SubjectsUpsertWithWhereUniqueWithoutClassInput | SubjectsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    set?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    disconnect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    delete?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    update?: SubjectsUpdateWithWhereUniqueWithoutClassInput | SubjectsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubjectsUpdateManyWithWhereWithoutClassInput | SubjectsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
  }

  export type SingleFeeUpdateManyWithoutClassNestedInput = {
    create?: XOR<SingleFeeCreateWithoutClassInput, SingleFeeUncheckedCreateWithoutClassInput> | SingleFeeCreateWithoutClassInput[] | SingleFeeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SingleFeeCreateOrConnectWithoutClassInput | SingleFeeCreateOrConnectWithoutClassInput[]
    upsert?: SingleFeeUpsertWithWhereUniqueWithoutClassInput | SingleFeeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SingleFeeCreateManyClassInputEnvelope
    set?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    disconnect?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    delete?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    connect?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    update?: SingleFeeUpdateWithWhereUniqueWithoutClassInput | SingleFeeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SingleFeeUpdateManyWithWhereWithoutClassInput | SingleFeeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SingleFeeScalarWhereInput | SingleFeeScalarWhereInput[]
  }

  export type FeeTemplateUpdateManyWithoutClassNestedInput = {
    create?: XOR<FeeTemplateCreateWithoutClassInput, FeeTemplateUncheckedCreateWithoutClassInput> | FeeTemplateCreateWithoutClassInput[] | FeeTemplateUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeeTemplateCreateOrConnectWithoutClassInput | FeeTemplateCreateOrConnectWithoutClassInput[]
    upsert?: FeeTemplateUpsertWithWhereUniqueWithoutClassInput | FeeTemplateUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: FeeTemplateCreateManyClassInputEnvelope
    set?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    disconnect?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    delete?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    connect?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    update?: FeeTemplateUpdateWithWhereUniqueWithoutClassInput | FeeTemplateUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: FeeTemplateUpdateManyWithWhereWithoutClassInput | FeeTemplateUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: FeeTemplateScalarWhereInput | FeeTemplateScalarWhereInput[]
  }

  export type LessonsUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutClassInput | LessonsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutClassInput | LessonsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutClassInput | LessonsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type RegistrationsUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutClassInput | RegistrationsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutClassInput | RegistrationsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutClassInput | RegistrationsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type SubjectsUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    upsert?: SubjectsUpsertWithWhereUniqueWithoutClassInput | SubjectsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    set?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    disconnect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    delete?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    update?: SubjectsUpdateWithWhereUniqueWithoutClassInput | SubjectsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubjectsUpdateManyWithWhereWithoutClassInput | SubjectsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
  }

  export type SingleFeeUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SingleFeeCreateWithoutClassInput, SingleFeeUncheckedCreateWithoutClassInput> | SingleFeeCreateWithoutClassInput[] | SingleFeeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SingleFeeCreateOrConnectWithoutClassInput | SingleFeeCreateOrConnectWithoutClassInput[]
    upsert?: SingleFeeUpsertWithWhereUniqueWithoutClassInput | SingleFeeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SingleFeeCreateManyClassInputEnvelope
    set?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    disconnect?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    delete?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    connect?: SingleFeeWhereUniqueInput | SingleFeeWhereUniqueInput[]
    update?: SingleFeeUpdateWithWhereUniqueWithoutClassInput | SingleFeeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SingleFeeUpdateManyWithWhereWithoutClassInput | SingleFeeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SingleFeeScalarWhereInput | SingleFeeScalarWhereInput[]
  }

  export type FeeTemplateUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<FeeTemplateCreateWithoutClassInput, FeeTemplateUncheckedCreateWithoutClassInput> | FeeTemplateCreateWithoutClassInput[] | FeeTemplateUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeeTemplateCreateOrConnectWithoutClassInput | FeeTemplateCreateOrConnectWithoutClassInput[]
    upsert?: FeeTemplateUpsertWithWhereUniqueWithoutClassInput | FeeTemplateUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: FeeTemplateCreateManyClassInputEnvelope
    set?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    disconnect?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    delete?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    connect?: FeeTemplateWhereUniqueInput | FeeTemplateWhereUniqueInput[]
    update?: FeeTemplateUpdateWithWhereUniqueWithoutClassInput | FeeTemplateUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: FeeTemplateUpdateManyWithWhereWithoutClassInput | FeeTemplateUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: FeeTemplateScalarWhereInput | FeeTemplateScalarWhereInput[]
  }

  export type AttendancesCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
  }

  export type NotesCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type RegistrationsCreateNestedManyWithoutStudentInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type StudentParentsCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type AttendancesUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
  }

  export type NotesUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type RegistrationsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type StudentParentsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type AttendancesUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    upsert?: AttendancesUpsertWithWhereUniqueWithoutStudentInput | AttendancesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    set?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    disconnect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    delete?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    update?: AttendancesUpdateWithWhereUniqueWithoutStudentInput | AttendancesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendancesUpdateManyWithWhereWithoutStudentInput | AttendancesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
  }

  export type NotesUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutStudentInput | NotesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutStudentInput | NotesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutStudentInput | NotesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type RegistrationsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutStudentInput | RegistrationsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutStudentInput | RegistrationsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutStudentInput | RegistrationsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type StudentParentsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutStudentInput | StudentParentsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutStudentInput | StudentParentsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutStudentInput | StudentParentsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type AttendancesUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    upsert?: AttendancesUpsertWithWhereUniqueWithoutStudentInput | AttendancesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    set?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    disconnect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    delete?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    update?: AttendancesUpdateWithWhereUniqueWithoutStudentInput | AttendancesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendancesUpdateManyWithWhereWithoutStudentInput | AttendancesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
  }

  export type NotesUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutStudentInput | NotesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutStudentInput | NotesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutStudentInput | NotesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type RegistrationsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutStudentInput | RegistrationsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutStudentInput | RegistrationsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutStudentInput | RegistrationsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type StudentParentsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutStudentInput | StudentParentsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutStudentInput | StudentParentsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutStudentInput | StudentParentsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type PaymentsCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ClassesCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutRegistrationsInput
    connect?: ClassesWhereUniqueInput
  }

  export type StudentsCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutRegistrationsInput
    connect?: StudentsWhereUniqueInput
  }

  export type PaymentsUncheckedCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentsUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutRegistrationInput | PaymentsUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutRegistrationInput | PaymentsUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutRegistrationInput | PaymentsUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ClassesUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutRegistrationsInput
    upsert?: ClassesUpsertWithoutRegistrationsInput
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutRegistrationsInput, ClassesUpdateWithoutRegistrationsInput>, ClassesUncheckedUpdateWithoutRegistrationsInput>
  }

  export type StudentsUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutRegistrationsInput
    upsert?: StudentsUpsertWithoutRegistrationsInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutRegistrationsInput, StudentsUpdateWithoutRegistrationsInput>, StudentsUncheckedUpdateWithoutRegistrationsInput>
  }

  export type PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutRegistrationInput | PaymentsUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutRegistrationInput | PaymentsUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutRegistrationInput | PaymentsUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type LessonsCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type TeacherWorkHoursCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type EmployeeAttendanceCreateNestedManyWithoutTeacherInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutTeacherInput, EmployeeAttendanceUncheckedCreateWithoutTeacherInput> | EmployeeAttendanceCreateWithoutTeacherInput[] | EmployeeAttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutTeacherInput | EmployeeAttendanceCreateOrConnectWithoutTeacherInput[]
    createMany?: EmployeeAttendanceCreateManyTeacherInputEnvelope
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
  }

  export type LessonsUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type TeacherWorkHoursUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type EmployeeAttendanceUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutTeacherInput, EmployeeAttendanceUncheckedCreateWithoutTeacherInput> | EmployeeAttendanceCreateWithoutTeacherInput[] | EmployeeAttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutTeacherInput | EmployeeAttendanceCreateOrConnectWithoutTeacherInput[]
    createMany?: EmployeeAttendanceCreateManyTeacherInputEnvelope
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LessonsUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutTeacherInput | LessonsUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutTeacherInput | LessonsUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutTeacherInput | LessonsUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type TeacherWorkHoursUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput | TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type EmployeeAttendanceUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutTeacherInput, EmployeeAttendanceUncheckedCreateWithoutTeacherInput> | EmployeeAttendanceCreateWithoutTeacherInput[] | EmployeeAttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutTeacherInput | EmployeeAttendanceCreateOrConnectWithoutTeacherInput[]
    upsert?: EmployeeAttendanceUpsertWithWhereUniqueWithoutTeacherInput | EmployeeAttendanceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: EmployeeAttendanceCreateManyTeacherInputEnvelope
    set?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    disconnect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    delete?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    update?: EmployeeAttendanceUpdateWithWhereUniqueWithoutTeacherInput | EmployeeAttendanceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: EmployeeAttendanceUpdateManyWithWhereWithoutTeacherInput | EmployeeAttendanceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: EmployeeAttendanceScalarWhereInput | EmployeeAttendanceScalarWhereInput[]
  }

  export type LessonsUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutTeacherInput | LessonsUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutTeacherInput | LessonsUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutTeacherInput | LessonsUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput | TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type EmployeeAttendanceUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutTeacherInput, EmployeeAttendanceUncheckedCreateWithoutTeacherInput> | EmployeeAttendanceCreateWithoutTeacherInput[] | EmployeeAttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutTeacherInput | EmployeeAttendanceCreateOrConnectWithoutTeacherInput[]
    upsert?: EmployeeAttendanceUpsertWithWhereUniqueWithoutTeacherInput | EmployeeAttendanceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: EmployeeAttendanceCreateManyTeacherInputEnvelope
    set?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    disconnect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    delete?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    update?: EmployeeAttendanceUpdateWithWhereUniqueWithoutTeacherInput | EmployeeAttendanceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: EmployeeAttendanceUpdateManyWithWhereWithoutTeacherInput | EmployeeAttendanceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: EmployeeAttendanceScalarWhereInput | EmployeeAttendanceScalarWhereInput[]
  }

  export type SubjectsCreateNestedOneWithoutWorkHoursInput = {
    create?: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutWorkHoursInput
    connect?: SubjectsWhereUniqueInput
  }

  export type TeachersCreateNestedOneWithoutWorkHoursInput = {
    create?: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutWorkHoursInput
    connect?: TeachersWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SubjectsUpdateOneWithoutWorkHoursNestedInput = {
    create?: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutWorkHoursInput
    upsert?: SubjectsUpsertWithoutWorkHoursInput
    disconnect?: SubjectsWhereInput | boolean
    delete?: SubjectsWhereInput | boolean
    connect?: SubjectsWhereUniqueInput
    update?: XOR<XOR<SubjectsUpdateToOneWithWhereWithoutWorkHoursInput, SubjectsUpdateWithoutWorkHoursInput>, SubjectsUncheckedUpdateWithoutWorkHoursInput>
  }

  export type TeachersUpdateOneRequiredWithoutWorkHoursNestedInput = {
    create?: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutWorkHoursInput
    upsert?: TeachersUpsertWithoutWorkHoursInput
    connect?: TeachersWhereUniqueInput
    update?: XOR<XOR<TeachersUpdateToOneWithWhereWithoutWorkHoursInput, TeachersUpdateWithoutWorkHoursInput>, TeachersUncheckedUpdateWithoutWorkHoursInput>
  }

  export type SubjectsCreateNestedOneWithoutLessonsInput = {
    create?: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutLessonsInput
    connect?: SubjectsWhereUniqueInput
  }

  export type ClassesCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutLessonsInput
    connect?: ClassesWhereUniqueInput
  }

  export type TeachersCreateNestedOneWithoutLessonsInput = {
    create?: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutLessonsInput
    connect?: TeachersWhereUniqueInput
  }

  export type NotesCreateNestedManyWithoutLessonInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type SchedulesCreateNestedManyWithoutLessonInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
  }

  export type NotesUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type SchedulesUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
  }

  export type SubjectsUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutLessonsInput
    upsert?: SubjectsUpsertWithoutLessonsInput
    connect?: SubjectsWhereUniqueInput
    update?: XOR<XOR<SubjectsUpdateToOneWithWhereWithoutLessonsInput, SubjectsUpdateWithoutLessonsInput>, SubjectsUncheckedUpdateWithoutLessonsInput>
  }

  export type ClassesUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutLessonsInput
    upsert?: ClassesUpsertWithoutLessonsInput
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutLessonsInput, ClassesUpdateWithoutLessonsInput>, ClassesUncheckedUpdateWithoutLessonsInput>
  }

  export type TeachersUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutLessonsInput
    upsert?: TeachersUpsertWithoutLessonsInput
    disconnect?: TeachersWhereInput | boolean
    delete?: TeachersWhereInput | boolean
    connect?: TeachersWhereUniqueInput
    update?: XOR<XOR<TeachersUpdateToOneWithWhereWithoutLessonsInput, TeachersUpdateWithoutLessonsInput>, TeachersUncheckedUpdateWithoutLessonsInput>
  }

  export type NotesUpdateManyWithoutLessonNestedInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutLessonInput | NotesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutLessonInput | NotesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutLessonInput | NotesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type SchedulesUpdateManyWithoutLessonNestedInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    upsert?: SchedulesUpsertWithWhereUniqueWithoutLessonInput | SchedulesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    set?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    disconnect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    delete?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    update?: SchedulesUpdateWithWhereUniqueWithoutLessonInput | SchedulesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: SchedulesUpdateManyWithWhereWithoutLessonInput | SchedulesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
  }

  export type NotesUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutLessonInput | NotesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutLessonInput | NotesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutLessonInput | NotesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type SchedulesUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    upsert?: SchedulesUpsertWithWhereUniqueWithoutLessonInput | SchedulesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    set?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    disconnect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    delete?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    update?: SchedulesUpdateWithWhereUniqueWithoutLessonInput | SchedulesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: SchedulesUpdateManyWithWhereWithoutLessonInput | SchedulesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
  }

  export type LessonsCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type ClassesCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutSubjectsInput
    connect?: ClassesWhereUniqueInput
  }

  export type TeacherWorkHoursCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type LessonsUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type LessonsUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutSubjectInput | LessonsUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutSubjectInput | LessonsUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutSubjectInput | LessonsUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type ClassesUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutSubjectsInput
    upsert?: ClassesUpsertWithoutSubjectsInput
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutSubjectsInput, ClassesUpdateWithoutSubjectsInput>, ClassesUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherWorkHoursUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput | TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type LessonsUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutSubjectInput | LessonsUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutSubjectInput | LessonsUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutSubjectInput | LessonsUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput | TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type LessonsCreateNestedOneWithoutNotesInput = {
    create?: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutNotesInput
    connect?: LessonsWhereUniqueInput
  }

  export type StudentsCreateNestedOneWithoutNotesInput = {
    create?: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutNotesInput
    connect?: StudentsWhereUniqueInput
  }

  export type LessonsUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutNotesInput
    upsert?: LessonsUpsertWithoutNotesInput
    connect?: LessonsWhereUniqueInput
    update?: XOR<XOR<LessonsUpdateToOneWithWhereWithoutNotesInput, LessonsUpdateWithoutNotesInput>, LessonsUncheckedUpdateWithoutNotesInput>
  }

  export type StudentsUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutNotesInput
    upsert?: StudentsUpsertWithoutNotesInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutNotesInput, StudentsUpdateWithoutNotesInput>, StudentsUncheckedUpdateWithoutNotesInput>
  }

  export type StudentParentsCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type StudentParentsUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type StudentParentsUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutParentInput | StudentParentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutParentInput | StudentParentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutParentInput | StudentParentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type StudentParentsUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutParentInput | StudentParentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutParentInput | StudentParentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutParentInput | StudentParentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type ParentsCreateNestedOneWithoutStudent_parentsInput = {
    create?: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: ParentsCreateOrConnectWithoutStudent_parentsInput
    connect?: ParentsWhereUniqueInput
  }

  export type StudentsCreateNestedOneWithoutStudent_parentsInput = {
    create?: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutStudent_parentsInput
    connect?: StudentsWhereUniqueInput
  }

  export type ParentsUpdateOneRequiredWithoutStudent_parentsNestedInput = {
    create?: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: ParentsCreateOrConnectWithoutStudent_parentsInput
    upsert?: ParentsUpsertWithoutStudent_parentsInput
    connect?: ParentsWhereUniqueInput
    update?: XOR<XOR<ParentsUpdateToOneWithWhereWithoutStudent_parentsInput, ParentsUpdateWithoutStudent_parentsInput>, ParentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type StudentsUpdateOneRequiredWithoutStudent_parentsNestedInput = {
    create?: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutStudent_parentsInput
    upsert?: StudentsUpsertWithoutStudent_parentsInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutStudent_parentsInput, StudentsUpdateWithoutStudent_parentsInput>, StudentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type RegistrationsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: RegistrationsCreateOrConnectWithoutPaymentsInput
    connect?: RegistrationsWhereUniqueInput
  }

  export type SingleFeeCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SingleFeeCreateWithoutPaymentsInput, SingleFeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SingleFeeCreateOrConnectWithoutPaymentsInput
    connect?: SingleFeeWhereUniqueInput
  }

  export type FeeTemplateCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<FeeTemplateCreateWithoutPaymentsInput, FeeTemplateUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeTemplateCreateOrConnectWithoutPaymentsInput
    connect?: FeeTemplateWhereUniqueInput
  }

  export type RegistrationsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: RegistrationsCreateOrConnectWithoutPaymentsInput
    upsert?: RegistrationsUpsertWithoutPaymentsInput
    disconnect?: RegistrationsWhereInput | boolean
    delete?: RegistrationsWhereInput | boolean
    connect?: RegistrationsWhereUniqueInput
    update?: XOR<XOR<RegistrationsUpdateToOneWithWhereWithoutPaymentsInput, RegistrationsUpdateWithoutPaymentsInput>, RegistrationsUncheckedUpdateWithoutPaymentsInput>
  }

  export type SingleFeeUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SingleFeeCreateWithoutPaymentsInput, SingleFeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SingleFeeCreateOrConnectWithoutPaymentsInput
    upsert?: SingleFeeUpsertWithoutPaymentsInput
    disconnect?: SingleFeeWhereInput | boolean
    delete?: SingleFeeWhereInput | boolean
    connect?: SingleFeeWhereUniqueInput
    update?: XOR<XOR<SingleFeeUpdateToOneWithWhereWithoutPaymentsInput, SingleFeeUpdateWithoutPaymentsInput>, SingleFeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type FeeTemplateUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<FeeTemplateCreateWithoutPaymentsInput, FeeTemplateUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeTemplateCreateOrConnectWithoutPaymentsInput
    upsert?: FeeTemplateUpsertWithoutPaymentsInput
    disconnect?: FeeTemplateWhereInput | boolean
    delete?: FeeTemplateWhereInput | boolean
    connect?: FeeTemplateWhereUniqueInput
    update?: XOR<XOR<FeeTemplateUpdateToOneWithWhereWithoutPaymentsInput, FeeTemplateUpdateWithoutPaymentsInput>, FeeTemplateUncheckedUpdateWithoutPaymentsInput>
  }

  export type ClassesCreateNestedOneWithoutSingle_feesInput = {
    create?: XOR<ClassesCreateWithoutSingle_feesInput, ClassesUncheckedCreateWithoutSingle_feesInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutSingle_feesInput
    connect?: ClassesWhereUniqueInput
  }

  export type PaymentsCreateNestedManyWithoutSingle_feeInput = {
    create?: XOR<PaymentsCreateWithoutSingle_feeInput, PaymentsUncheckedCreateWithoutSingle_feeInput> | PaymentsCreateWithoutSingle_feeInput[] | PaymentsUncheckedCreateWithoutSingle_feeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSingle_feeInput | PaymentsCreateOrConnectWithoutSingle_feeInput[]
    createMany?: PaymentsCreateManySingle_feeInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type DispatchRuleCreateNestedManyWithoutSource_single_feeInput = {
    create?: XOR<DispatchRuleCreateWithoutSource_single_feeInput, DispatchRuleUncheckedCreateWithoutSource_single_feeInput> | DispatchRuleCreateWithoutSource_single_feeInput[] | DispatchRuleUncheckedCreateWithoutSource_single_feeInput[]
    connectOrCreate?: DispatchRuleCreateOrConnectWithoutSource_single_feeInput | DispatchRuleCreateOrConnectWithoutSource_single_feeInput[]
    createMany?: DispatchRuleCreateManySource_single_feeInputEnvelope
    connect?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutSingle_feeInput = {
    create?: XOR<PaymentsCreateWithoutSingle_feeInput, PaymentsUncheckedCreateWithoutSingle_feeInput> | PaymentsCreateWithoutSingle_feeInput[] | PaymentsUncheckedCreateWithoutSingle_feeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSingle_feeInput | PaymentsCreateOrConnectWithoutSingle_feeInput[]
    createMany?: PaymentsCreateManySingle_feeInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type DispatchRuleUncheckedCreateNestedManyWithoutSource_single_feeInput = {
    create?: XOR<DispatchRuleCreateWithoutSource_single_feeInput, DispatchRuleUncheckedCreateWithoutSource_single_feeInput> | DispatchRuleCreateWithoutSource_single_feeInput[] | DispatchRuleUncheckedCreateWithoutSource_single_feeInput[]
    connectOrCreate?: DispatchRuleCreateOrConnectWithoutSource_single_feeInput | DispatchRuleCreateOrConnectWithoutSource_single_feeInput[]
    createMany?: DispatchRuleCreateManySource_single_feeInputEnvelope
    connect?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
  }

  export type ClassesUpdateOneWithoutSingle_feesNestedInput = {
    create?: XOR<ClassesCreateWithoutSingle_feesInput, ClassesUncheckedCreateWithoutSingle_feesInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutSingle_feesInput
    upsert?: ClassesUpsertWithoutSingle_feesInput
    disconnect?: ClassesWhereInput | boolean
    delete?: ClassesWhereInput | boolean
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutSingle_feesInput, ClassesUpdateWithoutSingle_feesInput>, ClassesUncheckedUpdateWithoutSingle_feesInput>
  }

  export type PaymentsUpdateManyWithoutSingle_feeNestedInput = {
    create?: XOR<PaymentsCreateWithoutSingle_feeInput, PaymentsUncheckedCreateWithoutSingle_feeInput> | PaymentsCreateWithoutSingle_feeInput[] | PaymentsUncheckedCreateWithoutSingle_feeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSingle_feeInput | PaymentsCreateOrConnectWithoutSingle_feeInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutSingle_feeInput | PaymentsUpsertWithWhereUniqueWithoutSingle_feeInput[]
    createMany?: PaymentsCreateManySingle_feeInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutSingle_feeInput | PaymentsUpdateWithWhereUniqueWithoutSingle_feeInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutSingle_feeInput | PaymentsUpdateManyWithWhereWithoutSingle_feeInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type DispatchRuleUpdateManyWithoutSource_single_feeNestedInput = {
    create?: XOR<DispatchRuleCreateWithoutSource_single_feeInput, DispatchRuleUncheckedCreateWithoutSource_single_feeInput> | DispatchRuleCreateWithoutSource_single_feeInput[] | DispatchRuleUncheckedCreateWithoutSource_single_feeInput[]
    connectOrCreate?: DispatchRuleCreateOrConnectWithoutSource_single_feeInput | DispatchRuleCreateOrConnectWithoutSource_single_feeInput[]
    upsert?: DispatchRuleUpsertWithWhereUniqueWithoutSource_single_feeInput | DispatchRuleUpsertWithWhereUniqueWithoutSource_single_feeInput[]
    createMany?: DispatchRuleCreateManySource_single_feeInputEnvelope
    set?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    disconnect?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    delete?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    connect?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    update?: DispatchRuleUpdateWithWhereUniqueWithoutSource_single_feeInput | DispatchRuleUpdateWithWhereUniqueWithoutSource_single_feeInput[]
    updateMany?: DispatchRuleUpdateManyWithWhereWithoutSource_single_feeInput | DispatchRuleUpdateManyWithWhereWithoutSource_single_feeInput[]
    deleteMany?: DispatchRuleScalarWhereInput | DispatchRuleScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutSingle_feeNestedInput = {
    create?: XOR<PaymentsCreateWithoutSingle_feeInput, PaymentsUncheckedCreateWithoutSingle_feeInput> | PaymentsCreateWithoutSingle_feeInput[] | PaymentsUncheckedCreateWithoutSingle_feeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSingle_feeInput | PaymentsCreateOrConnectWithoutSingle_feeInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutSingle_feeInput | PaymentsUpsertWithWhereUniqueWithoutSingle_feeInput[]
    createMany?: PaymentsCreateManySingle_feeInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutSingle_feeInput | PaymentsUpdateWithWhereUniqueWithoutSingle_feeInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutSingle_feeInput | PaymentsUpdateManyWithWhereWithoutSingle_feeInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type DispatchRuleUncheckedUpdateManyWithoutSource_single_feeNestedInput = {
    create?: XOR<DispatchRuleCreateWithoutSource_single_feeInput, DispatchRuleUncheckedCreateWithoutSource_single_feeInput> | DispatchRuleCreateWithoutSource_single_feeInput[] | DispatchRuleUncheckedCreateWithoutSource_single_feeInput[]
    connectOrCreate?: DispatchRuleCreateOrConnectWithoutSource_single_feeInput | DispatchRuleCreateOrConnectWithoutSource_single_feeInput[]
    upsert?: DispatchRuleUpsertWithWhereUniqueWithoutSource_single_feeInput | DispatchRuleUpsertWithWhereUniqueWithoutSource_single_feeInput[]
    createMany?: DispatchRuleCreateManySource_single_feeInputEnvelope
    set?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    disconnect?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    delete?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    connect?: DispatchRuleWhereUniqueInput | DispatchRuleWhereUniqueInput[]
    update?: DispatchRuleUpdateWithWhereUniqueWithoutSource_single_feeInput | DispatchRuleUpdateWithWhereUniqueWithoutSource_single_feeInput[]
    updateMany?: DispatchRuleUpdateManyWithWhereWithoutSource_single_feeInput | DispatchRuleUpdateManyWithWhereWithoutSource_single_feeInput[]
    deleteMany?: DispatchRuleScalarWhereInput | DispatchRuleScalarWhereInput[]
  }

  export type ClassesCreateNestedOneWithoutFee_templatesInput = {
    create?: XOR<ClassesCreateWithoutFee_templatesInput, ClassesUncheckedCreateWithoutFee_templatesInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutFee_templatesInput
    connect?: ClassesWhereUniqueInput
  }

  export type PaymentsCreateNestedManyWithoutFee_templateInput = {
    create?: XOR<PaymentsCreateWithoutFee_templateInput, PaymentsUncheckedCreateWithoutFee_templateInput> | PaymentsCreateWithoutFee_templateInput[] | PaymentsUncheckedCreateWithoutFee_templateInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFee_templateInput | PaymentsCreateOrConnectWithoutFee_templateInput[]
    createMany?: PaymentsCreateManyFee_templateInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutFee_templateInput = {
    create?: XOR<PaymentsCreateWithoutFee_templateInput, PaymentsUncheckedCreateWithoutFee_templateInput> | PaymentsCreateWithoutFee_templateInput[] | PaymentsUncheckedCreateWithoutFee_templateInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFee_templateInput | PaymentsCreateOrConnectWithoutFee_templateInput[]
    createMany?: PaymentsCreateManyFee_templateInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ClassesUpdateOneWithoutFee_templatesNestedInput = {
    create?: XOR<ClassesCreateWithoutFee_templatesInput, ClassesUncheckedCreateWithoutFee_templatesInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutFee_templatesInput
    upsert?: ClassesUpsertWithoutFee_templatesInput
    disconnect?: ClassesWhereInput | boolean
    delete?: ClassesWhereInput | boolean
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutFee_templatesInput, ClassesUpdateWithoutFee_templatesInput>, ClassesUncheckedUpdateWithoutFee_templatesInput>
  }

  export type PaymentsUpdateManyWithoutFee_templateNestedInput = {
    create?: XOR<PaymentsCreateWithoutFee_templateInput, PaymentsUncheckedCreateWithoutFee_templateInput> | PaymentsCreateWithoutFee_templateInput[] | PaymentsUncheckedCreateWithoutFee_templateInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFee_templateInput | PaymentsCreateOrConnectWithoutFee_templateInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutFee_templateInput | PaymentsUpsertWithWhereUniqueWithoutFee_templateInput[]
    createMany?: PaymentsCreateManyFee_templateInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutFee_templateInput | PaymentsUpdateWithWhereUniqueWithoutFee_templateInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutFee_templateInput | PaymentsUpdateManyWithWhereWithoutFee_templateInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutFee_templateNestedInput = {
    create?: XOR<PaymentsCreateWithoutFee_templateInput, PaymentsUncheckedCreateWithoutFee_templateInput> | PaymentsCreateWithoutFee_templateInput[] | PaymentsUncheckedCreateWithoutFee_templateInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFee_templateInput | PaymentsCreateOrConnectWithoutFee_templateInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutFee_templateInput | PaymentsUpsertWithWhereUniqueWithoutFee_templateInput[]
    createMany?: PaymentsCreateManyFee_templateInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutFee_templateInput | PaymentsUpdateWithWhereUniqueWithoutFee_templateInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutFee_templateInput | PaymentsUpdateManyWithWhereWithoutFee_templateInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type StudentsCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutAttendancesInput
    connect?: StudentsWhereUniqueInput
  }

  export type StudentsUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutAttendancesInput
    upsert?: StudentsUpsertWithoutAttendancesInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutAttendancesInput, StudentsUpdateWithoutAttendancesInput>, StudentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type SalaryPaymentsCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
  }

  export type EmployeeAttendanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutEmployeeInput, EmployeeAttendanceUncheckedCreateWithoutEmployeeInput> | EmployeeAttendanceCreateWithoutEmployeeInput[] | EmployeeAttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutEmployeeInput | EmployeeAttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeAttendanceCreateManyEmployeeInputEnvelope
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
  }

  export type SalaryPaymentsUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
  }

  export type EmployeeAttendanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutEmployeeInput, EmployeeAttendanceUncheckedCreateWithoutEmployeeInput> | EmployeeAttendanceCreateWithoutEmployeeInput[] | EmployeeAttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutEmployeeInput | EmployeeAttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeAttendanceCreateManyEmployeeInputEnvelope
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
  }

  export type SalaryPaymentsUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    disconnect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    delete?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    update?: SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
  }

  export type EmployeeAttendanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutEmployeeInput, EmployeeAttendanceUncheckedCreateWithoutEmployeeInput> | EmployeeAttendanceCreateWithoutEmployeeInput[] | EmployeeAttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutEmployeeInput | EmployeeAttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeAttendanceUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeAttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeAttendanceCreateManyEmployeeInputEnvelope
    set?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    disconnect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    delete?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    update?: EmployeeAttendanceUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeAttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeAttendanceUpdateManyWithWhereWithoutEmployeeInput | EmployeeAttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeAttendanceScalarWhereInput | EmployeeAttendanceScalarWhereInput[]
  }

  export type SalaryPaymentsUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    disconnect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    delete?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    update?: SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
  }

  export type EmployeeAttendanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAttendanceCreateWithoutEmployeeInput, EmployeeAttendanceUncheckedCreateWithoutEmployeeInput> | EmployeeAttendanceCreateWithoutEmployeeInput[] | EmployeeAttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttendanceCreateOrConnectWithoutEmployeeInput | EmployeeAttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeAttendanceUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeAttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeAttendanceCreateManyEmployeeInputEnvelope
    set?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    disconnect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    delete?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    connect?: EmployeeAttendanceWhereUniqueInput | EmployeeAttendanceWhereUniqueInput[]
    update?: EmployeeAttendanceUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeAttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeAttendanceUpdateManyWithWhereWithoutEmployeeInput | EmployeeAttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeAttendanceScalarWhereInput | EmployeeAttendanceScalarWhereInput[]
  }

  export type EmployeesCreateNestedOneWithoutSalary_paymentsInput = {
    create?: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutSalary_paymentsInput
    connect?: EmployeesWhereUniqueInput
  }

  export type EmployeesUpdateOneRequiredWithoutSalary_paymentsNestedInput = {
    create?: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutSalary_paymentsInput
    upsert?: EmployeesUpsertWithoutSalary_paymentsInput
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutSalary_paymentsInput, EmployeesUpdateWithoutSalary_paymentsInput>, EmployeesUncheckedUpdateWithoutSalary_paymentsInput>
  }

  export type LessonsCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutSchedulesInput
    connect?: LessonsWhereUniqueInput
  }

  export type LessonsUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutSchedulesInput
    upsert?: LessonsUpsertWithoutSchedulesInput
    connect?: LessonsWhereUniqueInput
    update?: XOR<XOR<LessonsUpdateToOneWithWhereWithoutSchedulesInput, LessonsUpdateWithoutSchedulesInput>, LessonsUncheckedUpdateWithoutSchedulesInput>
  }

  export type FinancialTransactionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<FinancialTransactionCreateWithoutCategoryInput, FinancialTransactionUncheckedCreateWithoutCategoryInput> | FinancialTransactionCreateWithoutCategoryInput[] | FinancialTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutCategoryInput | FinancialTransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: FinancialTransactionCreateManyCategoryInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type DispatchRuleDetailCreateNestedManyWithoutDestination_categoryInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput> | DispatchRuleDetailCreateWithoutDestination_categoryInput[] | DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput | DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput[]
    createMany?: DispatchRuleDetailCreateManyDestination_categoryInputEnvelope
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
  }

  export type FinancialTransactionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<FinancialTransactionCreateWithoutCategoryInput, FinancialTransactionUncheckedCreateWithoutCategoryInput> | FinancialTransactionCreateWithoutCategoryInput[] | FinancialTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutCategoryInput | FinancialTransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: FinancialTransactionCreateManyCategoryInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type DispatchRuleDetailUncheckedCreateNestedManyWithoutDestination_categoryInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput> | DispatchRuleDetailCreateWithoutDestination_categoryInput[] | DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput | DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput[]
    createMany?: DispatchRuleDetailCreateManyDestination_categoryInputEnvelope
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
  }

  export type FinancialTransactionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutCategoryInput, FinancialTransactionUncheckedCreateWithoutCategoryInput> | FinancialTransactionCreateWithoutCategoryInput[] | FinancialTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutCategoryInput | FinancialTransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutCategoryInput | FinancialTransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: FinancialTransactionCreateManyCategoryInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutCategoryInput | FinancialTransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutCategoryInput | FinancialTransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type DispatchRuleDetailUpdateManyWithoutDestination_categoryNestedInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput> | DispatchRuleDetailCreateWithoutDestination_categoryInput[] | DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput | DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput[]
    upsert?: DispatchRuleDetailUpsertWithWhereUniqueWithoutDestination_categoryInput | DispatchRuleDetailUpsertWithWhereUniqueWithoutDestination_categoryInput[]
    createMany?: DispatchRuleDetailCreateManyDestination_categoryInputEnvelope
    set?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    disconnect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    delete?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    update?: DispatchRuleDetailUpdateWithWhereUniqueWithoutDestination_categoryInput | DispatchRuleDetailUpdateWithWhereUniqueWithoutDestination_categoryInput[]
    updateMany?: DispatchRuleDetailUpdateManyWithWhereWithoutDestination_categoryInput | DispatchRuleDetailUpdateManyWithWhereWithoutDestination_categoryInput[]
    deleteMany?: DispatchRuleDetailScalarWhereInput | DispatchRuleDetailScalarWhereInput[]
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutCategoryInput, FinancialTransactionUncheckedCreateWithoutCategoryInput> | FinancialTransactionCreateWithoutCategoryInput[] | FinancialTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutCategoryInput | FinancialTransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutCategoryInput | FinancialTransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: FinancialTransactionCreateManyCategoryInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutCategoryInput | FinancialTransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutCategoryInput | FinancialTransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type DispatchRuleDetailUncheckedUpdateManyWithoutDestination_categoryNestedInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput> | DispatchRuleDetailCreateWithoutDestination_categoryInput[] | DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput | DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput[]
    upsert?: DispatchRuleDetailUpsertWithWhereUniqueWithoutDestination_categoryInput | DispatchRuleDetailUpsertWithWhereUniqueWithoutDestination_categoryInput[]
    createMany?: DispatchRuleDetailCreateManyDestination_categoryInputEnvelope
    set?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    disconnect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    delete?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    update?: DispatchRuleDetailUpdateWithWhereUniqueWithoutDestination_categoryInput | DispatchRuleDetailUpdateWithWhereUniqueWithoutDestination_categoryInput[]
    updateMany?: DispatchRuleDetailUpdateManyWithWhereWithoutDestination_categoryInput | DispatchRuleDetailUpdateManyWithWhereWithoutDestination_categoryInput[]
    deleteMany?: DispatchRuleDetailScalarWhereInput | DispatchRuleDetailScalarWhereInput[]
  }

  export type FinancialCategoryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<FinancialCategoryCreateWithoutTransactionsInput, FinancialCategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: FinancialCategoryCreateOrConnectWithoutTransactionsInput
    connect?: FinancialCategoryWhereUniqueInput
  }

  export type FinancialCategoryUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<FinancialCategoryCreateWithoutTransactionsInput, FinancialCategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: FinancialCategoryCreateOrConnectWithoutTransactionsInput
    upsert?: FinancialCategoryUpsertWithoutTransactionsInput
    connect?: FinancialCategoryWhereUniqueInput
    update?: XOR<XOR<FinancialCategoryUpdateToOneWithWhereWithoutTransactionsInput, FinancialCategoryUpdateWithoutTransactionsInput>, FinancialCategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type SingleFeeCreateNestedOneWithoutDispatch_rulesInput = {
    create?: XOR<SingleFeeCreateWithoutDispatch_rulesInput, SingleFeeUncheckedCreateWithoutDispatch_rulesInput>
    connectOrCreate?: SingleFeeCreateOrConnectWithoutDispatch_rulesInput
    connect?: SingleFeeWhereUniqueInput
  }

  export type DispatchRuleDetailCreateNestedManyWithoutDispatch_ruleInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput> | DispatchRuleDetailCreateWithoutDispatch_ruleInput[] | DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput | DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput[]
    createMany?: DispatchRuleDetailCreateManyDispatch_ruleInputEnvelope
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
  }

  export type DispatchRuleDetailUncheckedCreateNestedManyWithoutDispatch_ruleInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput> | DispatchRuleDetailCreateWithoutDispatch_ruleInput[] | DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput | DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput[]
    createMany?: DispatchRuleDetailCreateManyDispatch_ruleInputEnvelope
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
  }

  export type SingleFeeUpdateOneRequiredWithoutDispatch_rulesNestedInput = {
    create?: XOR<SingleFeeCreateWithoutDispatch_rulesInput, SingleFeeUncheckedCreateWithoutDispatch_rulesInput>
    connectOrCreate?: SingleFeeCreateOrConnectWithoutDispatch_rulesInput
    upsert?: SingleFeeUpsertWithoutDispatch_rulesInput
    connect?: SingleFeeWhereUniqueInput
    update?: XOR<XOR<SingleFeeUpdateToOneWithWhereWithoutDispatch_rulesInput, SingleFeeUpdateWithoutDispatch_rulesInput>, SingleFeeUncheckedUpdateWithoutDispatch_rulesInput>
  }

  export type DispatchRuleDetailUpdateManyWithoutDispatch_ruleNestedInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput> | DispatchRuleDetailCreateWithoutDispatch_ruleInput[] | DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput | DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput[]
    upsert?: DispatchRuleDetailUpsertWithWhereUniqueWithoutDispatch_ruleInput | DispatchRuleDetailUpsertWithWhereUniqueWithoutDispatch_ruleInput[]
    createMany?: DispatchRuleDetailCreateManyDispatch_ruleInputEnvelope
    set?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    disconnect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    delete?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    update?: DispatchRuleDetailUpdateWithWhereUniqueWithoutDispatch_ruleInput | DispatchRuleDetailUpdateWithWhereUniqueWithoutDispatch_ruleInput[]
    updateMany?: DispatchRuleDetailUpdateManyWithWhereWithoutDispatch_ruleInput | DispatchRuleDetailUpdateManyWithWhereWithoutDispatch_ruleInput[]
    deleteMany?: DispatchRuleDetailScalarWhereInput | DispatchRuleDetailScalarWhereInput[]
  }

  export type DispatchRuleDetailUncheckedUpdateManyWithoutDispatch_ruleNestedInput = {
    create?: XOR<DispatchRuleDetailCreateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput> | DispatchRuleDetailCreateWithoutDispatch_ruleInput[] | DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput[]
    connectOrCreate?: DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput | DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput[]
    upsert?: DispatchRuleDetailUpsertWithWhereUniqueWithoutDispatch_ruleInput | DispatchRuleDetailUpsertWithWhereUniqueWithoutDispatch_ruleInput[]
    createMany?: DispatchRuleDetailCreateManyDispatch_ruleInputEnvelope
    set?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    disconnect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    delete?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    connect?: DispatchRuleDetailWhereUniqueInput | DispatchRuleDetailWhereUniqueInput[]
    update?: DispatchRuleDetailUpdateWithWhereUniqueWithoutDispatch_ruleInput | DispatchRuleDetailUpdateWithWhereUniqueWithoutDispatch_ruleInput[]
    updateMany?: DispatchRuleDetailUpdateManyWithWhereWithoutDispatch_ruleInput | DispatchRuleDetailUpdateManyWithWhereWithoutDispatch_ruleInput[]
    deleteMany?: DispatchRuleDetailScalarWhereInput | DispatchRuleDetailScalarWhereInput[]
  }

  export type DispatchRuleCreateNestedOneWithoutDetailsInput = {
    create?: XOR<DispatchRuleCreateWithoutDetailsInput, DispatchRuleUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: DispatchRuleCreateOrConnectWithoutDetailsInput
    connect?: DispatchRuleWhereUniqueInput
  }

  export type FinancialCategoryCreateNestedOneWithoutDispatch_rule_detailsInput = {
    create?: XOR<FinancialCategoryCreateWithoutDispatch_rule_detailsInput, FinancialCategoryUncheckedCreateWithoutDispatch_rule_detailsInput>
    connectOrCreate?: FinancialCategoryCreateOrConnectWithoutDispatch_rule_detailsInput
    connect?: FinancialCategoryWhereUniqueInput
  }

  export type DispatchRuleUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<DispatchRuleCreateWithoutDetailsInput, DispatchRuleUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: DispatchRuleCreateOrConnectWithoutDetailsInput
    upsert?: DispatchRuleUpsertWithoutDetailsInput
    connect?: DispatchRuleWhereUniqueInput
    update?: XOR<XOR<DispatchRuleUpdateToOneWithWhereWithoutDetailsInput, DispatchRuleUpdateWithoutDetailsInput>, DispatchRuleUncheckedUpdateWithoutDetailsInput>
  }

  export type FinancialCategoryUpdateOneRequiredWithoutDispatch_rule_detailsNestedInput = {
    create?: XOR<FinancialCategoryCreateWithoutDispatch_rule_detailsInput, FinancialCategoryUncheckedCreateWithoutDispatch_rule_detailsInput>
    connectOrCreate?: FinancialCategoryCreateOrConnectWithoutDispatch_rule_detailsInput
    upsert?: FinancialCategoryUpsertWithoutDispatch_rule_detailsInput
    connect?: FinancialCategoryWhereUniqueInput
    update?: XOR<XOR<FinancialCategoryUpdateToOneWithWhereWithoutDispatch_rule_detailsInput, FinancialCategoryUpdateWithoutDispatch_rule_detailsInput>, FinancialCategoryUncheckedUpdateWithoutDispatch_rule_detailsInput>
  }

  export type EmployeesCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<EmployeesCreateWithoutAttendancesInput, EmployeesUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutAttendancesInput
    connect?: EmployeesWhereUniqueInput
  }

  export type TeachersCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<TeachersCreateWithoutAttendancesInput, TeachersUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutAttendancesInput
    connect?: TeachersWhereUniqueInput
  }

  export type EmployeesUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<EmployeesCreateWithoutAttendancesInput, EmployeesUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutAttendancesInput
    upsert?: EmployeesUpsertWithoutAttendancesInput
    disconnect?: EmployeesWhereInput | boolean
    delete?: EmployeesWhereInput | boolean
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutAttendancesInput, EmployeesUpdateWithoutAttendancesInput>, EmployeesUncheckedUpdateWithoutAttendancesInput>
  }

  export type TeachersUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<TeachersCreateWithoutAttendancesInput, TeachersUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutAttendancesInput
    upsert?: TeachersUpsertWithoutAttendancesInput
    disconnect?: TeachersWhereInput | boolean
    delete?: TeachersWhereInput | boolean
    connect?: TeachersWhereUniqueInput
    update?: XOR<XOR<TeachersUpdateToOneWithWhereWithoutAttendancesInput, TeachersUpdateWithoutAttendancesInput>, TeachersUncheckedUpdateWithoutAttendancesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LessonsCreateWithoutClassInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutClassInput = {
    id?: number
    teacher_id?: number | null
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutClassInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput>
  }

  export type LessonsCreateManyClassInputEnvelope = {
    data: LessonsCreateManyClassInput | LessonsCreateManyClassInput[]
  }

  export type RegistrationsCreateWithoutClassInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutRegistrationInput
    student: StudentsCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateWithoutClassInput = {
    id?: number
    student_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type RegistrationsCreateOrConnectWithoutClassInput = {
    where: RegistrationsWhereUniqueInput
    create: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput>
  }

  export type RegistrationsCreateManyClassInputEnvelope = {
    data: RegistrationsCreateManyClassInput | RegistrationsCreateManyClassInput[]
  }

  export type SubjectsCreateWithoutClassInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutSubjectInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUncheckedCreateWithoutClassInput = {
    id?: number
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutSubjectInput
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsCreateOrConnectWithoutClassInput = {
    where: SubjectsWhereUniqueInput
    create: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput>
  }

  export type SubjectsCreateManyClassInputEnvelope = {
    data: SubjectsCreateManyClassInput | SubjectsCreateManyClassInput[]
  }

  export type SingleFeeCreateWithoutClassInput = {
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutSingle_feeInput
    dispatch_rules?: DispatchRuleCreateNestedManyWithoutSource_single_feeInput
  }

  export type SingleFeeUncheckedCreateWithoutClassInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutSingle_feeInput
    dispatch_rules?: DispatchRuleUncheckedCreateNestedManyWithoutSource_single_feeInput
  }

  export type SingleFeeCreateOrConnectWithoutClassInput = {
    where: SingleFeeWhereUniqueInput
    create: XOR<SingleFeeCreateWithoutClassInput, SingleFeeUncheckedCreateWithoutClassInput>
  }

  export type SingleFeeCreateManyClassInputEnvelope = {
    data: SingleFeeCreateManyClassInput | SingleFeeCreateManyClassInput[]
  }

  export type FeeTemplateCreateWithoutClassInput = {
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutFee_templateInput
  }

  export type FeeTemplateUncheckedCreateWithoutClassInput = {
    id?: number
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutFee_templateInput
  }

  export type FeeTemplateCreateOrConnectWithoutClassInput = {
    where: FeeTemplateWhereUniqueInput
    create: XOR<FeeTemplateCreateWithoutClassInput, FeeTemplateUncheckedCreateWithoutClassInput>
  }

  export type FeeTemplateCreateManyClassInputEnvelope = {
    data: FeeTemplateCreateManyClassInput | FeeTemplateCreateManyClassInput[]
  }

  export type LessonsUpsertWithWhereUniqueWithoutClassInput = {
    where: LessonsWhereUniqueInput
    update: XOR<LessonsUpdateWithoutClassInput, LessonsUncheckedUpdateWithoutClassInput>
    create: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput>
  }

  export type LessonsUpdateWithWhereUniqueWithoutClassInput = {
    where: LessonsWhereUniqueInput
    data: XOR<LessonsUpdateWithoutClassInput, LessonsUncheckedUpdateWithoutClassInput>
  }

  export type LessonsUpdateManyWithWhereWithoutClassInput = {
    where: LessonsScalarWhereInput
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyWithoutClassInput>
  }

  export type LessonsScalarWhereInput = {
    AND?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
    OR?: LessonsScalarWhereInput[]
    NOT?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
    id?: IntFilter<"Lessons"> | number
    teacher_id?: IntNullableFilter<"Lessons"> | number | null
    class_id?: IntFilter<"Lessons"> | number
    subject_id?: IntFilter<"Lessons"> | number
    school_year?: StringNullableFilter<"Lessons"> | string | null
    supabase_id?: StringNullableFilter<"Lessons"> | string | null
    last_modified?: DateTimeFilter<"Lessons"> | Date | string
    needs_sync?: BoolFilter<"Lessons"> | boolean
    is_deleted?: BoolFilter<"Lessons"> | boolean
  }

  export type RegistrationsUpsertWithWhereUniqueWithoutClassInput = {
    where: RegistrationsWhereUniqueInput
    update: XOR<RegistrationsUpdateWithoutClassInput, RegistrationsUncheckedUpdateWithoutClassInput>
    create: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput>
  }

  export type RegistrationsUpdateWithWhereUniqueWithoutClassInput = {
    where: RegistrationsWhereUniqueInput
    data: XOR<RegistrationsUpdateWithoutClassInput, RegistrationsUncheckedUpdateWithoutClassInput>
  }

  export type RegistrationsUpdateManyWithWhereWithoutClassInput = {
    where: RegistrationsScalarWhereInput
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyWithoutClassInput>
  }

  export type RegistrationsScalarWhereInput = {
    AND?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
    OR?: RegistrationsScalarWhereInput[]
    NOT?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
    id?: IntFilter<"Registrations"> | number
    student_id?: IntFilter<"Registrations"> | number
    class_id?: IntFilter<"Registrations"> | number
    school_year?: StringNullableFilter<"Registrations"> | string | null
    state?: StringNullableFilter<"Registrations"> | string | null
    registration_date?: StringNullableFilter<"Registrations"> | string | null
    supabase_id?: StringNullableFilter<"Registrations"> | string | null
    last_modified?: DateTimeFilter<"Registrations"> | Date | string
    needs_sync?: BoolFilter<"Registrations"> | boolean
    is_deleted?: BoolFilter<"Registrations"> | boolean
  }

  export type SubjectsUpsertWithWhereUniqueWithoutClassInput = {
    where: SubjectsWhereUniqueInput
    update: XOR<SubjectsUpdateWithoutClassInput, SubjectsUncheckedUpdateWithoutClassInput>
    create: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput>
  }

  export type SubjectsUpdateWithWhereUniqueWithoutClassInput = {
    where: SubjectsWhereUniqueInput
    data: XOR<SubjectsUpdateWithoutClassInput, SubjectsUncheckedUpdateWithoutClassInput>
  }

  export type SubjectsUpdateManyWithWhereWithoutClassInput = {
    where: SubjectsScalarWhereInput
    data: XOR<SubjectsUpdateManyMutationInput, SubjectsUncheckedUpdateManyWithoutClassInput>
  }

  export type SubjectsScalarWhereInput = {
    AND?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
    OR?: SubjectsScalarWhereInput[]
    NOT?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
    id?: IntFilter<"Subjects"> | number
    name?: StringFilter<"Subjects"> | string
    class_id?: IntFilter<"Subjects"> | number
    school_year?: StringNullableFilter<"Subjects"> | string | null
    coefficient?: IntNullableFilter<"Subjects"> | number | null
    supabase_id?: StringNullableFilter<"Subjects"> | string | null
    last_modified?: DateTimeFilter<"Subjects"> | Date | string
    needs_sync?: BoolFilter<"Subjects"> | boolean
    is_deleted?: BoolFilter<"Subjects"> | boolean
  }

  export type SingleFeeUpsertWithWhereUniqueWithoutClassInput = {
    where: SingleFeeWhereUniqueInput
    update: XOR<SingleFeeUpdateWithoutClassInput, SingleFeeUncheckedUpdateWithoutClassInput>
    create: XOR<SingleFeeCreateWithoutClassInput, SingleFeeUncheckedCreateWithoutClassInput>
  }

  export type SingleFeeUpdateWithWhereUniqueWithoutClassInput = {
    where: SingleFeeWhereUniqueInput
    data: XOR<SingleFeeUpdateWithoutClassInput, SingleFeeUncheckedUpdateWithoutClassInput>
  }

  export type SingleFeeUpdateManyWithWhereWithoutClassInput = {
    where: SingleFeeScalarWhereInput
    data: XOR<SingleFeeUpdateManyMutationInput, SingleFeeUncheckedUpdateManyWithoutClassInput>
  }

  export type SingleFeeScalarWhereInput = {
    AND?: SingleFeeScalarWhereInput | SingleFeeScalarWhereInput[]
    OR?: SingleFeeScalarWhereInput[]
    NOT?: SingleFeeScalarWhereInput | SingleFeeScalarWhereInput[]
    id?: IntFilter<"SingleFee"> | number
    name?: StringNullableFilter<"SingleFee"> | string | null
    amount?: FloatNullableFilter<"SingleFee"> | number | null
    due_date?: StringNullableFilter<"SingleFee"> | string | null
    school_year?: StringNullableFilter<"SingleFee"> | string | null
    level?: StringNullableFilter<"SingleFee"> | string | null
    class_id?: IntNullableFilter<"SingleFee"> | number | null
    school_id?: StringNullableFilter<"SingleFee"> | string | null
    supabase_id?: StringNullableFilter<"SingleFee"> | string | null
    last_modified?: DateTimeFilter<"SingleFee"> | Date | string
    needs_sync?: BoolFilter<"SingleFee"> | boolean
    is_deleted?: BoolFilter<"SingleFee"> | boolean
  }

  export type FeeTemplateUpsertWithWhereUniqueWithoutClassInput = {
    where: FeeTemplateWhereUniqueInput
    update: XOR<FeeTemplateUpdateWithoutClassInput, FeeTemplateUncheckedUpdateWithoutClassInput>
    create: XOR<FeeTemplateCreateWithoutClassInput, FeeTemplateUncheckedCreateWithoutClassInput>
  }

  export type FeeTemplateUpdateWithWhereUniqueWithoutClassInput = {
    where: FeeTemplateWhereUniqueInput
    data: XOR<FeeTemplateUpdateWithoutClassInput, FeeTemplateUncheckedUpdateWithoutClassInput>
  }

  export type FeeTemplateUpdateManyWithWhereWithoutClassInput = {
    where: FeeTemplateScalarWhereInput
    data: XOR<FeeTemplateUpdateManyMutationInput, FeeTemplateUncheckedUpdateManyWithoutClassInput>
  }

  export type FeeTemplateScalarWhereInput = {
    AND?: FeeTemplateScalarWhereInput | FeeTemplateScalarWhereInput[]
    OR?: FeeTemplateScalarWhereInput[]
    NOT?: FeeTemplateScalarWhereInput | FeeTemplateScalarWhereInput[]
    id?: IntFilter<"FeeTemplate"> | number
    name?: StringFilter<"FeeTemplate"> | string
    amount?: FloatFilter<"FeeTemplate"> | number
    frequency?: StringFilter<"FeeTemplate"> | string
    due_day?: IntNullableFilter<"FeeTemplate"> | number | null
    applicable_months?: JsonNullableFilter<"FeeTemplate">
    school_id?: StringFilter<"FeeTemplate"> | string
    applies_to_level?: StringNullableFilter<"FeeTemplate"> | string | null
    applies_to_class_id?: IntNullableFilter<"FeeTemplate"> | number | null
    supabase_id?: StringNullableFilter<"FeeTemplate"> | string | null
    last_modified?: DateTimeFilter<"FeeTemplate"> | Date | string
    needs_sync?: BoolFilter<"FeeTemplate"> | boolean
    is_deleted?: BoolFilter<"FeeTemplate"> | boolean
  }

  export type AttendancesCreateWithoutStudentInput = {
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUncheckedCreateWithoutStudentInput = {
    id?: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesCreateOrConnectWithoutStudentInput = {
    where: AttendancesWhereUniqueInput
    create: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput>
  }

  export type AttendancesCreateManyStudentInputEnvelope = {
    data: AttendancesCreateManyStudentInput | AttendancesCreateManyStudentInput[]
  }

  export type NotesCreateWithoutStudentInput = {
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lesson: LessonsCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateWithoutStudentInput = {
    id?: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesCreateOrConnectWithoutStudentInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput>
  }

  export type NotesCreateManyStudentInputEnvelope = {
    data: NotesCreateManyStudentInput | NotesCreateManyStudentInput[]
  }

  export type RegistrationsCreateWithoutStudentInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutRegistrationInput
    class: ClassesCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateWithoutStudentInput = {
    id?: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type RegistrationsCreateOrConnectWithoutStudentInput = {
    where: RegistrationsWhereUniqueInput
    create: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput>
  }

  export type RegistrationsCreateManyStudentInputEnvelope = {
    data: RegistrationsCreateManyStudentInput | RegistrationsCreateManyStudentInput[]
  }

  export type StudentParentsCreateWithoutStudentInput = {
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    parent: ParentsCreateNestedOneWithoutStudent_parentsInput
  }

  export type StudentParentsUncheckedCreateWithoutStudentInput = {
    id?: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsCreateOrConnectWithoutStudentInput = {
    where: StudentParentsWhereUniqueInput
    create: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentsCreateManyStudentInputEnvelope = {
    data: StudentParentsCreateManyStudentInput | StudentParentsCreateManyStudentInput[]
  }

  export type AttendancesUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendancesWhereUniqueInput
    update: XOR<AttendancesUpdateWithoutStudentInput, AttendancesUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput>
  }

  export type AttendancesUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendancesWhereUniqueInput
    data: XOR<AttendancesUpdateWithoutStudentInput, AttendancesUncheckedUpdateWithoutStudentInput>
  }

  export type AttendancesUpdateManyWithWhereWithoutStudentInput = {
    where: AttendancesScalarWhereInput
    data: XOR<AttendancesUpdateManyMutationInput, AttendancesUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendancesScalarWhereInput = {
    AND?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
    OR?: AttendancesScalarWhereInput[]
    NOT?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
    id?: IntFilter<"Attendances"> | number
    student_id?: IntFilter<"Attendances"> | number
    date?: StringNullableFilter<"Attendances"> | string | null
    state?: StringNullableFilter<"Attendances"> | string | null
    justification?: StringNullableFilter<"Attendances"> | string | null
    supabase_id?: StringNullableFilter<"Attendances"> | string | null
    last_modified?: DateTimeFilter<"Attendances"> | Date | string
    needs_sync?: BoolFilter<"Attendances"> | boolean
    is_deleted?: BoolFilter<"Attendances"> | boolean
  }

  export type NotesUpsertWithWhereUniqueWithoutStudentInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutStudentInput, NotesUncheckedUpdateWithoutStudentInput>
    create: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutStudentInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutStudentInput, NotesUncheckedUpdateWithoutStudentInput>
  }

  export type NotesUpdateManyWithWhereWithoutStudentInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutStudentInput>
  }

  export type NotesScalarWhereInput = {
    AND?: NotesScalarWhereInput | NotesScalarWhereInput[]
    OR?: NotesScalarWhereInput[]
    NOT?: NotesScalarWhereInput | NotesScalarWhereInput[]
    id?: IntFilter<"Notes"> | number
    student_id?: IntFilter<"Notes"> | number
    lesson_id?: IntFilter<"Notes"> | number
    value?: FloatNullableFilter<"Notes"> | number | null
    type?: StringNullableFilter<"Notes"> | string | null
    quarter?: IntNullableFilter<"Notes"> | number | null
    supabase_id?: StringNullableFilter<"Notes"> | string | null
    last_modified?: DateTimeFilter<"Notes"> | Date | string
    needs_sync?: BoolFilter<"Notes"> | boolean
    is_deleted?: BoolFilter<"Notes"> | boolean
  }

  export type RegistrationsUpsertWithWhereUniqueWithoutStudentInput = {
    where: RegistrationsWhereUniqueInput
    update: XOR<RegistrationsUpdateWithoutStudentInput, RegistrationsUncheckedUpdateWithoutStudentInput>
    create: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput>
  }

  export type RegistrationsUpdateWithWhereUniqueWithoutStudentInput = {
    where: RegistrationsWhereUniqueInput
    data: XOR<RegistrationsUpdateWithoutStudentInput, RegistrationsUncheckedUpdateWithoutStudentInput>
  }

  export type RegistrationsUpdateManyWithWhereWithoutStudentInput = {
    where: RegistrationsScalarWhereInput
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentsUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentParentsWhereUniqueInput
    update: XOR<StudentParentsUpdateWithoutStudentInput, StudentParentsUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentsUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentParentsWhereUniqueInput
    data: XOR<StudentParentsUpdateWithoutStudentInput, StudentParentsUncheckedUpdateWithoutStudentInput>
  }

  export type StudentParentsUpdateManyWithWhereWithoutStudentInput = {
    where: StudentParentsScalarWhereInput
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentsScalarWhereInput = {
    AND?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
    OR?: StudentParentsScalarWhereInput[]
    NOT?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
    id?: IntFilter<"StudentParents"> | number
    student_id?: IntFilter<"StudentParents"> | number
    parent_id?: IntFilter<"StudentParents"> | number
    relation?: StringNullableFilter<"StudentParents"> | string | null
    supabase_id?: StringNullableFilter<"StudentParents"> | string | null
    last_modified?: DateTimeFilter<"StudentParents"> | Date | string
    needs_sync?: BoolFilter<"StudentParents"> | boolean
    is_deleted?: BoolFilter<"StudentParents"> | boolean
  }

  export type PaymentsCreateWithoutRegistrationInput = {
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    period_identifier?: string | null
    single_fee?: SingleFeeCreateNestedOneWithoutPaymentsInput
    fee_template?: FeeTemplateCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutRegistrationInput = {
    id?: number
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: number | null
    fee_template_id?: number | null
    period_identifier?: string | null
  }

  export type PaymentsCreateOrConnectWithoutRegistrationInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput>
  }

  export type PaymentsCreateManyRegistrationInputEnvelope = {
    data: PaymentsCreateManyRegistrationInput | PaymentsCreateManyRegistrationInput[]
  }

  export type ClassesCreateWithoutRegistrationsInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutRegistrationsInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeUncheckedCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutRegistrationsInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
  }

  export type StudentsCreateWithoutRegistrationsInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    notes?: NotesCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutRegistrationsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutRegistrationsInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
  }

  export type PaymentsUpsertWithWhereUniqueWithoutRegistrationInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutRegistrationInput, PaymentsUncheckedUpdateWithoutRegistrationInput>
    create: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutRegistrationInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutRegistrationInput, PaymentsUncheckedUpdateWithoutRegistrationInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutRegistrationInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutRegistrationInput>
  }

  export type PaymentsScalarWhereInput = {
    AND?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    OR?: PaymentsScalarWhereInput[]
    NOT?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    id?: IntFilter<"Payments"> | number
    registration_id?: IntNullableFilter<"Payments"> | number | null
    amount?: FloatNullableFilter<"Payments"> | number | null
    method?: StringNullableFilter<"Payments"> | string | null
    date?: StringNullableFilter<"Payments"> | string | null
    reference?: StringNullableFilter<"Payments"> | string | null
    emitter_id?: StringNullableFilter<"Payments"> | string | null
    supabase_id?: StringNullableFilter<"Payments"> | string | null
    last_modified?: DateTimeFilter<"Payments"> | Date | string
    needs_sync?: BoolFilter<"Payments"> | boolean
    is_deleted?: BoolFilter<"Payments"> | boolean
    single_fee_id?: IntNullableFilter<"Payments"> | number | null
    fee_template_id?: IntNullableFilter<"Payments"> | number | null
    period_identifier?: StringNullableFilter<"Payments"> | string | null
  }

  export type ClassesUpsertWithoutRegistrationsInput = {
    update: XOR<ClassesUpdateWithoutRegistrationsInput, ClassesUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutRegistrationsInput, ClassesUncheckedUpdateWithoutRegistrationsInput>
  }

  export type ClassesUpdateWithoutRegistrationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUncheckedUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentsUpsertWithoutRegistrationsInput = {
    update: XOR<StudentsUpdateWithoutRegistrationsInput, StudentsUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutRegistrationsInput, StudentsUncheckedUpdateWithoutRegistrationsInput>
  }

  export type StudentsUpdateWithoutRegistrationsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    notes?: NotesUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LessonsCreateWithoutTeacherInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutTeacherInput = {
    id?: number
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutTeacherInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput>
  }

  export type LessonsCreateManyTeacherInputEnvelope = {
    data: LessonsCreateManyTeacherInput | LessonsCreateManyTeacherInput[]
  }

  export type TeacherWorkHoursCreateWithoutTeacherInput = {
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: SubjectsCreateNestedOneWithoutWorkHoursInput
  }

  export type TeacherWorkHoursUncheckedCreateWithoutTeacherInput = {
    id?: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateOrConnectWithoutTeacherInput = {
    where: TeacherWorkHoursWhereUniqueInput
    create: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherWorkHoursCreateManyTeacherInputEnvelope = {
    data: TeacherWorkHoursCreateManyTeacherInput | TeacherWorkHoursCreateManyTeacherInput[]
  }

  export type EmployeeAttendanceCreateWithoutTeacherInput = {
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: EmployeesCreateNestedOneWithoutAttendancesInput
  }

  export type EmployeeAttendanceUncheckedCreateWithoutTeacherInput = {
    id?: number
    employee_id?: number | null
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeeAttendanceCreateOrConnectWithoutTeacherInput = {
    where: EmployeeAttendanceWhereUniqueInput
    create: XOR<EmployeeAttendanceCreateWithoutTeacherInput, EmployeeAttendanceUncheckedCreateWithoutTeacherInput>
  }

  export type EmployeeAttendanceCreateManyTeacherInputEnvelope = {
    data: EmployeeAttendanceCreateManyTeacherInput | EmployeeAttendanceCreateManyTeacherInput[]
  }

  export type LessonsUpsertWithWhereUniqueWithoutTeacherInput = {
    where: LessonsWhereUniqueInput
    update: XOR<LessonsUpdateWithoutTeacherInput, LessonsUncheckedUpdateWithoutTeacherInput>
    create: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput>
  }

  export type LessonsUpdateWithWhereUniqueWithoutTeacherInput = {
    where: LessonsWhereUniqueInput
    data: XOR<LessonsUpdateWithoutTeacherInput, LessonsUncheckedUpdateWithoutTeacherInput>
  }

  export type LessonsUpdateManyWithWhereWithoutTeacherInput = {
    where: LessonsScalarWhereInput
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherWorkHoursWhereUniqueInput
    update: XOR<TeacherWorkHoursUpdateWithoutTeacherInput, TeacherWorkHoursUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherWorkHoursWhereUniqueInput
    data: XOR<TeacherWorkHoursUpdateWithoutTeacherInput, TeacherWorkHoursUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherWorkHoursScalarWhereInput
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherWorkHoursScalarWhereInput = {
    AND?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
    OR?: TeacherWorkHoursScalarWhereInput[]
    NOT?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
    id?: IntFilter<"TeacherWorkHours"> | number
    teacher_id?: IntFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    hours?: FloatFilter<"TeacherWorkHours"> | number
    notes?: StringNullableFilter<"TeacherWorkHours"> | string | null
    supabase_id?: StringNullableFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolFilter<"TeacherWorkHours"> | boolean
  }

  export type EmployeeAttendanceUpsertWithWhereUniqueWithoutTeacherInput = {
    where: EmployeeAttendanceWhereUniqueInput
    update: XOR<EmployeeAttendanceUpdateWithoutTeacherInput, EmployeeAttendanceUncheckedUpdateWithoutTeacherInput>
    create: XOR<EmployeeAttendanceCreateWithoutTeacherInput, EmployeeAttendanceUncheckedCreateWithoutTeacherInput>
  }

  export type EmployeeAttendanceUpdateWithWhereUniqueWithoutTeacherInput = {
    where: EmployeeAttendanceWhereUniqueInput
    data: XOR<EmployeeAttendanceUpdateWithoutTeacherInput, EmployeeAttendanceUncheckedUpdateWithoutTeacherInput>
  }

  export type EmployeeAttendanceUpdateManyWithWhereWithoutTeacherInput = {
    where: EmployeeAttendanceScalarWhereInput
    data: XOR<EmployeeAttendanceUpdateManyMutationInput, EmployeeAttendanceUncheckedUpdateManyWithoutTeacherInput>
  }

  export type EmployeeAttendanceScalarWhereInput = {
    AND?: EmployeeAttendanceScalarWhereInput | EmployeeAttendanceScalarWhereInput[]
    OR?: EmployeeAttendanceScalarWhereInput[]
    NOT?: EmployeeAttendanceScalarWhereInput | EmployeeAttendanceScalarWhereInput[]
    id?: IntFilter<"EmployeeAttendance"> | number
    employee_id?: IntNullableFilter<"EmployeeAttendance"> | number | null
    teacher_id?: IntNullableFilter<"EmployeeAttendance"> | number | null
    check_in?: DateTimeFilter<"EmployeeAttendance"> | Date | string
    check_out?: DateTimeNullableFilter<"EmployeeAttendance"> | Date | string | null
    notes?: StringNullableFilter<"EmployeeAttendance"> | string | null
    school_id?: StringNullableFilter<"EmployeeAttendance"> | string | null
    supabase_id?: StringNullableFilter<"EmployeeAttendance"> | string | null
    last_modified?: DateTimeFilter<"EmployeeAttendance"> | Date | string
    needs_sync?: BoolFilter<"EmployeeAttendance"> | boolean
    is_deleted?: BoolFilter<"EmployeeAttendance"> | boolean
  }

  export type SubjectsCreateWithoutWorkHoursInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutSubjectInput
    class: ClassesCreateNestedOneWithoutSubjectsInput
  }

  export type SubjectsUncheckedCreateWithoutWorkHoursInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsCreateOrConnectWithoutWorkHoursInput = {
    where: SubjectsWhereUniqueInput
    create: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
  }

  export type TeachersCreateWithoutWorkHoursInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsCreateNestedManyWithoutTeacherInput
    attendances?: EmployeeAttendanceCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUncheckedCreateWithoutWorkHoursInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsUncheckedCreateNestedManyWithoutTeacherInput
    attendances?: EmployeeAttendanceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeachersCreateOrConnectWithoutWorkHoursInput = {
    where: TeachersWhereUniqueInput
    create: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
  }

  export type SubjectsUpsertWithoutWorkHoursInput = {
    update: XOR<SubjectsUpdateWithoutWorkHoursInput, SubjectsUncheckedUpdateWithoutWorkHoursInput>
    create: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
    where?: SubjectsWhereInput
  }

  export type SubjectsUpdateToOneWithWhereWithoutWorkHoursInput = {
    where?: SubjectsWhereInput
    data: XOR<SubjectsUpdateWithoutWorkHoursInput, SubjectsUncheckedUpdateWithoutWorkHoursInput>
  }

  export type SubjectsUpdateWithoutWorkHoursInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutSubjectNestedInput
    class?: ClassesUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type SubjectsUncheckedUpdateWithoutWorkHoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeachersUpsertWithoutWorkHoursInput = {
    update: XOR<TeachersUpdateWithoutWorkHoursInput, TeachersUncheckedUpdateWithoutWorkHoursInput>
    create: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
    where?: TeachersWhereInput
  }

  export type TeachersUpdateToOneWithWhereWithoutWorkHoursInput = {
    where?: TeachersWhereInput
    data: XOR<TeachersUpdateWithoutWorkHoursInput, TeachersUncheckedUpdateWithoutWorkHoursInput>
  }

  export type TeachersUpdateWithoutWorkHoursInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUpdateManyWithoutTeacherNestedInput
    attendances?: EmployeeAttendanceUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersUncheckedUpdateWithoutWorkHoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUncheckedUpdateManyWithoutTeacherNestedInput
    attendances?: EmployeeAttendanceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SubjectsCreateWithoutLessonsInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class: ClassesCreateNestedOneWithoutSubjectsInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUncheckedCreateWithoutLessonsInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsCreateOrConnectWithoutLessonsInput = {
    where: SubjectsWhereUniqueInput
    create: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
  }

  export type ClassesCreateWithoutLessonsInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutLessonsInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeUncheckedCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutLessonsInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
  }

  export type TeachersCreateWithoutLessonsInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    workHours?: TeacherWorkHoursCreateNestedManyWithoutTeacherInput
    attendances?: EmployeeAttendanceCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUncheckedCreateWithoutLessonsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutTeacherInput
    attendances?: EmployeeAttendanceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeachersCreateOrConnectWithoutLessonsInput = {
    where: TeachersWhereUniqueInput
    create: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
  }

  export type NotesCreateWithoutLessonInput = {
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    student: StudentsCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateWithoutLessonInput = {
    id?: number
    student_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesCreateOrConnectWithoutLessonInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput>
  }

  export type NotesCreateManyLessonInputEnvelope = {
    data: NotesCreateManyLessonInput | NotesCreateManyLessonInput[]
  }

  export type SchedulesCreateWithoutLessonInput = {
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesUncheckedCreateWithoutLessonInput = {
    id?: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesCreateOrConnectWithoutLessonInput = {
    where: SchedulesWhereUniqueInput
    create: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput>
  }

  export type SchedulesCreateManyLessonInputEnvelope = {
    data: SchedulesCreateManyLessonInput | SchedulesCreateManyLessonInput[]
  }

  export type SubjectsUpsertWithoutLessonsInput = {
    update: XOR<SubjectsUpdateWithoutLessonsInput, SubjectsUncheckedUpdateWithoutLessonsInput>
    create: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
    where?: SubjectsWhereInput
  }

  export type SubjectsUpdateToOneWithWhereWithoutLessonsInput = {
    where?: SubjectsWhereInput
    data: XOR<SubjectsUpdateWithoutLessonsInput, SubjectsUncheckedUpdateWithoutLessonsInput>
  }

  export type SubjectsUpdateWithoutLessonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneRequiredWithoutSubjectsNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ClassesUpsertWithoutLessonsInput = {
    update: XOR<ClassesUpdateWithoutLessonsInput, ClassesUncheckedUpdateWithoutLessonsInput>
    create: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutLessonsInput, ClassesUncheckedUpdateWithoutLessonsInput>
  }

  export type ClassesUpdateWithoutLessonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUncheckedUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeachersUpsertWithoutLessonsInput = {
    update: XOR<TeachersUpdateWithoutLessonsInput, TeachersUncheckedUpdateWithoutLessonsInput>
    create: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
    where?: TeachersWhereInput
  }

  export type TeachersUpdateToOneWithWhereWithoutLessonsInput = {
    where?: TeachersWhereInput
    data: XOR<TeachersUpdateWithoutLessonsInput, TeachersUncheckedUpdateWithoutLessonsInput>
  }

  export type TeachersUpdateWithoutLessonsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    workHours?: TeacherWorkHoursUpdateManyWithoutTeacherNestedInput
    attendances?: EmployeeAttendanceUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutTeacherNestedInput
    attendances?: EmployeeAttendanceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type NotesUpsertWithWhereUniqueWithoutLessonInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutLessonInput, NotesUncheckedUpdateWithoutLessonInput>
    create: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutLessonInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutLessonInput, NotesUncheckedUpdateWithoutLessonInput>
  }

  export type NotesUpdateManyWithWhereWithoutLessonInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutLessonInput>
  }

  export type SchedulesUpsertWithWhereUniqueWithoutLessonInput = {
    where: SchedulesWhereUniqueInput
    update: XOR<SchedulesUpdateWithoutLessonInput, SchedulesUncheckedUpdateWithoutLessonInput>
    create: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput>
  }

  export type SchedulesUpdateWithWhereUniqueWithoutLessonInput = {
    where: SchedulesWhereUniqueInput
    data: XOR<SchedulesUpdateWithoutLessonInput, SchedulesUncheckedUpdateWithoutLessonInput>
  }

  export type SchedulesUpdateManyWithWhereWithoutLessonInput = {
    where: SchedulesScalarWhereInput
    data: XOR<SchedulesUpdateManyMutationInput, SchedulesUncheckedUpdateManyWithoutLessonInput>
  }

  export type SchedulesScalarWhereInput = {
    AND?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
    OR?: SchedulesScalarWhereInput[]
    NOT?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
    id?: IntFilter<"Schedules"> | number
    lesson_id?: IntFilter<"Schedules"> | number
    day_of_week?: StringNullableFilter<"Schedules"> | string | null
    start_time?: StringNullableFilter<"Schedules"> | string | null
    end_time?: StringNullableFilter<"Schedules"> | string | null
    supabase_id?: StringNullableFilter<"Schedules"> | string | null
    last_modified?: DateTimeFilter<"Schedules"> | Date | string
    needs_sync?: BoolFilter<"Schedules"> | boolean
    is_deleted?: BoolFilter<"Schedules"> | boolean
  }

  export type LessonsCreateWithoutSubjectInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutSubjectInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutSubjectInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput>
  }

  export type LessonsCreateManySubjectInputEnvelope = {
    data: LessonsCreateManySubjectInput | LessonsCreateManySubjectInput[]
  }

  export type ClassesCreateWithoutSubjectsInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutSubjectsInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeUncheckedCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutSubjectsInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
  }

  export type TeacherWorkHoursCreateWithoutSubjectInput = {
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    teacher: TeachersCreateNestedOneWithoutWorkHoursInput
  }

  export type TeacherWorkHoursUncheckedCreateWithoutSubjectInput = {
    id?: number
    teacher_id: number
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateOrConnectWithoutSubjectInput = {
    where: TeacherWorkHoursWhereUniqueInput
    create: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherWorkHoursCreateManySubjectInputEnvelope = {
    data: TeacherWorkHoursCreateManySubjectInput | TeacherWorkHoursCreateManySubjectInput[]
  }

  export type LessonsUpsertWithWhereUniqueWithoutSubjectInput = {
    where: LessonsWhereUniqueInput
    update: XOR<LessonsUpdateWithoutSubjectInput, LessonsUncheckedUpdateWithoutSubjectInput>
    create: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput>
  }

  export type LessonsUpdateWithWhereUniqueWithoutSubjectInput = {
    where: LessonsWhereUniqueInput
    data: XOR<LessonsUpdateWithoutSubjectInput, LessonsUncheckedUpdateWithoutSubjectInput>
  }

  export type LessonsUpdateManyWithWhereWithoutSubjectInput = {
    where: LessonsScalarWhereInput
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ClassesUpsertWithoutSubjectsInput = {
    update: XOR<ClassesUpdateWithoutSubjectsInput, ClassesUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutSubjectsInput, ClassesUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassesUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUncheckedUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TeacherWorkHoursWhereUniqueInput
    update: XOR<TeacherWorkHoursUpdateWithoutSubjectInput, TeacherWorkHoursUncheckedUpdateWithoutSubjectInput>
    create: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TeacherWorkHoursWhereUniqueInput
    data: XOR<TeacherWorkHoursUpdateWithoutSubjectInput, TeacherWorkHoursUncheckedUpdateWithoutSubjectInput>
  }

  export type TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput = {
    where: TeacherWorkHoursScalarWhereInput
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyWithoutSubjectInput>
  }

  export type LessonsCreateWithoutNotesInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutNotesInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutNotesInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
  }

  export type StudentsCreateWithoutNotesInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutNotesInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutNotesInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
  }

  export type LessonsUpsertWithoutNotesInput = {
    update: XOR<LessonsUpdateWithoutNotesInput, LessonsUncheckedUpdateWithoutNotesInput>
    create: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
    where?: LessonsWhereInput
  }

  export type LessonsUpdateToOneWithWhereWithoutNotesInput = {
    where?: LessonsWhereInput
    data: XOR<LessonsUpdateWithoutNotesInput, LessonsUncheckedUpdateWithoutNotesInput>
  }

  export type LessonsUpdateWithoutNotesInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type StudentsUpsertWithoutNotesInput = {
    update: XOR<StudentsUpdateWithoutNotesInput, StudentsUncheckedUpdateWithoutNotesInput>
    create: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutNotesInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutNotesInput, StudentsUncheckedUpdateWithoutNotesInput>
  }

  export type StudentsUpdateWithoutNotesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentParentsCreateWithoutParentInput = {
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    student: StudentsCreateNestedOneWithoutStudent_parentsInput
  }

  export type StudentParentsUncheckedCreateWithoutParentInput = {
    id?: number
    student_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsCreateOrConnectWithoutParentInput = {
    where: StudentParentsWhereUniqueInput
    create: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput>
  }

  export type StudentParentsCreateManyParentInputEnvelope = {
    data: StudentParentsCreateManyParentInput | StudentParentsCreateManyParentInput[]
  }

  export type StudentParentsUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentParentsWhereUniqueInput
    update: XOR<StudentParentsUpdateWithoutParentInput, StudentParentsUncheckedUpdateWithoutParentInput>
    create: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput>
  }

  export type StudentParentsUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentParentsWhereUniqueInput
    data: XOR<StudentParentsUpdateWithoutParentInput, StudentParentsUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentsUpdateManyWithWhereWithoutParentInput = {
    where: StudentParentsScalarWhereInput
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyWithoutParentInput>
  }

  export type ParentsCreateWithoutStudent_parentsInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
  }

  export type ParentsUncheckedCreateWithoutStudent_parentsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
  }

  export type ParentsCreateOrConnectWithoutStudent_parentsInput = {
    where: ParentsWhereUniqueInput
    create: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
  }

  export type StudentsCreateWithoutStudent_parentsInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    notes?: NotesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutStudent_parentsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutStudent_parentsInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
  }

  export type ParentsUpsertWithoutStudent_parentsInput = {
    update: XOR<ParentsUpdateWithoutStudent_parentsInput, ParentsUncheckedUpdateWithoutStudent_parentsInput>
    create: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
    where?: ParentsWhereInput
  }

  export type ParentsUpdateToOneWithWhereWithoutStudent_parentsInput = {
    where?: ParentsWhereInput
    data: XOR<ParentsUpdateWithoutStudent_parentsInput, ParentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type ParentsUpdateWithoutStudent_parentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentsUncheckedUpdateWithoutStudent_parentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentsUpsertWithoutStudent_parentsInput = {
    update: XOR<StudentsUpdateWithoutStudent_parentsInput, StudentsUncheckedUpdateWithoutStudent_parentsInput>
    create: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutStudent_parentsInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutStudent_parentsInput, StudentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type StudentsUpdateWithoutStudent_parentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    notes?: NotesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutStudent_parentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type RegistrationsCreateWithoutPaymentsInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class: ClassesCreateNestedOneWithoutRegistrationsInput
    student: StudentsCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateWithoutPaymentsInput = {
    id?: number
    student_id: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsCreateOrConnectWithoutPaymentsInput = {
    where: RegistrationsWhereUniqueInput
    create: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
  }

  export type SingleFeeCreateWithoutPaymentsInput = {
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class?: ClassesCreateNestedOneWithoutSingle_feesInput
    dispatch_rules?: DispatchRuleCreateNestedManyWithoutSource_single_feeInput
  }

  export type SingleFeeUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    class_id?: number | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rules?: DispatchRuleUncheckedCreateNestedManyWithoutSource_single_feeInput
  }

  export type SingleFeeCreateOrConnectWithoutPaymentsInput = {
    where: SingleFeeWhereUniqueInput
    create: XOR<SingleFeeCreateWithoutPaymentsInput, SingleFeeUncheckedCreateWithoutPaymentsInput>
  }

  export type FeeTemplateCreateWithoutPaymentsInput = {
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class?: ClassesCreateNestedOneWithoutFee_templatesInput
  }

  export type FeeTemplateUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    applies_to_class_id?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeeTemplateCreateOrConnectWithoutPaymentsInput = {
    where: FeeTemplateWhereUniqueInput
    create: XOR<FeeTemplateCreateWithoutPaymentsInput, FeeTemplateUncheckedCreateWithoutPaymentsInput>
  }

  export type RegistrationsUpsertWithoutPaymentsInput = {
    update: XOR<RegistrationsUpdateWithoutPaymentsInput, RegistrationsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
    where?: RegistrationsWhereInput
  }

  export type RegistrationsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: RegistrationsWhereInput
    data: XOR<RegistrationsUpdateWithoutPaymentsInput, RegistrationsUncheckedUpdateWithoutPaymentsInput>
  }

  export type RegistrationsUpdateWithoutPaymentsInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneRequiredWithoutRegistrationsNestedInput
    student?: StudentsUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SingleFeeUpsertWithoutPaymentsInput = {
    update: XOR<SingleFeeUpdateWithoutPaymentsInput, SingleFeeUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SingleFeeCreateWithoutPaymentsInput, SingleFeeUncheckedCreateWithoutPaymentsInput>
    where?: SingleFeeWhereInput
  }

  export type SingleFeeUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SingleFeeWhereInput
    data: XOR<SingleFeeUpdateWithoutPaymentsInput, SingleFeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type SingleFeeUpdateWithoutPaymentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneWithoutSingle_feesNestedInput
    dispatch_rules?: DispatchRuleUpdateManyWithoutSource_single_feeNestedInput
  }

  export type SingleFeeUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    class_id?: NullableIntFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    dispatch_rules?: DispatchRuleUncheckedUpdateManyWithoutSource_single_feeNestedInput
  }

  export type FeeTemplateUpsertWithoutPaymentsInput = {
    update: XOR<FeeTemplateUpdateWithoutPaymentsInput, FeeTemplateUncheckedUpdateWithoutPaymentsInput>
    create: XOR<FeeTemplateCreateWithoutPaymentsInput, FeeTemplateUncheckedCreateWithoutPaymentsInput>
    where?: FeeTemplateWhereInput
  }

  export type FeeTemplateUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: FeeTemplateWhereInput
    data: XOR<FeeTemplateUpdateWithoutPaymentsInput, FeeTemplateUncheckedUpdateWithoutPaymentsInput>
  }

  export type FeeTemplateUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneWithoutFee_templatesNestedInput
  }

  export type FeeTemplateUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassesCreateWithoutSingle_feesInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutSingle_feesInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
    fee_templates?: FeeTemplateUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutSingle_feesInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutSingle_feesInput, ClassesUncheckedCreateWithoutSingle_feesInput>
  }

  export type PaymentsCreateWithoutSingle_feeInput = {
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    period_identifier?: string | null
    registration?: RegistrationsCreateNestedOneWithoutPaymentsInput
    fee_template?: FeeTemplateCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutSingle_feeInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    fee_template_id?: number | null
    period_identifier?: string | null
  }

  export type PaymentsCreateOrConnectWithoutSingle_feeInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutSingle_feeInput, PaymentsUncheckedCreateWithoutSingle_feeInput>
  }

  export type PaymentsCreateManySingle_feeInputEnvelope = {
    data: PaymentsCreateManySingle_feeInput | PaymentsCreateManySingle_feeInput[]
  }

  export type DispatchRuleCreateWithoutSource_single_feeInput = {
    name: string
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    details?: DispatchRuleDetailCreateNestedManyWithoutDispatch_ruleInput
  }

  export type DispatchRuleUncheckedCreateWithoutSource_single_feeInput = {
    id?: number
    name: string
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    details?: DispatchRuleDetailUncheckedCreateNestedManyWithoutDispatch_ruleInput
  }

  export type DispatchRuleCreateOrConnectWithoutSource_single_feeInput = {
    where: DispatchRuleWhereUniqueInput
    create: XOR<DispatchRuleCreateWithoutSource_single_feeInput, DispatchRuleUncheckedCreateWithoutSource_single_feeInput>
  }

  export type DispatchRuleCreateManySource_single_feeInputEnvelope = {
    data: DispatchRuleCreateManySource_single_feeInput | DispatchRuleCreateManySource_single_feeInput[]
  }

  export type ClassesUpsertWithoutSingle_feesInput = {
    update: XOR<ClassesUpdateWithoutSingle_feesInput, ClassesUncheckedUpdateWithoutSingle_feesInput>
    create: XOR<ClassesCreateWithoutSingle_feesInput, ClassesUncheckedCreateWithoutSingle_feesInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutSingle_feesInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutSingle_feesInput, ClassesUncheckedUpdateWithoutSingle_feesInput>
  }

  export type ClassesUpdateWithoutSingle_feesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutSingle_feesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
    fee_templates?: FeeTemplateUncheckedUpdateManyWithoutClassNestedInput
  }

  export type PaymentsUpsertWithWhereUniqueWithoutSingle_feeInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutSingle_feeInput, PaymentsUncheckedUpdateWithoutSingle_feeInput>
    create: XOR<PaymentsCreateWithoutSingle_feeInput, PaymentsUncheckedCreateWithoutSingle_feeInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutSingle_feeInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutSingle_feeInput, PaymentsUncheckedUpdateWithoutSingle_feeInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutSingle_feeInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutSingle_feeInput>
  }

  export type DispatchRuleUpsertWithWhereUniqueWithoutSource_single_feeInput = {
    where: DispatchRuleWhereUniqueInput
    update: XOR<DispatchRuleUpdateWithoutSource_single_feeInput, DispatchRuleUncheckedUpdateWithoutSource_single_feeInput>
    create: XOR<DispatchRuleCreateWithoutSource_single_feeInput, DispatchRuleUncheckedCreateWithoutSource_single_feeInput>
  }

  export type DispatchRuleUpdateWithWhereUniqueWithoutSource_single_feeInput = {
    where: DispatchRuleWhereUniqueInput
    data: XOR<DispatchRuleUpdateWithoutSource_single_feeInput, DispatchRuleUncheckedUpdateWithoutSource_single_feeInput>
  }

  export type DispatchRuleUpdateManyWithWhereWithoutSource_single_feeInput = {
    where: DispatchRuleScalarWhereInput
    data: XOR<DispatchRuleUpdateManyMutationInput, DispatchRuleUncheckedUpdateManyWithoutSource_single_feeInput>
  }

  export type DispatchRuleScalarWhereInput = {
    AND?: DispatchRuleScalarWhereInput | DispatchRuleScalarWhereInput[]
    OR?: DispatchRuleScalarWhereInput[]
    NOT?: DispatchRuleScalarWhereInput | DispatchRuleScalarWhereInput[]
    id?: IntFilter<"DispatchRule"> | number
    name?: StringFilter<"DispatchRule"> | string
    source_single_fee_id?: IntFilter<"DispatchRule"> | number
    school_id?: StringFilter<"DispatchRule"> | string
    supabase_id?: StringNullableFilter<"DispatchRule"> | string | null
    last_modified?: DateTimeFilter<"DispatchRule"> | Date | string
    needs_sync?: BoolFilter<"DispatchRule"> | boolean
    is_deleted?: BoolFilter<"DispatchRule"> | boolean
  }

  export type ClassesCreateWithoutFee_templatesInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutFee_templatesInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
    single_fees?: SingleFeeUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutFee_templatesInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutFee_templatesInput, ClassesUncheckedCreateWithoutFee_templatesInput>
  }

  export type PaymentsCreateWithoutFee_templateInput = {
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    period_identifier?: string | null
    registration?: RegistrationsCreateNestedOneWithoutPaymentsInput
    single_fee?: SingleFeeCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutFee_templateInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: number | null
    period_identifier?: string | null
  }

  export type PaymentsCreateOrConnectWithoutFee_templateInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutFee_templateInput, PaymentsUncheckedCreateWithoutFee_templateInput>
  }

  export type PaymentsCreateManyFee_templateInputEnvelope = {
    data: PaymentsCreateManyFee_templateInput | PaymentsCreateManyFee_templateInput[]
  }

  export type ClassesUpsertWithoutFee_templatesInput = {
    update: XOR<ClassesUpdateWithoutFee_templatesInput, ClassesUncheckedUpdateWithoutFee_templatesInput>
    create: XOR<ClassesCreateWithoutFee_templatesInput, ClassesUncheckedCreateWithoutFee_templatesInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutFee_templatesInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutFee_templatesInput, ClassesUncheckedUpdateWithoutFee_templatesInput>
  }

  export type ClassesUpdateWithoutFee_templatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutFee_templatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
    single_fees?: SingleFeeUncheckedUpdateManyWithoutClassNestedInput
  }

  export type PaymentsUpsertWithWhereUniqueWithoutFee_templateInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutFee_templateInput, PaymentsUncheckedUpdateWithoutFee_templateInput>
    create: XOR<PaymentsCreateWithoutFee_templateInput, PaymentsUncheckedCreateWithoutFee_templateInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutFee_templateInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutFee_templateInput, PaymentsUncheckedUpdateWithoutFee_templateInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutFee_templateInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutFee_templateInput>
  }

  export type StudentsCreateWithoutAttendancesInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    notes?: NotesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutAttendancesInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutAttendancesInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
  }

  export type StudentsUpsertWithoutAttendancesInput = {
    update: XOR<StudentsUpdateWithoutAttendancesInput, StudentsUncheckedUpdateWithoutAttendancesInput>
    create: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutAttendancesInput, StudentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentsUpdateWithoutAttendancesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NotesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutAttendancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SalaryPaymentsCreateWithoutEmployeeInput = {
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUncheckedCreateWithoutEmployeeInput = {
    id?: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsCreateOrConnectWithoutEmployeeInput = {
    where: SalaryPaymentsWhereUniqueInput
    create: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentsCreateManyEmployeeInputEnvelope = {
    data: SalaryPaymentsCreateManyEmployeeInput | SalaryPaymentsCreateManyEmployeeInput[]
  }

  export type EmployeeAttendanceCreateWithoutEmployeeInput = {
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    teacher?: TeachersCreateNestedOneWithoutAttendancesInput
  }

  export type EmployeeAttendanceUncheckedCreateWithoutEmployeeInput = {
    id?: number
    teacher_id?: number | null
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeeAttendanceCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeAttendanceWhereUniqueInput
    create: XOR<EmployeeAttendanceCreateWithoutEmployeeInput, EmployeeAttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeAttendanceCreateManyEmployeeInputEnvelope = {
    data: EmployeeAttendanceCreateManyEmployeeInput | EmployeeAttendanceCreateManyEmployeeInput[]
  }

  export type SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentsWhereUniqueInput
    update: XOR<SalaryPaymentsUpdateWithoutEmployeeInput, SalaryPaymentsUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentsWhereUniqueInput
    data: XOR<SalaryPaymentsUpdateWithoutEmployeeInput, SalaryPaymentsUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryPaymentsScalarWhereInput
    data: XOR<SalaryPaymentsUpdateManyMutationInput, SalaryPaymentsUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SalaryPaymentsScalarWhereInput = {
    AND?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
    OR?: SalaryPaymentsScalarWhereInput[]
    NOT?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
    id?: IntFilter<"SalaryPayments"> | number
    employee_id?: IntFilter<"SalaryPayments"> | number
    base_salary?: FloatFilter<"SalaryPayments"> | number
    bonus_amount?: FloatFilter<"SalaryPayments"> | number
    total_amount?: FloatFilter<"SalaryPayments"> | number
    payment_date?: StringFilter<"SalaryPayments"> | string
    notes?: StringNullableFilter<"SalaryPayments"> | string | null
    supabase_id?: StringNullableFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolFilter<"SalaryPayments"> | boolean
  }

  export type EmployeeAttendanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeAttendanceWhereUniqueInput
    update: XOR<EmployeeAttendanceUpdateWithoutEmployeeInput, EmployeeAttendanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeAttendanceCreateWithoutEmployeeInput, EmployeeAttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeAttendanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeAttendanceWhereUniqueInput
    data: XOR<EmployeeAttendanceUpdateWithoutEmployeeInput, EmployeeAttendanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeAttendanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeAttendanceScalarWhereInput
    data: XOR<EmployeeAttendanceUpdateManyMutationInput, EmployeeAttendanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeesCreateWithoutSalary_paymentsInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    attendances?: EmployeeAttendanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateWithoutSalary_paymentsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    attendances?: EmployeeAttendanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesCreateOrConnectWithoutSalary_paymentsInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
  }

  export type EmployeesUpsertWithoutSalary_paymentsInput = {
    update: XOR<EmployeesUpdateWithoutSalary_paymentsInput, EmployeesUncheckedUpdateWithoutSalary_paymentsInput>
    create: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutSalary_paymentsInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutSalary_paymentsInput, EmployeesUncheckedUpdateWithoutSalary_paymentsInput>
  }

  export type EmployeesUpdateWithoutSalary_paymentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    attendances?: EmployeeAttendanceUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutSalary_paymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    attendances?: EmployeeAttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LessonsCreateWithoutSchedulesInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutSchedulesInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutSchedulesInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
  }

  export type LessonsUpsertWithoutSchedulesInput = {
    update: XOR<LessonsUpdateWithoutSchedulesInput, LessonsUncheckedUpdateWithoutSchedulesInput>
    create: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
    where?: LessonsWhereInput
  }

  export type LessonsUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: LessonsWhereInput
    data: XOR<LessonsUpdateWithoutSchedulesInput, LessonsUncheckedUpdateWithoutSchedulesInput>
  }

  export type LessonsUpdateWithoutSchedulesInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type FinancialTransactionCreateWithoutCategoryInput = {
    date: Date | string
    description: string
    amount: number
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialTransactionUncheckedCreateWithoutCategoryInput = {
    id?: number
    date: Date | string
    description: string
    amount: number
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialTransactionCreateOrConnectWithoutCategoryInput = {
    where: FinancialTransactionWhereUniqueInput
    create: XOR<FinancialTransactionCreateWithoutCategoryInput, FinancialTransactionUncheckedCreateWithoutCategoryInput>
  }

  export type FinancialTransactionCreateManyCategoryInputEnvelope = {
    data: FinancialTransactionCreateManyCategoryInput | FinancialTransactionCreateManyCategoryInput[]
  }

  export type DispatchRuleDetailCreateWithoutDestination_categoryInput = {
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rule: DispatchRuleCreateNestedOneWithoutDetailsInput
  }

  export type DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput = {
    id?: number
    dispatch_rule_id: number
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleDetailCreateOrConnectWithoutDestination_categoryInput = {
    where: DispatchRuleDetailWhereUniqueInput
    create: XOR<DispatchRuleDetailCreateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput>
  }

  export type DispatchRuleDetailCreateManyDestination_categoryInputEnvelope = {
    data: DispatchRuleDetailCreateManyDestination_categoryInput | DispatchRuleDetailCreateManyDestination_categoryInput[]
  }

  export type FinancialTransactionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: FinancialTransactionWhereUniqueInput
    update: XOR<FinancialTransactionUpdateWithoutCategoryInput, FinancialTransactionUncheckedUpdateWithoutCategoryInput>
    create: XOR<FinancialTransactionCreateWithoutCategoryInput, FinancialTransactionUncheckedCreateWithoutCategoryInput>
  }

  export type FinancialTransactionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: FinancialTransactionWhereUniqueInput
    data: XOR<FinancialTransactionUpdateWithoutCategoryInput, FinancialTransactionUncheckedUpdateWithoutCategoryInput>
  }

  export type FinancialTransactionUpdateManyWithWhereWithoutCategoryInput = {
    where: FinancialTransactionScalarWhereInput
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type FinancialTransactionScalarWhereInput = {
    AND?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
    OR?: FinancialTransactionScalarWhereInput[]
    NOT?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
    id?: IntFilter<"FinancialTransaction"> | number
    date?: DateTimeFilter<"FinancialTransaction"> | Date | string
    description?: StringFilter<"FinancialTransaction"> | string
    amount?: FloatFilter<"FinancialTransaction"> | number
    type?: StringFilter<"FinancialTransaction"> | string
    category_id?: IntFilter<"FinancialTransaction"> | number
    school_id?: StringNullableFilter<"FinancialTransaction"> | string | null
    supabase_id?: StringNullableFilter<"FinancialTransaction"> | string | null
    last_modified?: DateTimeFilter<"FinancialTransaction"> | Date | string
    needs_sync?: BoolFilter<"FinancialTransaction"> | boolean
    is_deleted?: BoolFilter<"FinancialTransaction"> | boolean
  }

  export type DispatchRuleDetailUpsertWithWhereUniqueWithoutDestination_categoryInput = {
    where: DispatchRuleDetailWhereUniqueInput
    update: XOR<DispatchRuleDetailUpdateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedUpdateWithoutDestination_categoryInput>
    create: XOR<DispatchRuleDetailCreateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedCreateWithoutDestination_categoryInput>
  }

  export type DispatchRuleDetailUpdateWithWhereUniqueWithoutDestination_categoryInput = {
    where: DispatchRuleDetailWhereUniqueInput
    data: XOR<DispatchRuleDetailUpdateWithoutDestination_categoryInput, DispatchRuleDetailUncheckedUpdateWithoutDestination_categoryInput>
  }

  export type DispatchRuleDetailUpdateManyWithWhereWithoutDestination_categoryInput = {
    where: DispatchRuleDetailScalarWhereInput
    data: XOR<DispatchRuleDetailUpdateManyMutationInput, DispatchRuleDetailUncheckedUpdateManyWithoutDestination_categoryInput>
  }

  export type DispatchRuleDetailScalarWhereInput = {
    AND?: DispatchRuleDetailScalarWhereInput | DispatchRuleDetailScalarWhereInput[]
    OR?: DispatchRuleDetailScalarWhereInput[]
    NOT?: DispatchRuleDetailScalarWhereInput | DispatchRuleDetailScalarWhereInput[]
    id?: IntFilter<"DispatchRuleDetail"> | number
    dispatch_rule_id?: IntFilter<"DispatchRuleDetail"> | number
    destination_category_id?: IntFilter<"DispatchRuleDetail"> | number
    percentage?: FloatFilter<"DispatchRuleDetail"> | number
    supabase_id?: StringNullableFilter<"DispatchRuleDetail"> | string | null
    last_modified?: DateTimeFilter<"DispatchRuleDetail"> | Date | string
    needs_sync?: BoolFilter<"DispatchRuleDetail"> | boolean
    is_deleted?: BoolFilter<"DispatchRuleDetail"> | boolean
  }

  export type FinancialCategoryCreateWithoutTransactionsInput = {
    name: string
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rule_details?: DispatchRuleDetailCreateNestedManyWithoutDestination_categoryInput
  }

  export type FinancialCategoryUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    dispatch_rule_details?: DispatchRuleDetailUncheckedCreateNestedManyWithoutDestination_categoryInput
  }

  export type FinancialCategoryCreateOrConnectWithoutTransactionsInput = {
    where: FinancialCategoryWhereUniqueInput
    create: XOR<FinancialCategoryCreateWithoutTransactionsInput, FinancialCategoryUncheckedCreateWithoutTransactionsInput>
  }

  export type FinancialCategoryUpsertWithoutTransactionsInput = {
    update: XOR<FinancialCategoryUpdateWithoutTransactionsInput, FinancialCategoryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<FinancialCategoryCreateWithoutTransactionsInput, FinancialCategoryUncheckedCreateWithoutTransactionsInput>
    where?: FinancialCategoryWhereInput
  }

  export type FinancialCategoryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: FinancialCategoryWhereInput
    data: XOR<FinancialCategoryUpdateWithoutTransactionsInput, FinancialCategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type FinancialCategoryUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    dispatch_rule_details?: DispatchRuleDetailUpdateManyWithoutDestination_categoryNestedInput
  }

  export type FinancialCategoryUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    dispatch_rule_details?: DispatchRuleDetailUncheckedUpdateManyWithoutDestination_categoryNestedInput
  }

  export type SingleFeeCreateWithoutDispatch_rulesInput = {
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class?: ClassesCreateNestedOneWithoutSingle_feesInput
    payments?: PaymentsCreateNestedManyWithoutSingle_feeInput
  }

  export type SingleFeeUncheckedCreateWithoutDispatch_rulesInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    class_id?: number | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutSingle_feeInput
  }

  export type SingleFeeCreateOrConnectWithoutDispatch_rulesInput = {
    where: SingleFeeWhereUniqueInput
    create: XOR<SingleFeeCreateWithoutDispatch_rulesInput, SingleFeeUncheckedCreateWithoutDispatch_rulesInput>
  }

  export type DispatchRuleDetailCreateWithoutDispatch_ruleInput = {
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    destination_category: FinancialCategoryCreateNestedOneWithoutDispatch_rule_detailsInput
  }

  export type DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput = {
    id?: number
    destination_category_id: number
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleDetailCreateOrConnectWithoutDispatch_ruleInput = {
    where: DispatchRuleDetailWhereUniqueInput
    create: XOR<DispatchRuleDetailCreateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput>
  }

  export type DispatchRuleDetailCreateManyDispatch_ruleInputEnvelope = {
    data: DispatchRuleDetailCreateManyDispatch_ruleInput | DispatchRuleDetailCreateManyDispatch_ruleInput[]
  }

  export type SingleFeeUpsertWithoutDispatch_rulesInput = {
    update: XOR<SingleFeeUpdateWithoutDispatch_rulesInput, SingleFeeUncheckedUpdateWithoutDispatch_rulesInput>
    create: XOR<SingleFeeCreateWithoutDispatch_rulesInput, SingleFeeUncheckedCreateWithoutDispatch_rulesInput>
    where?: SingleFeeWhereInput
  }

  export type SingleFeeUpdateToOneWithWhereWithoutDispatch_rulesInput = {
    where?: SingleFeeWhereInput
    data: XOR<SingleFeeUpdateWithoutDispatch_rulesInput, SingleFeeUncheckedUpdateWithoutDispatch_rulesInput>
  }

  export type SingleFeeUpdateWithoutDispatch_rulesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneWithoutSingle_feesNestedInput
    payments?: PaymentsUpdateManyWithoutSingle_feeNestedInput
  }

  export type SingleFeeUncheckedUpdateWithoutDispatch_rulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    class_id?: NullableIntFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutSingle_feeNestedInput
  }

  export type DispatchRuleDetailUpsertWithWhereUniqueWithoutDispatch_ruleInput = {
    where: DispatchRuleDetailWhereUniqueInput
    update: XOR<DispatchRuleDetailUpdateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedUpdateWithoutDispatch_ruleInput>
    create: XOR<DispatchRuleDetailCreateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedCreateWithoutDispatch_ruleInput>
  }

  export type DispatchRuleDetailUpdateWithWhereUniqueWithoutDispatch_ruleInput = {
    where: DispatchRuleDetailWhereUniqueInput
    data: XOR<DispatchRuleDetailUpdateWithoutDispatch_ruleInput, DispatchRuleDetailUncheckedUpdateWithoutDispatch_ruleInput>
  }

  export type DispatchRuleDetailUpdateManyWithWhereWithoutDispatch_ruleInput = {
    where: DispatchRuleDetailScalarWhereInput
    data: XOR<DispatchRuleDetailUpdateManyMutationInput, DispatchRuleDetailUncheckedUpdateManyWithoutDispatch_ruleInput>
  }

  export type DispatchRuleCreateWithoutDetailsInput = {
    name: string
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    source_single_fee: SingleFeeCreateNestedOneWithoutDispatch_rulesInput
  }

  export type DispatchRuleUncheckedCreateWithoutDetailsInput = {
    id?: number
    name: string
    source_single_fee_id: number
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleCreateOrConnectWithoutDetailsInput = {
    where: DispatchRuleWhereUniqueInput
    create: XOR<DispatchRuleCreateWithoutDetailsInput, DispatchRuleUncheckedCreateWithoutDetailsInput>
  }

  export type FinancialCategoryCreateWithoutDispatch_rule_detailsInput = {
    name: string
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    transactions?: FinancialTransactionCreateNestedManyWithoutCategoryInput
  }

  export type FinancialCategoryUncheckedCreateWithoutDispatch_rule_detailsInput = {
    id?: number
    name: string
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type FinancialCategoryCreateOrConnectWithoutDispatch_rule_detailsInput = {
    where: FinancialCategoryWhereUniqueInput
    create: XOR<FinancialCategoryCreateWithoutDispatch_rule_detailsInput, FinancialCategoryUncheckedCreateWithoutDispatch_rule_detailsInput>
  }

  export type DispatchRuleUpsertWithoutDetailsInput = {
    update: XOR<DispatchRuleUpdateWithoutDetailsInput, DispatchRuleUncheckedUpdateWithoutDetailsInput>
    create: XOR<DispatchRuleCreateWithoutDetailsInput, DispatchRuleUncheckedCreateWithoutDetailsInput>
    where?: DispatchRuleWhereInput
  }

  export type DispatchRuleUpdateToOneWithWhereWithoutDetailsInput = {
    where?: DispatchRuleWhereInput
    data: XOR<DispatchRuleUpdateWithoutDetailsInput, DispatchRuleUncheckedUpdateWithoutDetailsInput>
  }

  export type DispatchRuleUpdateWithoutDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    source_single_fee?: SingleFeeUpdateOneRequiredWithoutDispatch_rulesNestedInput
  }

  export type DispatchRuleUncheckedUpdateWithoutDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    source_single_fee_id?: IntFieldUpdateOperationsInput | number
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialCategoryUpsertWithoutDispatch_rule_detailsInput = {
    update: XOR<FinancialCategoryUpdateWithoutDispatch_rule_detailsInput, FinancialCategoryUncheckedUpdateWithoutDispatch_rule_detailsInput>
    create: XOR<FinancialCategoryCreateWithoutDispatch_rule_detailsInput, FinancialCategoryUncheckedCreateWithoutDispatch_rule_detailsInput>
    where?: FinancialCategoryWhereInput
  }

  export type FinancialCategoryUpdateToOneWithWhereWithoutDispatch_rule_detailsInput = {
    where?: FinancialCategoryWhereInput
    data: XOR<FinancialCategoryUpdateWithoutDispatch_rule_detailsInput, FinancialCategoryUncheckedUpdateWithoutDispatch_rule_detailsInput>
  }

  export type FinancialCategoryUpdateWithoutDispatch_rule_detailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    transactions?: FinancialTransactionUpdateManyWithoutCategoryNestedInput
  }

  export type FinancialCategoryUncheckedUpdateWithoutDispatch_rule_detailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EmployeesCreateWithoutAttendancesInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: SalaryPaymentsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateWithoutAttendancesInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: SalaryPaymentsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesCreateOrConnectWithoutAttendancesInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutAttendancesInput, EmployeesUncheckedCreateWithoutAttendancesInput>
  }

  export type TeachersCreateWithoutAttendancesInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsCreateNestedManyWithoutTeacherInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUncheckedCreateWithoutAttendancesInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsUncheckedCreateNestedManyWithoutTeacherInput
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeachersCreateOrConnectWithoutAttendancesInput = {
    where: TeachersWhereUniqueInput
    create: XOR<TeachersCreateWithoutAttendancesInput, TeachersUncheckedCreateWithoutAttendancesInput>
  }

  export type EmployeesUpsertWithoutAttendancesInput = {
    update: XOR<EmployeesUpdateWithoutAttendancesInput, EmployeesUncheckedUpdateWithoutAttendancesInput>
    create: XOR<EmployeesCreateWithoutAttendancesInput, EmployeesUncheckedCreateWithoutAttendancesInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutAttendancesInput, EmployeesUncheckedUpdateWithoutAttendancesInput>
  }

  export type EmployeesUpdateWithoutAttendancesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    salary_payments?: SalaryPaymentsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutAttendancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    salary_payments?: SalaryPaymentsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type TeachersUpsertWithoutAttendancesInput = {
    update: XOR<TeachersUpdateWithoutAttendancesInput, TeachersUncheckedUpdateWithoutAttendancesInput>
    create: XOR<TeachersCreateWithoutAttendancesInput, TeachersUncheckedCreateWithoutAttendancesInput>
    where?: TeachersWhereInput
  }

  export type TeachersUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: TeachersWhereInput
    data: XOR<TeachersUpdateWithoutAttendancesInput, TeachersUncheckedUpdateWithoutAttendancesInput>
  }

  export type TeachersUpdateWithoutAttendancesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUpdateManyWithoutTeacherNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersUncheckedUpdateWithoutAttendancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUncheckedUpdateManyWithoutTeacherNestedInput
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type LessonsCreateManyClassInput = {
    id?: number
    teacher_id?: number | null
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsCreateManyClassInput = {
    id?: number
    student_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SubjectsCreateManyClassInput = {
    id?: number
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SingleFeeCreateManyClassInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeeTemplateCreateManyClassInput = {
    id?: number
    name: string
    amount: number
    frequency: string
    due_day?: number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id: string
    applies_to_level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateWithoutClassInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegistrationsUpdateWithoutClassInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutRegistrationNestedInput
    student?: StudentsUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type RegistrationsUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubjectsUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutSubjectNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutSubjectNestedInput
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SingleFeeUpdateWithoutClassInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutSingle_feeNestedInput
    dispatch_rules?: DispatchRuleUpdateManyWithoutSource_single_feeNestedInput
  }

  export type SingleFeeUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutSingle_feeNestedInput
    dispatch_rules?: DispatchRuleUncheckedUpdateManyWithoutSource_single_feeNestedInput
  }

  export type SingleFeeUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeeTemplateUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutFee_templateNestedInput
  }

  export type FeeTemplateUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutFee_templateNestedInput
  }

  export type FeeTemplateUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    due_day?: NullableIntFieldUpdateOperationsInput | number | null
    applicable_months?: NullableJsonNullValueInput | InputJsonValue
    school_id?: StringFieldUpdateOperationsInput | string
    applies_to_level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesCreateManyStudentInput = {
    id?: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesCreateManyStudentInput = {
    id?: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsCreateManyStudentInput = {
    id?: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsCreateManyStudentInput = {
    id?: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUpdateWithoutStudentInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUpdateWithoutStudentInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson?: LessonsUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegistrationsUpdateWithoutStudentInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutRegistrationNestedInput
    class?: ClassesUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type RegistrationsUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUpdateWithoutStudentInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    parent?: ParentsUpdateOneRequiredWithoutStudent_parentsNestedInput
  }

  export type StudentParentsUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateManyRegistrationInput = {
    id?: number
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: number | null
    fee_template_id?: number | null
    period_identifier?: string | null
  }

  export type PaymentsUpdateWithoutRegistrationInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    single_fee?: SingleFeeUpdateOneWithoutPaymentsNestedInput
    fee_template?: FeeTemplateUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutRegistrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    single_fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    fee_template_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutRegistrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    single_fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    fee_template_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonsCreateManyTeacherInput = {
    id?: number
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateManyTeacherInput = {
    id?: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeeAttendanceCreateManyTeacherInput = {
    id?: number
    employee_id?: number | null
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateWithoutTeacherInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUpdateWithoutTeacherInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneWithoutWorkHoursNestedInput
  }

  export type TeacherWorkHoursUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeAttendanceUpdateWithoutTeacherInput = {
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    employee?: EmployeesUpdateOneWithoutAttendancesNestedInput
  }

  export type EmployeeAttendanceUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeAttendanceUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesCreateManyLessonInput = {
    id?: number
    student_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesCreateManyLessonInput = {
    id?: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesUpdateWithoutLessonInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentsUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUpdateWithoutLessonInput = {
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsCreateManySubjectInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateManySubjectInput = {
    id?: number
    teacher_id: number
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateWithoutSubjectInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUpdateWithoutSubjectInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeachersUpdateOneRequiredWithoutWorkHoursNestedInput
  }

  export type TeacherWorkHoursUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsCreateManyParentInput = {
    id?: number
    student_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsUpdateWithoutParentInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentsUpdateOneRequiredWithoutStudent_parentsNestedInput
  }

  export type StudentParentsUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateManySingle_feeInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    fee_template_id?: number | null
    period_identifier?: string | null
  }

  export type DispatchRuleCreateManySource_single_feeInput = {
    id?: number
    name: string
    school_id: string
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsUpdateWithoutSingle_feeInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    registration?: RegistrationsUpdateOneWithoutPaymentsNestedInput
    fee_template?: FeeTemplateUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutSingle_feeInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    fee_template_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutSingle_feeInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    fee_template_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DispatchRuleUpdateWithoutSource_single_feeInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    details?: DispatchRuleDetailUpdateManyWithoutDispatch_ruleNestedInput
  }

  export type DispatchRuleUncheckedUpdateWithoutSource_single_feeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    details?: DispatchRuleDetailUncheckedUpdateManyWithoutDispatch_ruleNestedInput
  }

  export type DispatchRuleUncheckedUpdateManyWithoutSource_single_feeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    school_id?: StringFieldUpdateOperationsInput | string
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateManyFee_templateInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    single_fee_id?: number | null
    period_identifier?: string | null
  }

  export type PaymentsUpdateWithoutFee_templateInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
    registration?: RegistrationsUpdateOneWithoutPaymentsNestedInput
    single_fee?: SingleFeeUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutFee_templateInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    single_fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutFee_templateInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    single_fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    period_identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalaryPaymentsCreateManyEmployeeInput = {
    id?: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeeAttendanceCreateManyEmployeeInput = {
    id?: number
    teacher_id?: number | null
    check_in: Date | string
    check_out?: Date | string | null
    notes?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUpdateWithoutEmployeeInput = {
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeAttendanceUpdateWithoutEmployeeInput = {
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeachersUpdateOneWithoutAttendancesNestedInput
  }

  export type EmployeeAttendanceUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeAttendanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    check_in?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialTransactionCreateManyCategoryInput = {
    id?: number
    date: Date | string
    description: string
    amount: number
    type: string
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleDetailCreateManyDestination_categoryInput = {
    id?: number
    dispatch_rule_id: number
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FinancialTransactionUpdateWithoutCategoryInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialTransactionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleDetailUpdateWithoutDestination_categoryInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    dispatch_rule?: DispatchRuleUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type DispatchRuleDetailUncheckedUpdateWithoutDestination_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispatch_rule_id?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleDetailUncheckedUpdateManyWithoutDestination_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    dispatch_rule_id?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleDetailCreateManyDispatch_ruleInput = {
    id?: number
    destination_category_id: number
    percentage: number
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type DispatchRuleDetailUpdateWithoutDispatch_ruleInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    destination_category?: FinancialCategoryUpdateOneRequiredWithoutDispatch_rule_detailsNestedInput
  }

  export type DispatchRuleDetailUncheckedUpdateWithoutDispatch_ruleInput = {
    id?: IntFieldUpdateOperationsInput | number
    destination_category_id?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DispatchRuleDetailUncheckedUpdateManyWithoutDispatch_ruleInput = {
    id?: IntFieldUpdateOperationsInput | number
    destination_category_id?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}