
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Classes
 * 
 */
export type Classes = $Result.DefaultSelection<Prisma.$ClassesPayload>
/**
 * Model Students
 * 
 */
export type Students = $Result.DefaultSelection<Prisma.$StudentsPayload>
/**
 * Model Registrations
 * 
 */
export type Registrations = $Result.DefaultSelection<Prisma.$RegistrationsPayload>
/**
 * Model Teachers
 * 
 */
export type Teachers = $Result.DefaultSelection<Prisma.$TeachersPayload>
/**
 * Model TeacherWorkHours
 * 
 */
export type TeacherWorkHours = $Result.DefaultSelection<Prisma.$TeacherWorkHoursPayload>
/**
 * Model Lessons
 * 
 */
export type Lessons = $Result.DefaultSelection<Prisma.$LessonsPayload>
/**
 * Model Subjects
 * 
 */
export type Subjects = $Result.DefaultSelection<Prisma.$SubjectsPayload>
/**
 * Model Notes
 * 
 */
export type Notes = $Result.DefaultSelection<Prisma.$NotesPayload>
/**
 * Model Parents
 * 
 */
export type Parents = $Result.DefaultSelection<Prisma.$ParentsPayload>
/**
 * Model StudentParents
 * 
 */
export type StudentParents = $Result.DefaultSelection<Prisma.$StudentParentsPayload>
/**
 * Model Payments
 * 
 */
export type Payments = $Result.DefaultSelection<Prisma.$PaymentsPayload>
/**
 * Model Fees
 * 
 */
export type Fees = $Result.DefaultSelection<Prisma.$FeesPayload>
/**
 * Model Attendances
 * 
 */
export type Attendances = $Result.DefaultSelection<Prisma.$AttendancesPayload>
/**
 * Model Employees
 * 
 */
export type Employees = $Result.DefaultSelection<Prisma.$EmployeesPayload>
/**
 * Model SalaryPayments
 * 
 */
export type SalaryPayments = $Result.DefaultSelection<Prisma.$SalaryPaymentsPayload>
/**
 * Model Schedules
 * 
 */
export type Schedules = $Result.DefaultSelection<Prisma.$SchedulesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Settings
 * const settings = await prisma.settings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Settings
   * const settings = await prisma.settings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classes`: Exposes CRUD operations for the **Classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classes.findMany()
    * ```
    */
  get classes(): Prisma.ClassesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **Students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.StudentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registrations`: Exposes CRUD operations for the **Registrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Registrations
    * const registrations = await prisma.registrations.findMany()
    * ```
    */
  get registrations(): Prisma.RegistrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teachers`: Exposes CRUD operations for the **Teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teachers.findMany()
    * ```
    */
  get teachers(): Prisma.TeachersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherWorkHours`: Exposes CRUD operations for the **TeacherWorkHours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherWorkHours
    * const teacherWorkHours = await prisma.teacherWorkHours.findMany()
    * ```
    */
  get teacherWorkHours(): Prisma.TeacherWorkHoursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessons`: Exposes CRUD operations for the **Lessons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lessons.findMany()
    * ```
    */
  get lessons(): Prisma.LessonsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subjects`: Exposes CRUD operations for the **Subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subjects.findMany()
    * ```
    */
  get subjects(): Prisma.SubjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **Notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.NotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parents`: Exposes CRUD operations for the **Parents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parents.findMany()
    * ```
    */
  get parents(): Prisma.ParentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentParents`: Exposes CRUD operations for the **StudentParents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParents
    * const studentParents = await prisma.studentParents.findMany()
    * ```
    */
  get studentParents(): Prisma.StudentParentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.PaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fees`: Exposes CRUD operations for the **Fees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fees
    * const fees = await prisma.fees.findMany()
    * ```
    */
  get fees(): Prisma.FeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendances`: Exposes CRUD operations for the **Attendances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendances.findMany()
    * ```
    */
  get attendances(): Prisma.AttendancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **Employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.EmployeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryPayments`: Exposes CRUD operations for the **SalaryPayments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryPayments
    * const salaryPayments = await prisma.salaryPayments.findMany()
    * ```
    */
  get salaryPayments(): Prisma.SalaryPaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedules`: Exposes CRUD operations for the **Schedules** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedules.findMany()
    * ```
    */
  get schedules(): Prisma.SchedulesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Settings: 'Settings',
    Classes: 'Classes',
    Students: 'Students',
    Registrations: 'Registrations',
    Teachers: 'Teachers',
    TeacherWorkHours: 'TeacherWorkHours',
    Lessons: 'Lessons',
    Subjects: 'Subjects',
    Notes: 'Notes',
    Parents: 'Parents',
    StudentParents: 'StudentParents',
    Payments: 'Payments',
    Fees: 'Fees',
    Attendances: 'Attendances',
    Employees: 'Employees',
    SalaryPayments: 'SalaryPayments',
    Schedules: 'Schedules'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "settings" | "classes" | "students" | "registrations" | "teachers" | "teacherWorkHours" | "lessons" | "subjects" | "notes" | "parents" | "studentParents" | "payments" | "fees" | "attendances" | "employees" | "salaryPayments" | "schedules"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Classes: {
        payload: Prisma.$ClassesPayload<ExtArgs>
        fields: Prisma.ClassesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          findFirst: {
            args: Prisma.ClassesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          findMany: {
            args: Prisma.ClassesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>[]
          }
          create: {
            args: Prisma.ClassesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          createMany: {
            args: Prisma.ClassesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>[]
          }
          delete: {
            args: Prisma.ClassesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          update: {
            args: Prisma.ClassesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          deleteMany: {
            args: Prisma.ClassesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>[]
          }
          upsert: {
            args: Prisma.ClassesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassesPayload>
          }
          aggregate: {
            args: Prisma.ClassesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasses>
          }
          groupBy: {
            args: Prisma.ClassesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassesCountArgs<ExtArgs>
            result: $Utils.Optional<ClassesCountAggregateOutputType> | number
          }
        }
      }
      Students: {
        payload: Prisma.$StudentsPayload<ExtArgs>
        fields: Prisma.StudentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findFirst: {
            args: Prisma.StudentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findMany: {
            args: Prisma.StudentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          create: {
            args: Prisma.StudentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          createMany: {
            args: Prisma.StudentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          delete: {
            args: Prisma.StudentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          update: {
            args: Prisma.StudentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          deleteMany: {
            args: Prisma.StudentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          upsert: {
            args: Prisma.StudentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.StudentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      Registrations: {
        payload: Prisma.$RegistrationsPayload<ExtArgs>
        fields: Prisma.RegistrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegistrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegistrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          findFirst: {
            args: Prisma.RegistrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegistrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          findMany: {
            args: Prisma.RegistrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>[]
          }
          create: {
            args: Prisma.RegistrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          createMany: {
            args: Prisma.RegistrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegistrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>[]
          }
          delete: {
            args: Prisma.RegistrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          update: {
            args: Prisma.RegistrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          deleteMany: {
            args: Prisma.RegistrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegistrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegistrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>[]
          }
          upsert: {
            args: Prisma.RegistrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistrationsPayload>
          }
          aggregate: {
            args: Prisma.RegistrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegistrations>
          }
          groupBy: {
            args: Prisma.RegistrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegistrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegistrationsCountArgs<ExtArgs>
            result: $Utils.Optional<RegistrationsCountAggregateOutputType> | number
          }
        }
      }
      Teachers: {
        payload: Prisma.$TeachersPayload<ExtArgs>
        fields: Prisma.TeachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeachersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeachersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          findFirst: {
            args: Prisma.TeachersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeachersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          findMany: {
            args: Prisma.TeachersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>[]
          }
          create: {
            args: Prisma.TeachersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          createMany: {
            args: Prisma.TeachersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeachersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>[]
          }
          delete: {
            args: Prisma.TeachersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          update: {
            args: Prisma.TeachersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          deleteMany: {
            args: Prisma.TeachersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeachersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeachersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>[]
          }
          upsert: {
            args: Prisma.TeachersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          aggregate: {
            args: Prisma.TeachersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachers>
          }
          groupBy: {
            args: Prisma.TeachersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeachersCountArgs<ExtArgs>
            result: $Utils.Optional<TeachersCountAggregateOutputType> | number
          }
        }
      }
      TeacherWorkHours: {
        payload: Prisma.$TeacherWorkHoursPayload<ExtArgs>
        fields: Prisma.TeacherWorkHoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherWorkHoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherWorkHoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          findFirst: {
            args: Prisma.TeacherWorkHoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherWorkHoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          findMany: {
            args: Prisma.TeacherWorkHoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>[]
          }
          create: {
            args: Prisma.TeacherWorkHoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          createMany: {
            args: Prisma.TeacherWorkHoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherWorkHoursCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>[]
          }
          delete: {
            args: Prisma.TeacherWorkHoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          update: {
            args: Prisma.TeacherWorkHoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          deleteMany: {
            args: Prisma.TeacherWorkHoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherWorkHoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherWorkHoursUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>[]
          }
          upsert: {
            args: Prisma.TeacherWorkHoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkHoursPayload>
          }
          aggregate: {
            args: Prisma.TeacherWorkHoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherWorkHours>
          }
          groupBy: {
            args: Prisma.TeacherWorkHoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherWorkHoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherWorkHoursCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherWorkHoursCountAggregateOutputType> | number
          }
        }
      }
      Lessons: {
        payload: Prisma.$LessonsPayload<ExtArgs>
        fields: Prisma.LessonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          findFirst: {
            args: Prisma.LessonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          findMany: {
            args: Prisma.LessonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          create: {
            args: Prisma.LessonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          createMany: {
            args: Prisma.LessonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          delete: {
            args: Prisma.LessonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          update: {
            args: Prisma.LessonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          deleteMany: {
            args: Prisma.LessonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>[]
          }
          upsert: {
            args: Prisma.LessonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonsPayload>
          }
          aggregate: {
            args: Prisma.LessonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessons>
          }
          groupBy: {
            args: Prisma.LessonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonsCountArgs<ExtArgs>
            result: $Utils.Optional<LessonsCountAggregateOutputType> | number
          }
        }
      }
      Subjects: {
        payload: Prisma.$SubjectsPayload<ExtArgs>
        fields: Prisma.SubjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          findFirst: {
            args: Prisma.SubjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          findMany: {
            args: Prisma.SubjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>[]
          }
          create: {
            args: Prisma.SubjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          createMany: {
            args: Prisma.SubjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>[]
          }
          delete: {
            args: Prisma.SubjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          update: {
            args: Prisma.SubjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          deleteMany: {
            args: Prisma.SubjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>[]
          }
          upsert: {
            args: Prisma.SubjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectsPayload>
          }
          aggregate: {
            args: Prisma.SubjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjects>
          }
          groupBy: {
            args: Prisma.SubjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectsCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectsCountAggregateOutputType> | number
          }
        }
      }
      Notes: {
        payload: Prisma.$NotesPayload<ExtArgs>
        fields: Prisma.NotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          findFirst: {
            args: Prisma.NotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          findMany: {
            args: Prisma.NotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          create: {
            args: Prisma.NotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          createMany: {
            args: Prisma.NotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          delete: {
            args: Prisma.NotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          update: {
            args: Prisma.NotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          deleteMany: {
            args: Prisma.NotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>[]
          }
          upsert: {
            args: Prisma.NotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotesPayload>
          }
          aggregate: {
            args: Prisma.NotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotes>
          }
          groupBy: {
            args: Prisma.NotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotesCountArgs<ExtArgs>
            result: $Utils.Optional<NotesCountAggregateOutputType> | number
          }
        }
      }
      Parents: {
        payload: Prisma.$ParentsPayload<ExtArgs>
        fields: Prisma.ParentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          findFirst: {
            args: Prisma.ParentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          findMany: {
            args: Prisma.ParentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>[]
          }
          create: {
            args: Prisma.ParentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          createMany: {
            args: Prisma.ParentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>[]
          }
          delete: {
            args: Prisma.ParentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          update: {
            args: Prisma.ParentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          deleteMany: {
            args: Prisma.ParentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>[]
          }
          upsert: {
            args: Prisma.ParentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentsPayload>
          }
          aggregate: {
            args: Prisma.ParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParents>
          }
          groupBy: {
            args: Prisma.ParentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentsCountArgs<ExtArgs>
            result: $Utils.Optional<ParentsCountAggregateOutputType> | number
          }
        }
      }
      StudentParents: {
        payload: Prisma.$StudentParentsPayload<ExtArgs>
        fields: Prisma.StudentParentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentParentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentParentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          findFirst: {
            args: Prisma.StudentParentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentParentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          findMany: {
            args: Prisma.StudentParentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>[]
          }
          create: {
            args: Prisma.StudentParentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          createMany: {
            args: Prisma.StudentParentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentParentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>[]
          }
          delete: {
            args: Prisma.StudentParentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          update: {
            args: Prisma.StudentParentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          deleteMany: {
            args: Prisma.StudentParentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentParentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentParentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>[]
          }
          upsert: {
            args: Prisma.StudentParentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentsPayload>
          }
          aggregate: {
            args: Prisma.StudentParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentParents>
          }
          groupBy: {
            args: Prisma.StudentParentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentParentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentParentsCountAggregateOutputType> | number
          }
        }
      }
      Payments: {
        payload: Prisma.$PaymentsPayload<ExtArgs>
        fields: Prisma.PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findFirst: {
            args: Prisma.PaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findMany: {
            args: Prisma.PaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          create: {
            args: Prisma.PaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          createMany: {
            args: Prisma.PaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          delete: {
            args: Prisma.PaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          update: {
            args: Prisma.PaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.PaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      Fees: {
        payload: Prisma.$FeesPayload<ExtArgs>
        fields: Prisma.FeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          findFirst: {
            args: Prisma.FeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          findMany: {
            args: Prisma.FeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[]
          }
          create: {
            args: Prisma.FeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          createMany: {
            args: Prisma.FeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[]
          }
          delete: {
            args: Prisma.FeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          update: {
            args: Prisma.FeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          deleteMany: {
            args: Prisma.FeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[]
          }
          upsert: {
            args: Prisma.FeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          aggregate: {
            args: Prisma.FeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFees>
          }
          groupBy: {
            args: Prisma.FeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeesCountArgs<ExtArgs>
            result: $Utils.Optional<FeesCountAggregateOutputType> | number
          }
        }
      }
      Attendances: {
        payload: Prisma.$AttendancesPayload<ExtArgs>
        fields: Prisma.AttendancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          findFirst: {
            args: Prisma.AttendancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          findMany: {
            args: Prisma.AttendancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>[]
          }
          create: {
            args: Prisma.AttendancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          createMany: {
            args: Prisma.AttendancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendancesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>[]
          }
          delete: {
            args: Prisma.AttendancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          update: {
            args: Prisma.AttendancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          deleteMany: {
            args: Prisma.AttendancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendancesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>[]
          }
          upsert: {
            args: Prisma.AttendancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancesPayload>
          }
          aggregate: {
            args: Prisma.AttendancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendances>
          }
          groupBy: {
            args: Prisma.AttendancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendancesCountArgs<ExtArgs>
            result: $Utils.Optional<AttendancesCountAggregateOutputType> | number
          }
        }
      }
      Employees: {
        payload: Prisma.$EmployeesPayload<ExtArgs>
        fields: Prisma.EmployeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findFirst: {
            args: Prisma.EmployeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findMany: {
            args: Prisma.EmployeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          create: {
            args: Prisma.EmployeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          createMany: {
            args: Prisma.EmployeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          delete: {
            args: Prisma.EmployeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          update: {
            args: Prisma.EmployeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          upsert: {
            args: Prisma.EmployeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployees>
          }
          groupBy: {
            args: Prisma.EmployeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesCountAggregateOutputType> | number
          }
        }
      }
      SalaryPayments: {
        payload: Prisma.$SalaryPaymentsPayload<ExtArgs>
        fields: Prisma.SalaryPaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryPaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryPaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          findFirst: {
            args: Prisma.SalaryPaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryPaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          findMany: {
            args: Prisma.SalaryPaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>[]
          }
          create: {
            args: Prisma.SalaryPaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          createMany: {
            args: Prisma.SalaryPaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryPaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>[]
          }
          delete: {
            args: Prisma.SalaryPaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          update: {
            args: Prisma.SalaryPaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          deleteMany: {
            args: Prisma.SalaryPaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryPaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryPaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>[]
          }
          upsert: {
            args: Prisma.SalaryPaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentsPayload>
          }
          aggregate: {
            args: Prisma.SalaryPaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryPayments>
          }
          groupBy: {
            args: Prisma.SalaryPaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryPaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentsCountAggregateOutputType> | number
          }
        }
      }
      Schedules: {
        payload: Prisma.$SchedulesPayload<ExtArgs>
        fields: Prisma.SchedulesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchedulesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchedulesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          findFirst: {
            args: Prisma.SchedulesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchedulesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          findMany: {
            args: Prisma.SchedulesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>[]
          }
          create: {
            args: Prisma.SchedulesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          createMany: {
            args: Prisma.SchedulesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchedulesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>[]
          }
          delete: {
            args: Prisma.SchedulesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          update: {
            args: Prisma.SchedulesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          deleteMany: {
            args: Prisma.SchedulesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchedulesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchedulesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>[]
          }
          upsert: {
            args: Prisma.SchedulesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulesPayload>
          }
          aggregate: {
            args: Prisma.SchedulesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedules>
          }
          groupBy: {
            args: Prisma.SchedulesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchedulesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchedulesCountArgs<ExtArgs>
            result: $Utils.Optional<SchedulesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    settings?: SettingsOmit
    classes?: ClassesOmit
    students?: StudentsOmit
    registrations?: RegistrationsOmit
    teachers?: TeachersOmit
    teacherWorkHours?: TeacherWorkHoursOmit
    lessons?: LessonsOmit
    subjects?: SubjectsOmit
    notes?: NotesOmit
    parents?: ParentsOmit
    studentParents?: StudentParentsOmit
    payments?: PaymentsOmit
    fees?: FeesOmit
    attendances?: AttendancesOmit
    employees?: EmployeesOmit
    salaryPayments?: SalaryPaymentsOmit
    schedules?: SchedulesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClassesCountOutputType
   */

  export type ClassesCountOutputType = {
    lessons: number
    registrations: number
    subjects: number
  }

  export type ClassesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | ClassesCountOutputTypeCountLessonsArgs
    registrations?: boolean | ClassesCountOutputTypeCountRegistrationsArgs
    subjects?: boolean | ClassesCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassesCountOutputType
     */
    select?: ClassesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistrationsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectsWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    attendances: number
    notes: number
    registrations: number
    student_parents: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | StudentsCountOutputTypeCountAttendancesArgs
    notes?: boolean | StudentsCountOutputTypeCountNotesArgs
    registrations?: boolean | StudentsCountOutputTypeCountRegistrationsArgs
    student_parents?: boolean | StudentsCountOutputTypeCountStudent_parentsArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendancesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistrationsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentsWhereInput
  }


  /**
   * Count Type RegistrationsCountOutputType
   */

  export type RegistrationsCountOutputType = {
    payments: number
  }

  export type RegistrationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | RegistrationsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * RegistrationsCountOutputType without action
   */
  export type RegistrationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistrationsCountOutputType
     */
    select?: RegistrationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegistrationsCountOutputType without action
   */
  export type RegistrationsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Count Type TeachersCountOutputType
   */

  export type TeachersCountOutputType = {
    lessons: number
    workHours: number
  }

  export type TeachersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | TeachersCountOutputTypeCountLessonsArgs
    workHours?: boolean | TeachersCountOutputTypeCountWorkHoursArgs
  }

  // Custom InputTypes
  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachersCountOutputType
     */
    select?: TeachersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountWorkHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkHoursWhereInput
  }


  /**
   * Count Type LessonsCountOutputType
   */

  export type LessonsCountOutputType = {
    notes: number
    schedules: number
  }

  export type LessonsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | LessonsCountOutputTypeCountNotesArgs
    schedules?: boolean | LessonsCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonsCountOutputType
     */
    select?: LessonsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
  }

  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchedulesWhereInput
  }


  /**
   * Count Type SubjectsCountOutputType
   */

  export type SubjectsCountOutputType = {
    lessons: number
    workHours: number
  }

  export type SubjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | SubjectsCountOutputTypeCountLessonsArgs
    workHours?: boolean | SubjectsCountOutputTypeCountWorkHoursArgs
  }

  // Custom InputTypes
  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectsCountOutputType
     */
    select?: SubjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountWorkHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkHoursWhereInput
  }


  /**
   * Count Type ParentsCountOutputType
   */

  export type ParentsCountOutputType = {
    student_parents: number
  }

  export type ParentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_parents?: boolean | ParentsCountOutputTypeCountStudent_parentsArgs
  }

  // Custom InputTypes
  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentsCountOutputType
     */
    select?: ParentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeCountStudent_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentsWhereInput
  }


  /**
   * Count Type FeesCountOutputType
   */

  export type FeesCountOutputType = {
    payments: number
  }

  export type FeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | FeesCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * FeesCountOutputType without action
   */
  export type FeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeesCountOutputType
     */
    select?: FeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeesCountOutputType without action
   */
  export type FeesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Count Type EmployeesCountOutputType
   */

  export type EmployeesCountOutputType = {
    salary_payments: number
  }

  export type EmployeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salary_payments?: boolean | EmployeesCountOutputTypeCountSalary_paymentsArgs
  }

  // Custom InputTypes
  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesCountOutputType
     */
    select?: EmployeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountSalary_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
    loggedIn: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
    loggedIn: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    schoolName: string | null
    schoolAddress: string | null
    loggedIn: number | null
    userRole: string | null
    schoolId: string | null
    userToken: string | null
    last_sync: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    schoolName: string | null
    schoolAddress: string | null
    loggedIn: number | null
    userRole: string | null
    schoolId: string | null
    userToken: string | null
    last_sync: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    schoolName: number
    schoolAddress: number
    loggedIn: number
    userRole: number
    schoolId: number
    userToken: number
    last_sync: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
    loggedIn?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
    loggedIn?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    schoolName?: true
    schoolAddress?: true
    loggedIn?: true
    userRole?: true
    schoolId?: true
    userToken?: true
    last_sync?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    schoolName?: true
    schoolAddress?: true
    loggedIn?: true
    userRole?: true
    schoolId?: true
    userToken?: true
    last_sync?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    schoolName?: true
    schoolAddress?: true
    loggedIn?: true
    userRole?: true
    schoolId?: true
    userToken?: true
    last_sync?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: number
    schoolName: string | null
    schoolAddress: string | null
    loggedIn: number | null
    userRole: string | null
    schoolId: string | null
    userToken: string | null
    last_sync: Date | null
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    schoolName?: boolean
    schoolAddress?: boolean
    loggedIn?: boolean
    userRole?: boolean
    schoolId?: boolean
    userToken?: boolean
    last_sync?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolName" | "schoolAddress" | "loggedIn" | "userRole" | "schoolId" | "userToken" | "last_sync", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schoolName: string | null
      schoolAddress: string | null
      loggedIn: number | null
      userRole: string | null
      schoolId: string | null
      userToken: string | null
      last_sync: Date | null
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'Int'>
    readonly schoolName: FieldRef<"Settings", 'String'>
    readonly schoolAddress: FieldRef<"Settings", 'String'>
    readonly loggedIn: FieldRef<"Settings", 'Int'>
    readonly userRole: FieldRef<"Settings", 'String'>
    readonly schoolId: FieldRef<"Settings", 'String'>
    readonly userToken: FieldRef<"Settings", 'String'>
    readonly last_sync: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data?: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model Classes
   */

  export type AggregateClasses = {
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  export type ClassesAvgAggregateOutputType = {
    id: number | null
  }

  export type ClassesSumAggregateOutputType = {
    id: number | null
  }

  export type ClassesMinAggregateOutputType = {
    id: number | null
    name: string | null
    level: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type ClassesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    level: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type ClassesCountAggregateOutputType = {
    id: number
    name: number
    level: number
    school_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type ClassesAvgAggregateInputType = {
    id?: true
  }

  export type ClassesSumAggregateInputType = {
    id?: true
  }

  export type ClassesMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type ClassesMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type ClassesCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    school_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type ClassesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to aggregate.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassesMaxAggregateInputType
  }

  export type GetClassesAggregateType<T extends ClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasses[P]>
      : GetScalarType<T[P], AggregateClasses[P]>
  }




  export type ClassesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassesWhereInput
    orderBy?: ClassesOrderByWithAggregationInput | ClassesOrderByWithAggregationInput[]
    by: ClassesScalarFieldEnum[] | ClassesScalarFieldEnum
    having?: ClassesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassesCountAggregateInputType | true
    _avg?: ClassesAvgAggregateInputType
    _sum?: ClassesSumAggregateInputType
    _min?: ClassesMinAggregateInputType
    _max?: ClassesMaxAggregateInputType
  }

  export type ClassesGroupByOutputType = {
    id: number
    name: string
    level: string | null
    school_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  type GetClassesGroupByPayload<T extends ClassesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassesGroupByOutputType[P]>
            : GetScalarType<T[P], ClassesGroupByOutputType[P]>
        }
      >
    >


  export type ClassesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: boolean | Classes$lessonsArgs<ExtArgs>
    registrations?: boolean | Classes$registrationsArgs<ExtArgs>
    subjects?: boolean | Classes$subjectsArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classes"]>

  export type ClassesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["classes"]>

  export type ClassesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["classes"]>

  export type ClassesSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    school_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type ClassesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "level" | "school_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["classes"]>
  export type ClassesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Classes$lessonsArgs<ExtArgs>
    registrations?: boolean | Classes$registrationsArgs<ExtArgs>
    subjects?: boolean | Classes$subjectsArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClassesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classes"
    objects: {
      lessons: Prisma.$LessonsPayload<ExtArgs>[]
      registrations: Prisma.$RegistrationsPayload<ExtArgs>[]
      subjects: Prisma.$SubjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      level: string | null
      school_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["classes"]>
    composites: {}
  }

  type ClassesGetPayload<S extends boolean | null | undefined | ClassesDefaultArgs> = $Result.GetResult<Prisma.$ClassesPayload, S>

  type ClassesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassesCountAggregateInputType | true
    }

  export interface ClassesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classes'], meta: { name: 'Classes' } }
    /**
     * Find zero or one Classes that matches the filter.
     * @param {ClassesFindUniqueArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassesFindUniqueArgs>(args: SelectSubset<T, ClassesFindUniqueArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassesFindUniqueOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassesFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesFindFirstArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassesFindFirstArgs>(args?: SelectSubset<T, ClassesFindFirstArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesFindFirstOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassesFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classes.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classesWithIdOnly = await prisma.classes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassesFindManyArgs>(args?: SelectSubset<T, ClassesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classes.
     * @param {ClassesCreateArgs} args - Arguments to create a Classes.
     * @example
     * // Create one Classes
     * const Classes = await prisma.classes.create({
     *   data: {
     *     // ... data to create a Classes
     *   }
     * })
     * 
     */
    create<T extends ClassesCreateArgs>(args: SelectSubset<T, ClassesCreateArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassesCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassesCreateManyArgs>(args?: SelectSubset<T, ClassesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassesCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classesWithIdOnly = await prisma.classes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassesCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classes.
     * @param {ClassesDeleteArgs} args - Arguments to delete one Classes.
     * @example
     * // Delete one Classes
     * const Classes = await prisma.classes.delete({
     *   where: {
     *     // ... filter to delete one Classes
     *   }
     * })
     * 
     */
    delete<T extends ClassesDeleteArgs>(args: SelectSubset<T, ClassesDeleteArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classes.
     * @param {ClassesUpdateArgs} args - Arguments to update one Classes.
     * @example
     * // Update one Classes
     * const classes = await prisma.classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassesUpdateArgs>(args: SelectSubset<T, ClassesUpdateArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassesDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassesDeleteManyArgs>(args?: SelectSubset<T, ClassesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassesUpdateManyArgs>(args: SelectSubset<T, ClassesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassesUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classesWithIdOnly = await prisma.classes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassesUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classes.
     * @param {ClassesUpsertArgs} args - Arguments to update or create a Classes.
     * @example
     * // Update or create a Classes
     * const classes = await prisma.classes.upsert({
     *   create: {
     *     // ... data to create a Classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classes we want to update
     *   }
     * })
     */
    upsert<T extends ClassesUpsertArgs>(args: SelectSubset<T, ClassesUpsertArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classes.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassesCountArgs>(
      args?: Subset<T, ClassesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassesAggregateArgs>(args: Subset<T, ClassesAggregateArgs>): Prisma.PrismaPromise<GetClassesAggregateType<T>>

    /**
     * Group by Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassesGroupByArgs['orderBy'] }
        : { orderBy?: ClassesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classes model
   */
  readonly fields: ClassesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Classes$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Classes$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrations<T extends Classes$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Classes$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Classes$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Classes$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classes model
   */
  interface ClassesFieldRefs {
    readonly id: FieldRef<"Classes", 'Int'>
    readonly name: FieldRef<"Classes", 'String'>
    readonly level: FieldRef<"Classes", 'String'>
    readonly school_id: FieldRef<"Classes", 'String'>
    readonly supabase_id: FieldRef<"Classes", 'String'>
    readonly last_modified: FieldRef<"Classes", 'DateTime'>
    readonly needs_sync: FieldRef<"Classes", 'Boolean'>
    readonly is_deleted: FieldRef<"Classes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Classes findUnique
   */
  export type ClassesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes findUniqueOrThrow
   */
  export type ClassesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes findFirst
   */
  export type ClassesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * Classes findFirstOrThrow
   */
  export type ClassesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * Classes findMany
   */
  export type ClassesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassesOrderByWithRelationInput | ClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * Classes create
   */
  export type ClassesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * The data needed to create a Classes.
     */
    data: XOR<ClassesCreateInput, ClassesUncheckedCreateInput>
  }

  /**
   * Classes createMany
   */
  export type ClassesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassesCreateManyInput | ClassesCreateManyInput[]
  }

  /**
   * Classes createManyAndReturn
   */
  export type ClassesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassesCreateManyInput | ClassesCreateManyInput[]
  }

  /**
   * Classes update
   */
  export type ClassesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * The data needed to update a Classes.
     */
    data: XOR<ClassesUpdateInput, ClassesUncheckedUpdateInput>
    /**
     * Choose, which Classes to update.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes updateMany
   */
  export type ClassesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassesUpdateManyMutationInput, ClassesUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassesWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Classes updateManyAndReturn
   */
  export type ClassesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassesUpdateManyMutationInput, ClassesUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassesWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Classes upsert
   */
  export type ClassesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * The filter to search for the Classes to update in case it exists.
     */
    where: ClassesWhereUniqueInput
    /**
     * In case the Classes found by the `where` argument doesn't exist, create a new Classes with this data.
     */
    create: XOR<ClassesCreateInput, ClassesUncheckedCreateInput>
    /**
     * In case the Classes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassesUpdateInput, ClassesUncheckedUpdateInput>
  }

  /**
   * Classes delete
   */
  export type ClassesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
    /**
     * Filter which Classes to delete.
     */
    where: ClassesWhereUniqueInput
  }

  /**
   * Classes deleteMany
   */
  export type ClassesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassesWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Classes.lessons
   */
  export type Classes$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    cursor?: LessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Classes.registrations
   */
  export type Classes$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    where?: RegistrationsWhereInput
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    cursor?: RegistrationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Classes.subjects
   */
  export type Classes$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    where?: SubjectsWhereInput
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    cursor?: SubjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Classes without action
   */
  export type ClassesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classes
     */
    select?: ClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classes
     */
    omit?: ClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassesInclude<ExtArgs> | null
  }


  /**
   * Model Students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    id: number | null
  }

  export type StudentsSumAggregateOutputType = {
    id: number | null
  }

  export type StudentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    genre: string | null
    birth_date: string | null
    picture_url: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    matricul: string | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    genre: string | null
    birth_date: string | null
    picture_url: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    matricul: string | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    genre: number
    birth_date: number
    picture_url: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    matricul: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    id?: true
  }

  export type StudentsSumAggregateInputType = {
    id?: true
  }

  export type StudentsMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    genre?: true
    birth_date?: true
    picture_url?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    matricul?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    genre?: true
    birth_date?: true
    picture_url?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    matricul?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    genre?: true
    birth_date?: true
    picture_url?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    matricul?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to aggregate.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type StudentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentsWhereInput
    orderBy?: StudentsOrderByWithAggregationInput | StudentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: StudentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    genre: string | null
    birth_date: string | null
    picture_url: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    matricul: string | null
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends StudentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
    attendances?: boolean | Students$attendancesArgs<ExtArgs>
    notes?: boolean | Students$notesArgs<ExtArgs>
    registrations?: boolean | Students$registrationsArgs<ExtArgs>
    student_parents?: boolean | Students$student_parentsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    genre?: boolean
    birth_date?: boolean
    picture_url?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: boolean
  }

  export type StudentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "genre" | "birth_date" | "picture_url" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted" | "matricul", ExtArgs["result"]["students"]>
  export type StudentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | Students$attendancesArgs<ExtArgs>
    notes?: boolean | Students$notesArgs<ExtArgs>
    registrations?: boolean | Students$registrationsArgs<ExtArgs>
    student_parents?: boolean | Students$student_parentsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StudentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StudentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Students"
    objects: {
      attendances: Prisma.$AttendancesPayload<ExtArgs>[]
      notes: Prisma.$NotesPayload<ExtArgs>[]
      registrations: Prisma.$RegistrationsPayload<ExtArgs>[]
      student_parents: Prisma.$StudentParentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      genre: string | null
      birth_date: string | null
      picture_url: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
      matricul: string | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type StudentsGetPayload<S extends boolean | null | undefined | StudentsDefaultArgs> = $Result.GetResult<Prisma.$StudentsPayload, S>

  type StudentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface StudentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Students'], meta: { name: 'Students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {StudentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentsFindUniqueArgs>(args: SelectSubset<T, StudentsFindUniqueArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentsFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentsFindFirstArgs>(args?: SelectSubset<T, StudentsFindFirstArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentsFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentsFindManyArgs>(args?: SelectSubset<T, StudentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Students.
     * @param {StudentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends StudentsCreateArgs>(args: SelectSubset<T, StudentsCreateArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentsCreateManyArgs>(args?: SelectSubset<T, StudentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentsCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentsCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Students.
     * @param {StudentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends StudentsDeleteArgs>(args: SelectSubset<T, StudentsDeleteArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Students.
     * @param {StudentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentsUpdateArgs>(args: SelectSubset<T, StudentsUpdateArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentsDeleteManyArgs>(args?: SelectSubset<T, StudentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentsUpdateManyArgs>(args: SelectSubset<T, StudentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentsUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentsUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Students.
     * @param {StudentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends StudentsUpsertArgs>(args: SelectSubset<T, StudentsUpsertArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentsCountArgs>(
      args?: Subset<T, StudentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Students model
   */
  readonly fields: StudentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendances<T extends Students$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Students$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Students$notesArgs<ExtArgs> = {}>(args?: Subset<T, Students$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrations<T extends Students$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Students$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_parents<T extends Students$student_parentsArgs<ExtArgs> = {}>(args?: Subset<T, Students$student_parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Students model
   */
  interface StudentsFieldRefs {
    readonly id: FieldRef<"Students", 'Int'>
    readonly name: FieldRef<"Students", 'String'>
    readonly first_name: FieldRef<"Students", 'String'>
    readonly genre: FieldRef<"Students", 'String'>
    readonly birth_date: FieldRef<"Students", 'String'>
    readonly picture_url: FieldRef<"Students", 'String'>
    readonly supabase_id: FieldRef<"Students", 'String'>
    readonly last_modified: FieldRef<"Students", 'DateTime'>
    readonly needs_sync: FieldRef<"Students", 'Boolean'>
    readonly is_deleted: FieldRef<"Students", 'Boolean'>
    readonly matricul: FieldRef<"Students", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Students findUnique
   */
  export type StudentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students findUniqueOrThrow
   */
  export type StudentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students findFirst
   */
  export type StudentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students findFirstOrThrow
   */
  export type StudentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students findMany
   */
  export type StudentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students create
   */
  export type StudentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Students.
     */
    data?: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
  }

  /**
   * Students createMany
   */
  export type StudentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentsCreateManyInput | StudentsCreateManyInput[]
  }

  /**
   * Students createManyAndReturn
   */
  export type StudentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentsCreateManyInput | StudentsCreateManyInput[]
  }

  /**
   * Students update
   */
  export type StudentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Students.
     */
    data: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
    /**
     * Choose, which Students to update.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students updateMany
   */
  export type StudentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Students updateManyAndReturn
   */
  export type StudentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Students upsert
   */
  export type StudentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Students to update in case it exists.
     */
    where: StudentsWhereUniqueInput
    /**
     * In case the Students found by the `where` argument doesn't exist, create a new Students with this data.
     */
    create: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
    /**
     * In case the Students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
  }

  /**
   * Students delete
   */
  export type StudentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter which Students to delete.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students deleteMany
   */
  export type StudentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Students.attendances
   */
  export type Students$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    where?: AttendancesWhereInput
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    cursor?: AttendancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Students.notes
   */
  export type Students$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Students.registrations
   */
  export type Students$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    where?: RegistrationsWhereInput
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    cursor?: RegistrationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Students.student_parents
   */
  export type Students$student_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    where?: StudentParentsWhereInput
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    cursor?: StudentParentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * Students without action
   */
  export type StudentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
  }


  /**
   * Model Registrations
   */

  export type AggregateRegistrations = {
    _count: RegistrationsCountAggregateOutputType | null
    _avg: RegistrationsAvgAggregateOutputType | null
    _sum: RegistrationsSumAggregateOutputType | null
    _min: RegistrationsMinAggregateOutputType | null
    _max: RegistrationsMaxAggregateOutputType | null
  }

  export type RegistrationsAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
  }

  export type RegistrationsSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
  }

  export type RegistrationsMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
    school_year: string | null
    state: string | null
    registration_date: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type RegistrationsMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    class_id: number | null
    school_year: string | null
    state: string | null
    registration_date: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type RegistrationsCountAggregateOutputType = {
    id: number
    student_id: number
    class_id: number
    school_year: number
    state: number
    registration_date: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type RegistrationsAvgAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
  }

  export type RegistrationsSumAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
  }

  export type RegistrationsMinAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
    school_year?: true
    state?: true
    registration_date?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type RegistrationsMaxAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
    school_year?: true
    state?: true
    registration_date?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type RegistrationsCountAggregateInputType = {
    id?: true
    student_id?: true
    class_id?: true
    school_year?: true
    state?: true
    registration_date?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type RegistrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Registrations to aggregate.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Registrations
    **/
    _count?: true | RegistrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegistrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegistrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegistrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegistrationsMaxAggregateInputType
  }

  export type GetRegistrationsAggregateType<T extends RegistrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistrations[P]>
      : GetScalarType<T[P], AggregateRegistrations[P]>
  }




  export type RegistrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistrationsWhereInput
    orderBy?: RegistrationsOrderByWithAggregationInput | RegistrationsOrderByWithAggregationInput[]
    by: RegistrationsScalarFieldEnum[] | RegistrationsScalarFieldEnum
    having?: RegistrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegistrationsCountAggregateInputType | true
    _avg?: RegistrationsAvgAggregateInputType
    _sum?: RegistrationsSumAggregateInputType
    _min?: RegistrationsMinAggregateInputType
    _max?: RegistrationsMaxAggregateInputType
  }

  export type RegistrationsGroupByOutputType = {
    id: number
    student_id: number
    class_id: number
    school_year: string | null
    state: string | null
    registration_date: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: RegistrationsCountAggregateOutputType | null
    _avg: RegistrationsAvgAggregateOutputType | null
    _sum: RegistrationsSumAggregateOutputType | null
    _min: RegistrationsMinAggregateOutputType | null
    _max: RegistrationsMaxAggregateOutputType | null
  }

  type GetRegistrationsGroupByPayload<T extends RegistrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegistrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegistrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegistrationsGroupByOutputType[P]>
            : GetScalarType<T[P], RegistrationsGroupByOutputType[P]>
        }
      >
    >


  export type RegistrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: boolean | Registrations$paymentsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
    _count?: boolean | RegistrationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registrations"]>

  export type RegistrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registrations"]>

  export type RegistrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registrations"]>

  export type RegistrationsSelectScalar = {
    id?: boolean
    student_id?: boolean
    class_id?: boolean
    school_year?: boolean
    state?: boolean
    registration_date?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "class_id" | "school_year" | "state" | "registration_date" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["registrations"]>
  export type RegistrationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Registrations$paymentsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
    _count?: boolean | RegistrationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegistrationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type RegistrationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $RegistrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Registrations"
    objects: {
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
      class: Prisma.$ClassesPayload<ExtArgs>
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      class_id: number
      school_year: string | null
      state: string | null
      registration_date: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["registrations"]>
    composites: {}
  }

  type RegistrationsGetPayload<S extends boolean | null | undefined | RegistrationsDefaultArgs> = $Result.GetResult<Prisma.$RegistrationsPayload, S>

  type RegistrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegistrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegistrationsCountAggregateInputType | true
    }

  export interface RegistrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Registrations'], meta: { name: 'Registrations' } }
    /**
     * Find zero or one Registrations that matches the filter.
     * @param {RegistrationsFindUniqueArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegistrationsFindUniqueArgs>(args: SelectSubset<T, RegistrationsFindUniqueArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Registrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegistrationsFindUniqueOrThrowArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegistrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, RegistrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsFindFirstArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegistrationsFindFirstArgs>(args?: SelectSubset<T, RegistrationsFindFirstArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Registrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsFindFirstOrThrowArgs} args - Arguments to find a Registrations
     * @example
     * // Get one Registrations
     * const registrations = await prisma.registrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegistrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, RegistrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Registrations
     * const registrations = await prisma.registrations.findMany()
     * 
     * // Get first 10 Registrations
     * const registrations = await prisma.registrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registrationsWithIdOnly = await prisma.registrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegistrationsFindManyArgs>(args?: SelectSubset<T, RegistrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Registrations.
     * @param {RegistrationsCreateArgs} args - Arguments to create a Registrations.
     * @example
     * // Create one Registrations
     * const Registrations = await prisma.registrations.create({
     *   data: {
     *     // ... data to create a Registrations
     *   }
     * })
     * 
     */
    create<T extends RegistrationsCreateArgs>(args: SelectSubset<T, RegistrationsCreateArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Registrations.
     * @param {RegistrationsCreateManyArgs} args - Arguments to create many Registrations.
     * @example
     * // Create many Registrations
     * const registrations = await prisma.registrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegistrationsCreateManyArgs>(args?: SelectSubset<T, RegistrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Registrations and returns the data saved in the database.
     * @param {RegistrationsCreateManyAndReturnArgs} args - Arguments to create many Registrations.
     * @example
     * // Create many Registrations
     * const registrations = await prisma.registrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Registrations and only return the `id`
     * const registrationsWithIdOnly = await prisma.registrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegistrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, RegistrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Registrations.
     * @param {RegistrationsDeleteArgs} args - Arguments to delete one Registrations.
     * @example
     * // Delete one Registrations
     * const Registrations = await prisma.registrations.delete({
     *   where: {
     *     // ... filter to delete one Registrations
     *   }
     * })
     * 
     */
    delete<T extends RegistrationsDeleteArgs>(args: SelectSubset<T, RegistrationsDeleteArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Registrations.
     * @param {RegistrationsUpdateArgs} args - Arguments to update one Registrations.
     * @example
     * // Update one Registrations
     * const registrations = await prisma.registrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegistrationsUpdateArgs>(args: SelectSubset<T, RegistrationsUpdateArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Registrations.
     * @param {RegistrationsDeleteManyArgs} args - Arguments to filter Registrations to delete.
     * @example
     * // Delete a few Registrations
     * const { count } = await prisma.registrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegistrationsDeleteManyArgs>(args?: SelectSubset<T, RegistrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Registrations
     * const registrations = await prisma.registrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegistrationsUpdateManyArgs>(args: SelectSubset<T, RegistrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Registrations and returns the data updated in the database.
     * @param {RegistrationsUpdateManyAndReturnArgs} args - Arguments to update many Registrations.
     * @example
     * // Update many Registrations
     * const registrations = await prisma.registrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Registrations and only return the `id`
     * const registrationsWithIdOnly = await prisma.registrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegistrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, RegistrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Registrations.
     * @param {RegistrationsUpsertArgs} args - Arguments to update or create a Registrations.
     * @example
     * // Update or create a Registrations
     * const registrations = await prisma.registrations.upsert({
     *   create: {
     *     // ... data to create a Registrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Registrations we want to update
     *   }
     * })
     */
    upsert<T extends RegistrationsUpsertArgs>(args: SelectSubset<T, RegistrationsUpsertArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsCountArgs} args - Arguments to filter Registrations to count.
     * @example
     * // Count the number of Registrations
     * const count = await prisma.registrations.count({
     *   where: {
     *     // ... the filter for the Registrations we want to count
     *   }
     * })
    **/
    count<T extends RegistrationsCountArgs>(
      args?: Subset<T, RegistrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegistrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegistrationsAggregateArgs>(args: Subset<T, RegistrationsAggregateArgs>): Prisma.PrismaPromise<GetRegistrationsAggregateType<T>>

    /**
     * Group by Registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegistrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegistrationsGroupByArgs['orderBy'] }
        : { orderBy?: RegistrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegistrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Registrations model
   */
  readonly fields: RegistrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Registrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegistrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends Registrations$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Registrations$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class<T extends ClassesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassesDefaultArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Registrations model
   */
  interface RegistrationsFieldRefs {
    readonly id: FieldRef<"Registrations", 'Int'>
    readonly student_id: FieldRef<"Registrations", 'Int'>
    readonly class_id: FieldRef<"Registrations", 'Int'>
    readonly school_year: FieldRef<"Registrations", 'String'>
    readonly state: FieldRef<"Registrations", 'String'>
    readonly registration_date: FieldRef<"Registrations", 'String'>
    readonly supabase_id: FieldRef<"Registrations", 'String'>
    readonly last_modified: FieldRef<"Registrations", 'DateTime'>
    readonly needs_sync: FieldRef<"Registrations", 'Boolean'>
    readonly is_deleted: FieldRef<"Registrations", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Registrations findUnique
   */
  export type RegistrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations findUniqueOrThrow
   */
  export type RegistrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations findFirst
   */
  export type RegistrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Registrations.
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Registrations.
     */
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Registrations findFirstOrThrow
   */
  export type RegistrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Registrations.
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Registrations.
     */
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Registrations findMany
   */
  export type RegistrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter, which Registrations to fetch.
     */
    where?: RegistrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Registrations to fetch.
     */
    orderBy?: RegistrationsOrderByWithRelationInput | RegistrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Registrations.
     */
    cursor?: RegistrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Registrations.
     */
    skip?: number
    distinct?: RegistrationsScalarFieldEnum | RegistrationsScalarFieldEnum[]
  }

  /**
   * Registrations create
   */
  export type RegistrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Registrations.
     */
    data: XOR<RegistrationsCreateInput, RegistrationsUncheckedCreateInput>
  }

  /**
   * Registrations createMany
   */
  export type RegistrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Registrations.
     */
    data: RegistrationsCreateManyInput | RegistrationsCreateManyInput[]
  }

  /**
   * Registrations createManyAndReturn
   */
  export type RegistrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * The data used to create many Registrations.
     */
    data: RegistrationsCreateManyInput | RegistrationsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Registrations update
   */
  export type RegistrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Registrations.
     */
    data: XOR<RegistrationsUpdateInput, RegistrationsUncheckedUpdateInput>
    /**
     * Choose, which Registrations to update.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations updateMany
   */
  export type RegistrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Registrations.
     */
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyInput>
    /**
     * Filter which Registrations to update
     */
    where?: RegistrationsWhereInput
    /**
     * Limit how many Registrations to update.
     */
    limit?: number
  }

  /**
   * Registrations updateManyAndReturn
   */
  export type RegistrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * The data used to update Registrations.
     */
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyInput>
    /**
     * Filter which Registrations to update
     */
    where?: RegistrationsWhereInput
    /**
     * Limit how many Registrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Registrations upsert
   */
  export type RegistrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Registrations to update in case it exists.
     */
    where: RegistrationsWhereUniqueInput
    /**
     * In case the Registrations found by the `where` argument doesn't exist, create a new Registrations with this data.
     */
    create: XOR<RegistrationsCreateInput, RegistrationsUncheckedCreateInput>
    /**
     * In case the Registrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegistrationsUpdateInput, RegistrationsUncheckedUpdateInput>
  }

  /**
   * Registrations delete
   */
  export type RegistrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    /**
     * Filter which Registrations to delete.
     */
    where: RegistrationsWhereUniqueInput
  }

  /**
   * Registrations deleteMany
   */
  export type RegistrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Registrations to delete
     */
    where?: RegistrationsWhereInput
    /**
     * Limit how many Registrations to delete.
     */
    limit?: number
  }

  /**
   * Registrations.payments
   */
  export type Registrations$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Registrations without action
   */
  export type RegistrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
  }


  /**
   * Model Teachers
   */

  export type AggregateTeachers = {
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  export type TeachersAvgAggregateOutputType = {
    id: number | null
    hourlyRate: number | null
  }

  export type TeachersSumAggregateOutputType = {
    id: number | null
    hourlyRate: number | null
  }

  export type TeachersMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    password_hash: string | null
    role_id: string | null
    speciality: string | null
    matricule: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    hourlyRate: number | null
    school_id: string | null
  }

  export type TeachersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    password_hash: string | null
    role_id: string | null
    speciality: string | null
    matricule: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    hourlyRate: number | null
    school_id: string | null
  }

  export type TeachersCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    phone: number
    email: number
    adress: number
    password_hash: number
    role_id: number
    speciality: number
    matricule: number
    supabase_id: number
    user_supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    hourlyRate: number
    school_id: number
    _all: number
  }


  export type TeachersAvgAggregateInputType = {
    id?: true
    hourlyRate?: true
  }

  export type TeachersSumAggregateInputType = {
    id?: true
    hourlyRate?: true
  }

  export type TeachersMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    password_hash?: true
    role_id?: true
    speciality?: true
    matricule?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    hourlyRate?: true
    school_id?: true
  }

  export type TeachersMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    password_hash?: true
    role_id?: true
    speciality?: true
    matricule?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    hourlyRate?: true
    school_id?: true
  }

  export type TeachersCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    password_hash?: true
    role_id?: true
    speciality?: true
    matricule?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    hourlyRate?: true
    school_id?: true
    _all?: true
  }

  export type TeachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to aggregate.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachersMaxAggregateInputType
  }

  export type GetTeachersAggregateType<T extends TeachersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers[P]>
      : GetScalarType<T[P], AggregateTeachers[P]>
  }




  export type TeachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachersWhereInput
    orderBy?: TeachersOrderByWithAggregationInput | TeachersOrderByWithAggregationInput[]
    by: TeachersScalarFieldEnum[] | TeachersScalarFieldEnum
    having?: TeachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachersCountAggregateInputType | true
    _avg?: TeachersAvgAggregateInputType
    _sum?: TeachersSumAggregateInputType
    _min?: TeachersMinAggregateInputType
    _max?: TeachersMaxAggregateInputType
  }

  export type TeachersGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    password_hash: string | null
    role_id: string | null
    speciality: string | null
    matricule: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    hourlyRate: number | null
    school_id: string | null
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  type GetTeachersGroupByPayload<T extends TeachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachersGroupByOutputType[P]>
            : GetScalarType<T[P], TeachersGroupByOutputType[P]>
        }
      >
    >


  export type TeachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
    lessons?: boolean | Teachers$lessonsArgs<ExtArgs>
    workHours?: boolean | Teachers$workHoursArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type TeachersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["teachers"]>

  export type TeachersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["teachers"]>

  export type TeachersSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    password_hash?: boolean
    role_id?: boolean
    speciality?: boolean
    matricule?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: boolean
    school_id?: boolean
  }

  export type TeachersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "phone" | "email" | "adress" | "password_hash" | "role_id" | "speciality" | "matricule" | "supabase_id" | "user_supabase_id" | "last_modified" | "needs_sync" | "is_deleted" | "hourlyRate" | "school_id", ExtArgs["result"]["teachers"]>
  export type TeachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Teachers$lessonsArgs<ExtArgs>
    workHours?: boolean | Teachers$workHoursArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeachersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeachersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teachers"
    objects: {
      lessons: Prisma.$LessonsPayload<ExtArgs>[]
      workHours: Prisma.$TeacherWorkHoursPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      phone: string | null
      email: string | null
      adress: string | null
      password_hash: string | null
      role_id: string | null
      speciality: string | null
      matricule: string | null
      supabase_id: string | null
      user_supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
      hourlyRate: number | null
      school_id: string | null
    }, ExtArgs["result"]["teachers"]>
    composites: {}
  }

  type TeachersGetPayload<S extends boolean | null | undefined | TeachersDefaultArgs> = $Result.GetResult<Prisma.$TeachersPayload, S>

  type TeachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeachersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeachersCountAggregateInputType | true
    }

  export interface TeachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teachers'], meta: { name: 'Teachers' } }
    /**
     * Find zero or one Teachers that matches the filter.
     * @param {TeachersFindUniqueArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeachersFindUniqueArgs>(args: SelectSubset<T, TeachersFindUniqueArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teachers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeachersFindUniqueOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeachersFindUniqueOrThrowArgs>(args: SelectSubset<T, TeachersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindFirstArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeachersFindFirstArgs>(args?: SelectSubset<T, TeachersFindFirstArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindFirstOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeachersFindFirstOrThrowArgs>(args?: SelectSubset<T, TeachersFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teachers.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teachers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachersWithIdOnly = await prisma.teachers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeachersFindManyArgs>(args?: SelectSubset<T, TeachersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teachers.
     * @param {TeachersCreateArgs} args - Arguments to create a Teachers.
     * @example
     * // Create one Teachers
     * const Teachers = await prisma.teachers.create({
     *   data: {
     *     // ... data to create a Teachers
     *   }
     * })
     * 
     */
    create<T extends TeachersCreateArgs>(args: SelectSubset<T, TeachersCreateArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeachersCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeachersCreateManyArgs>(args?: SelectSubset<T, TeachersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeachersCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teachersWithIdOnly = await prisma.teachers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeachersCreateManyAndReturnArgs>(args?: SelectSubset<T, TeachersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teachers.
     * @param {TeachersDeleteArgs} args - Arguments to delete one Teachers.
     * @example
     * // Delete one Teachers
     * const Teachers = await prisma.teachers.delete({
     *   where: {
     *     // ... filter to delete one Teachers
     *   }
     * })
     * 
     */
    delete<T extends TeachersDeleteArgs>(args: SelectSubset<T, TeachersDeleteArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teachers.
     * @param {TeachersUpdateArgs} args - Arguments to update one Teachers.
     * @example
     * // Update one Teachers
     * const teachers = await prisma.teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeachersUpdateArgs>(args: SelectSubset<T, TeachersUpdateArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeachersDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeachersDeleteManyArgs>(args?: SelectSubset<T, TeachersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeachersUpdateManyArgs>(args: SelectSubset<T, TeachersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeachersUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teachersWithIdOnly = await prisma.teachers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeachersUpdateManyAndReturnArgs>(args: SelectSubset<T, TeachersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teachers.
     * @param {TeachersUpsertArgs} args - Arguments to update or create a Teachers.
     * @example
     * // Update or create a Teachers
     * const teachers = await prisma.teachers.upsert({
     *   create: {
     *     // ... data to create a Teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers we want to update
     *   }
     * })
     */
    upsert<T extends TeachersUpsertArgs>(args: SelectSubset<T, TeachersUpsertArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teachers.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeachersCountArgs>(
      args?: Subset<T, TeachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachersAggregateArgs>(args: Subset<T, TeachersAggregateArgs>): Prisma.PrismaPromise<GetTeachersAggregateType<T>>

    /**
     * Group by Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeachersGroupByArgs['orderBy'] }
        : { orderBy?: TeachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teachers model
   */
  readonly fields: TeachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Teachers$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Teachers$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workHours<T extends Teachers$workHoursArgs<ExtArgs> = {}>(args?: Subset<T, Teachers$workHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teachers model
   */
  interface TeachersFieldRefs {
    readonly id: FieldRef<"Teachers", 'Int'>
    readonly name: FieldRef<"Teachers", 'String'>
    readonly first_name: FieldRef<"Teachers", 'String'>
    readonly phone: FieldRef<"Teachers", 'String'>
    readonly email: FieldRef<"Teachers", 'String'>
    readonly adress: FieldRef<"Teachers", 'String'>
    readonly password_hash: FieldRef<"Teachers", 'String'>
    readonly role_id: FieldRef<"Teachers", 'String'>
    readonly speciality: FieldRef<"Teachers", 'String'>
    readonly matricule: FieldRef<"Teachers", 'String'>
    readonly supabase_id: FieldRef<"Teachers", 'String'>
    readonly user_supabase_id: FieldRef<"Teachers", 'String'>
    readonly last_modified: FieldRef<"Teachers", 'DateTime'>
    readonly needs_sync: FieldRef<"Teachers", 'Boolean'>
    readonly is_deleted: FieldRef<"Teachers", 'Boolean'>
    readonly hourlyRate: FieldRef<"Teachers", 'Float'>
    readonly school_id: FieldRef<"Teachers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Teachers findUnique
   */
  export type TeachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers findUniqueOrThrow
   */
  export type TeachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers findFirst
   */
  export type TeachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * Teachers findFirstOrThrow
   */
  export type TeachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * Teachers findMany
   */
  export type TeachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * Teachers create
   */
  export type TeachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The data needed to create a Teachers.
     */
    data?: XOR<TeachersCreateInput, TeachersUncheckedCreateInput>
  }

  /**
   * Teachers createMany
   */
  export type TeachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeachersCreateManyInput | TeachersCreateManyInput[]
  }

  /**
   * Teachers createManyAndReturn
   */
  export type TeachersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeachersCreateManyInput | TeachersCreateManyInput[]
  }

  /**
   * Teachers update
   */
  export type TeachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The data needed to update a Teachers.
     */
    data: XOR<TeachersUpdateInput, TeachersUncheckedUpdateInput>
    /**
     * Choose, which Teachers to update.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers updateMany
   */
  export type TeachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeachersUpdateManyMutationInput, TeachersUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeachersWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teachers updateManyAndReturn
   */
  export type TeachersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeachersUpdateManyMutationInput, TeachersUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeachersWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teachers upsert
   */
  export type TeachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The filter to search for the Teachers to update in case it exists.
     */
    where: TeachersWhereUniqueInput
    /**
     * In case the Teachers found by the `where` argument doesn't exist, create a new Teachers with this data.
     */
    create: XOR<TeachersCreateInput, TeachersUncheckedCreateInput>
    /**
     * In case the Teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeachersUpdateInput, TeachersUncheckedUpdateInput>
  }

  /**
   * Teachers delete
   */
  export type TeachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter which Teachers to delete.
     */
    where: TeachersWhereUniqueInput
  }

  /**
   * Teachers deleteMany
   */
  export type TeachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeachersWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teachers.lessons
   */
  export type Teachers$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    cursor?: LessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Teachers.workHours
   */
  export type Teachers$workHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    where?: TeacherWorkHoursWhereInput
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    cursor?: TeacherWorkHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * Teachers without action
   */
  export type TeachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
  }


  /**
   * Model TeacherWorkHours
   */

  export type AggregateTeacherWorkHours = {
    _count: TeacherWorkHoursCountAggregateOutputType | null
    _avg: TeacherWorkHoursAvgAggregateOutputType | null
    _sum: TeacherWorkHoursSumAggregateOutputType | null
    _min: TeacherWorkHoursMinAggregateOutputType | null
    _max: TeacherWorkHoursMaxAggregateOutputType | null
  }

  export type TeacherWorkHoursAvgAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    hours: number | null
  }

  export type TeacherWorkHoursSumAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    hours: number | null
  }

  export type TeacherWorkHoursMinAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    hours: number | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type TeacherWorkHoursMaxAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    subject_id: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    hours: number | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type TeacherWorkHoursCountAggregateOutputType = {
    id: number
    teacher_id: number
    subject_id: number
    date: number
    start_time: number
    end_time: number
    hours: number
    notes: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type TeacherWorkHoursAvgAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    hours?: true
  }

  export type TeacherWorkHoursSumAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    hours?: true
  }

  export type TeacherWorkHoursMinAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    date?: true
    start_time?: true
    end_time?: true
    hours?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type TeacherWorkHoursMaxAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    date?: true
    start_time?: true
    end_time?: true
    hours?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type TeacherWorkHoursCountAggregateInputType = {
    id?: true
    teacher_id?: true
    subject_id?: true
    date?: true
    start_time?: true
    end_time?: true
    hours?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type TeacherWorkHoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherWorkHours to aggregate.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherWorkHours
    **/
    _count?: true | TeacherWorkHoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherWorkHoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherWorkHoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherWorkHoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherWorkHoursMaxAggregateInputType
  }

  export type GetTeacherWorkHoursAggregateType<T extends TeacherWorkHoursAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherWorkHours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherWorkHours[P]>
      : GetScalarType<T[P], AggregateTeacherWorkHours[P]>
  }




  export type TeacherWorkHoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkHoursWhereInput
    orderBy?: TeacherWorkHoursOrderByWithAggregationInput | TeacherWorkHoursOrderByWithAggregationInput[]
    by: TeacherWorkHoursScalarFieldEnum[] | TeacherWorkHoursScalarFieldEnum
    having?: TeacherWorkHoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherWorkHoursCountAggregateInputType | true
    _avg?: TeacherWorkHoursAvgAggregateInputType
    _sum?: TeacherWorkHoursSumAggregateInputType
    _min?: TeacherWorkHoursMinAggregateInputType
    _max?: TeacherWorkHoursMaxAggregateInputType
  }

  export type TeacherWorkHoursGroupByOutputType = {
    id: number
    teacher_id: number
    subject_id: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    hours: number
    notes: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: TeacherWorkHoursCountAggregateOutputType | null
    _avg: TeacherWorkHoursAvgAggregateOutputType | null
    _sum: TeacherWorkHoursSumAggregateOutputType | null
    _min: TeacherWorkHoursMinAggregateOutputType | null
    _max: TeacherWorkHoursMaxAggregateOutputType | null
  }

  type GetTeacherWorkHoursGroupByPayload<T extends TeacherWorkHoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherWorkHoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherWorkHoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherWorkHoursGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherWorkHoursGroupByOutputType[P]>
        }
      >
    >


  export type TeacherWorkHoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherWorkHours"]>

  export type TeacherWorkHoursSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherWorkHours"]>

  export type TeacherWorkHoursSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherWorkHours"]>

  export type TeacherWorkHoursSelectScalar = {
    id?: boolean
    teacher_id?: boolean
    subject_id?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    hours?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacher_id" | "subject_id" | "date" | "start_time" | "end_time" | "hours" | "notes" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["teacherWorkHours"]>
  export type TeacherWorkHoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }
  export type TeacherWorkHoursIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }
  export type TeacherWorkHoursIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | TeacherWorkHours$subjectArgs<ExtArgs>
    teacher?: boolean | TeachersDefaultArgs<ExtArgs>
  }

  export type $TeacherWorkHoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherWorkHours"
    objects: {
      subject: Prisma.$SubjectsPayload<ExtArgs> | null
      teacher: Prisma.$TeachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacher_id: number
      subject_id: number | null
      date: string | null
      start_time: string | null
      end_time: string | null
      hours: number
      notes: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["teacherWorkHours"]>
    composites: {}
  }

  type TeacherWorkHoursGetPayload<S extends boolean | null | undefined | TeacherWorkHoursDefaultArgs> = $Result.GetResult<Prisma.$TeacherWorkHoursPayload, S>

  type TeacherWorkHoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherWorkHoursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherWorkHoursCountAggregateInputType | true
    }

  export interface TeacherWorkHoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherWorkHours'], meta: { name: 'TeacherWorkHours' } }
    /**
     * Find zero or one TeacherWorkHours that matches the filter.
     * @param {TeacherWorkHoursFindUniqueArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherWorkHoursFindUniqueArgs>(args: SelectSubset<T, TeacherWorkHoursFindUniqueArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherWorkHours that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherWorkHoursFindUniqueOrThrowArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherWorkHoursFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherWorkHoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherWorkHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursFindFirstArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherWorkHoursFindFirstArgs>(args?: SelectSubset<T, TeacherWorkHoursFindFirstArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherWorkHours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursFindFirstOrThrowArgs} args - Arguments to find a TeacherWorkHours
     * @example
     * // Get one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherWorkHoursFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherWorkHoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherWorkHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findMany()
     * 
     * // Get first 10 TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWorkHoursWithIdOnly = await prisma.teacherWorkHours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherWorkHoursFindManyArgs>(args?: SelectSubset<T, TeacherWorkHoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherWorkHours.
     * @param {TeacherWorkHoursCreateArgs} args - Arguments to create a TeacherWorkHours.
     * @example
     * // Create one TeacherWorkHours
     * const TeacherWorkHours = await prisma.teacherWorkHours.create({
     *   data: {
     *     // ... data to create a TeacherWorkHours
     *   }
     * })
     * 
     */
    create<T extends TeacherWorkHoursCreateArgs>(args: SelectSubset<T, TeacherWorkHoursCreateArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherWorkHours.
     * @param {TeacherWorkHoursCreateManyArgs} args - Arguments to create many TeacherWorkHours.
     * @example
     * // Create many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherWorkHoursCreateManyArgs>(args?: SelectSubset<T, TeacherWorkHoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherWorkHours and returns the data saved in the database.
     * @param {TeacherWorkHoursCreateManyAndReturnArgs} args - Arguments to create many TeacherWorkHours.
     * @example
     * // Create many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherWorkHours and only return the `id`
     * const teacherWorkHoursWithIdOnly = await prisma.teacherWorkHours.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherWorkHoursCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherWorkHoursCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeacherWorkHours.
     * @param {TeacherWorkHoursDeleteArgs} args - Arguments to delete one TeacherWorkHours.
     * @example
     * // Delete one TeacherWorkHours
     * const TeacherWorkHours = await prisma.teacherWorkHours.delete({
     *   where: {
     *     // ... filter to delete one TeacherWorkHours
     *   }
     * })
     * 
     */
    delete<T extends TeacherWorkHoursDeleteArgs>(args: SelectSubset<T, TeacherWorkHoursDeleteArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherWorkHours.
     * @param {TeacherWorkHoursUpdateArgs} args - Arguments to update one TeacherWorkHours.
     * @example
     * // Update one TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherWorkHoursUpdateArgs>(args: SelectSubset<T, TeacherWorkHoursUpdateArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherWorkHours.
     * @param {TeacherWorkHoursDeleteManyArgs} args - Arguments to filter TeacherWorkHours to delete.
     * @example
     * // Delete a few TeacherWorkHours
     * const { count } = await prisma.teacherWorkHours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherWorkHoursDeleteManyArgs>(args?: SelectSubset<T, TeacherWorkHoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherWorkHoursUpdateManyArgs>(args: SelectSubset<T, TeacherWorkHoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherWorkHours and returns the data updated in the database.
     * @param {TeacherWorkHoursUpdateManyAndReturnArgs} args - Arguments to update many TeacherWorkHours.
     * @example
     * // Update many TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeacherWorkHours and only return the `id`
     * const teacherWorkHoursWithIdOnly = await prisma.teacherWorkHours.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherWorkHoursUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherWorkHoursUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeacherWorkHours.
     * @param {TeacherWorkHoursUpsertArgs} args - Arguments to update or create a TeacherWorkHours.
     * @example
     * // Update or create a TeacherWorkHours
     * const teacherWorkHours = await prisma.teacherWorkHours.upsert({
     *   create: {
     *     // ... data to create a TeacherWorkHours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherWorkHours we want to update
     *   }
     * })
     */
    upsert<T extends TeacherWorkHoursUpsertArgs>(args: SelectSubset<T, TeacherWorkHoursUpsertArgs<ExtArgs>>): Prisma__TeacherWorkHoursClient<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursCountArgs} args - Arguments to filter TeacherWorkHours to count.
     * @example
     * // Count the number of TeacherWorkHours
     * const count = await prisma.teacherWorkHours.count({
     *   where: {
     *     // ... the filter for the TeacherWorkHours we want to count
     *   }
     * })
    **/
    count<T extends TeacherWorkHoursCountArgs>(
      args?: Subset<T, TeacherWorkHoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherWorkHoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherWorkHoursAggregateArgs>(args: Subset<T, TeacherWorkHoursAggregateArgs>): Prisma.PrismaPromise<GetTeacherWorkHoursAggregateType<T>>

    /**
     * Group by TeacherWorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkHoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherWorkHoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherWorkHoursGroupByArgs['orderBy'] }
        : { orderBy?: TeacherWorkHoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherWorkHoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherWorkHoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherWorkHours model
   */
  readonly fields: TeacherWorkHoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherWorkHours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherWorkHoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends TeacherWorkHours$subjectArgs<ExtArgs> = {}>(args?: Subset<T, TeacherWorkHours$subjectArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeachersDefaultArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherWorkHours model
   */
  interface TeacherWorkHoursFieldRefs {
    readonly id: FieldRef<"TeacherWorkHours", 'Int'>
    readonly teacher_id: FieldRef<"TeacherWorkHours", 'Int'>
    readonly subject_id: FieldRef<"TeacherWorkHours", 'Int'>
    readonly date: FieldRef<"TeacherWorkHours", 'String'>
    readonly start_time: FieldRef<"TeacherWorkHours", 'String'>
    readonly end_time: FieldRef<"TeacherWorkHours", 'String'>
    readonly hours: FieldRef<"TeacherWorkHours", 'Float'>
    readonly notes: FieldRef<"TeacherWorkHours", 'String'>
    readonly supabase_id: FieldRef<"TeacherWorkHours", 'String'>
    readonly last_modified: FieldRef<"TeacherWorkHours", 'DateTime'>
    readonly needs_sync: FieldRef<"TeacherWorkHours", 'Boolean'>
    readonly is_deleted: FieldRef<"TeacherWorkHours", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TeacherWorkHours findUnique
   */
  export type TeacherWorkHoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours findUniqueOrThrow
   */
  export type TeacherWorkHoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours findFirst
   */
  export type TeacherWorkHoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherWorkHours.
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherWorkHours.
     */
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * TeacherWorkHours findFirstOrThrow
   */
  export type TeacherWorkHoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherWorkHours.
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherWorkHours.
     */
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * TeacherWorkHours findMany
   */
  export type TeacherWorkHoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkHours to fetch.
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkHours to fetch.
     */
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherWorkHours.
     */
    cursor?: TeacherWorkHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkHours.
     */
    skip?: number
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * TeacherWorkHours create
   */
  export type TeacherWorkHoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursCreateInput, TeacherWorkHoursUncheckedCreateInput>
  }

  /**
   * TeacherWorkHours createMany
   */
  export type TeacherWorkHoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherWorkHours.
     */
    data: TeacherWorkHoursCreateManyInput | TeacherWorkHoursCreateManyInput[]
  }

  /**
   * TeacherWorkHours createManyAndReturn
   */
  export type TeacherWorkHoursCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * The data used to create many TeacherWorkHours.
     */
    data: TeacherWorkHoursCreateManyInput | TeacherWorkHoursCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherWorkHours update
   */
  export type TeacherWorkHoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursUpdateInput, TeacherWorkHoursUncheckedUpdateInput>
    /**
     * Choose, which TeacherWorkHours to update.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours updateMany
   */
  export type TeacherWorkHoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyInput>
    /**
     * Filter which TeacherWorkHours to update
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * Limit how many TeacherWorkHours to update.
     */
    limit?: number
  }

  /**
   * TeacherWorkHours updateManyAndReturn
   */
  export type TeacherWorkHoursUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * The data used to update TeacherWorkHours.
     */
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyInput>
    /**
     * Filter which TeacherWorkHours to update
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * Limit how many TeacherWorkHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherWorkHours upsert
   */
  export type TeacherWorkHoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherWorkHours to update in case it exists.
     */
    where: TeacherWorkHoursWhereUniqueInput
    /**
     * In case the TeacherWorkHours found by the `where` argument doesn't exist, create a new TeacherWorkHours with this data.
     */
    create: XOR<TeacherWorkHoursCreateInput, TeacherWorkHoursUncheckedCreateInput>
    /**
     * In case the TeacherWorkHours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherWorkHoursUpdateInput, TeacherWorkHoursUncheckedUpdateInput>
  }

  /**
   * TeacherWorkHours delete
   */
  export type TeacherWorkHoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    /**
     * Filter which TeacherWorkHours to delete.
     */
    where: TeacherWorkHoursWhereUniqueInput
  }

  /**
   * TeacherWorkHours deleteMany
   */
  export type TeacherWorkHoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherWorkHours to delete
     */
    where?: TeacherWorkHoursWhereInput
    /**
     * Limit how many TeacherWorkHours to delete.
     */
    limit?: number
  }

  /**
   * TeacherWorkHours.subject
   */
  export type TeacherWorkHours$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    where?: SubjectsWhereInput
  }

  /**
   * TeacherWorkHours without action
   */
  export type TeacherWorkHoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
  }


  /**
   * Model Lessons
   */

  export type AggregateLessons = {
    _count: LessonsCountAggregateOutputType | null
    _avg: LessonsAvgAggregateOutputType | null
    _sum: LessonsSumAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  export type LessonsAvgAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
  }

  export type LessonsSumAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
  }

  export type LessonsMinAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
    school_year: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type LessonsMaxAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_id: number | null
    subject_id: number | null
    school_year: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type LessonsCountAggregateOutputType = {
    id: number
    teacher_id: number
    class_id: number
    subject_id: number
    school_year: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type LessonsAvgAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
  }

  export type LessonsSumAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
  }

  export type LessonsMinAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
    school_year?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type LessonsMaxAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
    school_year?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type LessonsCountAggregateInputType = {
    id?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
    school_year?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type LessonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to aggregate.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonsMaxAggregateInputType
  }

  export type GetLessonsAggregateType<T extends LessonsAggregateArgs> = {
        [P in keyof T & keyof AggregateLessons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessons[P]>
      : GetScalarType<T[P], AggregateLessons[P]>
  }




  export type LessonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithAggregationInput | LessonsOrderByWithAggregationInput[]
    by: LessonsScalarFieldEnum[] | LessonsScalarFieldEnum
    having?: LessonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonsCountAggregateInputType | true
    _avg?: LessonsAvgAggregateInputType
    _sum?: LessonsSumAggregateInputType
    _min?: LessonsMinAggregateInputType
    _max?: LessonsMaxAggregateInputType
  }

  export type LessonsGroupByOutputType = {
    id: number
    teacher_id: number | null
    class_id: number
    subject_id: number
    school_year: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: LessonsCountAggregateOutputType | null
    _avg: LessonsAvgAggregateOutputType | null
    _sum: LessonsSumAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  type GetLessonsGroupByPayload<T extends LessonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonsGroupByOutputType[P]>
            : GetScalarType<T[P], LessonsGroupByOutputType[P]>
        }
      >
    >


  export type LessonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
    notes?: boolean | Lessons$notesArgs<ExtArgs>
    schedules?: boolean | Lessons$schedulesArgs<ExtArgs>
    _count?: boolean | LessonsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>

  export type LessonsSelectScalar = {
    id?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    school_year?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacher_id" | "class_id" | "subject_id" | "school_year" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["lessons"]>
  export type LessonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
    notes?: boolean | Lessons$notesArgs<ExtArgs>
    schedules?: boolean | Lessons$schedulesArgs<ExtArgs>
    _count?: boolean | LessonsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }
  export type LessonsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectsDefaultArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    teacher?: boolean | Lessons$teacherArgs<ExtArgs>
  }

  export type $LessonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lessons"
    objects: {
      subject: Prisma.$SubjectsPayload<ExtArgs>
      class: Prisma.$ClassesPayload<ExtArgs>
      teacher: Prisma.$TeachersPayload<ExtArgs> | null
      notes: Prisma.$NotesPayload<ExtArgs>[]
      schedules: Prisma.$SchedulesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacher_id: number | null
      class_id: number
      subject_id: number
      school_year: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["lessons"]>
    composites: {}
  }

  type LessonsGetPayload<S extends boolean | null | undefined | LessonsDefaultArgs> = $Result.GetResult<Prisma.$LessonsPayload, S>

  type LessonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonsCountAggregateInputType | true
    }

  export interface LessonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lessons'], meta: { name: 'Lessons' } }
    /**
     * Find zero or one Lessons that matches the filter.
     * @param {LessonsFindUniqueArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonsFindUniqueArgs>(args: SelectSubset<T, LessonsFindUniqueArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lessons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonsFindUniqueOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonsFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindFirstArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonsFindFirstArgs>(args?: SelectSubset<T, LessonsFindFirstArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lessons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindFirstOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonsFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lessons.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lessons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonsWithIdOnly = await prisma.lessons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonsFindManyArgs>(args?: SelectSubset<T, LessonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lessons.
     * @param {LessonsCreateArgs} args - Arguments to create a Lessons.
     * @example
     * // Create one Lessons
     * const Lessons = await prisma.lessons.create({
     *   data: {
     *     // ... data to create a Lessons
     *   }
     * })
     * 
     */
    create<T extends LessonsCreateArgs>(args: SelectSubset<T, LessonsCreateArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonsCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lessons = await prisma.lessons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonsCreateManyArgs>(args?: SelectSubset<T, LessonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonsCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lessons = await prisma.lessons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonsWithIdOnly = await prisma.lessons.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonsCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lessons.
     * @param {LessonsDeleteArgs} args - Arguments to delete one Lessons.
     * @example
     * // Delete one Lessons
     * const Lessons = await prisma.lessons.delete({
     *   where: {
     *     // ... filter to delete one Lessons
     *   }
     * })
     * 
     */
    delete<T extends LessonsDeleteArgs>(args: SelectSubset<T, LessonsDeleteArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lessons.
     * @param {LessonsUpdateArgs} args - Arguments to update one Lessons.
     * @example
     * // Update one Lessons
     * const lessons = await prisma.lessons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonsUpdateArgs>(args: SelectSubset<T, LessonsUpdateArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonsDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lessons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonsDeleteManyArgs>(args?: SelectSubset<T, LessonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lessons = await prisma.lessons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonsUpdateManyArgs>(args: SelectSubset<T, LessonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonsUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lessons = await prisma.lessons.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonsWithIdOnly = await prisma.lessons.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonsUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lessons.
     * @param {LessonsUpsertArgs} args - Arguments to update or create a Lessons.
     * @example
     * // Update or create a Lessons
     * const lessons = await prisma.lessons.upsert({
     *   create: {
     *     // ... data to create a Lessons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lessons we want to update
     *   }
     * })
     */
    upsert<T extends LessonsUpsertArgs>(args: SelectSubset<T, LessonsUpsertArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lessons.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonsCountArgs>(
      args?: Subset<T, LessonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonsAggregateArgs>(args: Subset<T, LessonsAggregateArgs>): Prisma.PrismaPromise<GetLessonsAggregateType<T>>

    /**
     * Group by Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonsGroupByArgs['orderBy'] }
        : { orderBy?: LessonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lessons model
   */
  readonly fields: LessonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lessons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectsDefaultArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassesDefaultArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends Lessons$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Lessons$teacherArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notes<T extends Lessons$notesArgs<ExtArgs> = {}>(args?: Subset<T, Lessons$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Lessons$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Lessons$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lessons model
   */
  interface LessonsFieldRefs {
    readonly id: FieldRef<"Lessons", 'Int'>
    readonly teacher_id: FieldRef<"Lessons", 'Int'>
    readonly class_id: FieldRef<"Lessons", 'Int'>
    readonly subject_id: FieldRef<"Lessons", 'Int'>
    readonly school_year: FieldRef<"Lessons", 'String'>
    readonly supabase_id: FieldRef<"Lessons", 'String'>
    readonly last_modified: FieldRef<"Lessons", 'DateTime'>
    readonly needs_sync: FieldRef<"Lessons", 'Boolean'>
    readonly is_deleted: FieldRef<"Lessons", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Lessons findUnique
   */
  export type LessonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons findUniqueOrThrow
   */
  export type LessonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons findFirst
   */
  export type LessonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons findFirstOrThrow
   */
  export type LessonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons findMany
   */
  export type LessonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Lessons create
   */
  export type LessonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The data needed to create a Lessons.
     */
    data: XOR<LessonsCreateInput, LessonsUncheckedCreateInput>
  }

  /**
   * Lessons createMany
   */
  export type LessonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonsCreateManyInput | LessonsCreateManyInput[]
  }

  /**
   * Lessons createManyAndReturn
   */
  export type LessonsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonsCreateManyInput | LessonsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lessons update
   */
  export type LessonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The data needed to update a Lessons.
     */
    data: XOR<LessonsUpdateInput, LessonsUncheckedUpdateInput>
    /**
     * Choose, which Lessons to update.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons updateMany
   */
  export type LessonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonsWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lessons updateManyAndReturn
   */
  export type LessonsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonsWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lessons upsert
   */
  export type LessonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * The filter to search for the Lessons to update in case it exists.
     */
    where: LessonsWhereUniqueInput
    /**
     * In case the Lessons found by the `where` argument doesn't exist, create a new Lessons with this data.
     */
    create: XOR<LessonsCreateInput, LessonsUncheckedCreateInput>
    /**
     * In case the Lessons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonsUpdateInput, LessonsUncheckedUpdateInput>
  }

  /**
   * Lessons delete
   */
  export type LessonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    /**
     * Filter which Lessons to delete.
     */
    where: LessonsWhereUniqueInput
  }

  /**
   * Lessons deleteMany
   */
  export type LessonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonsWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lessons.teacher
   */
  export type Lessons$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teachers
     */
    omit?: TeachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeachersInclude<ExtArgs> | null
    where?: TeachersWhereInput
  }

  /**
   * Lessons.notes
   */
  export type Lessons$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    cursor?: NotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Lessons.schedules
   */
  export type Lessons$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    where?: SchedulesWhereInput
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    cursor?: SchedulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Lessons without action
   */
  export type LessonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
  }


  /**
   * Model Subjects
   */

  export type AggregateSubjects = {
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  export type SubjectsAvgAggregateOutputType = {
    id: number | null
    class_id: number | null
    coefficient: number | null
  }

  export type SubjectsSumAggregateOutputType = {
    id: number | null
    class_id: number | null
    coefficient: number | null
  }

  export type SubjectsMinAggregateOutputType = {
    id: number | null
    name: string | null
    class_id: number | null
    school_year: string | null
    coefficient: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SubjectsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    class_id: number | null
    school_year: string | null
    coefficient: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SubjectsCountAggregateOutputType = {
    id: number
    name: number
    class_id: number
    school_year: number
    coefficient: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type SubjectsAvgAggregateInputType = {
    id?: true
    class_id?: true
    coefficient?: true
  }

  export type SubjectsSumAggregateInputType = {
    id?: true
    class_id?: true
    coefficient?: true
  }

  export type SubjectsMinAggregateInputType = {
    id?: true
    name?: true
    class_id?: true
    school_year?: true
    coefficient?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SubjectsMaxAggregateInputType = {
    id?: true
    name?: true
    class_id?: true
    school_year?: true
    coefficient?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SubjectsCountAggregateInputType = {
    id?: true
    name?: true
    class_id?: true
    school_year?: true
    coefficient?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type SubjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to aggregate.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectsMaxAggregateInputType
  }

  export type GetSubjectsAggregateType<T extends SubjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjects[P]>
      : GetScalarType<T[P], AggregateSubjects[P]>
  }




  export type SubjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectsWhereInput
    orderBy?: SubjectsOrderByWithAggregationInput | SubjectsOrderByWithAggregationInput[]
    by: SubjectsScalarFieldEnum[] | SubjectsScalarFieldEnum
    having?: SubjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectsCountAggregateInputType | true
    _avg?: SubjectsAvgAggregateInputType
    _sum?: SubjectsSumAggregateInputType
    _min?: SubjectsMinAggregateInputType
    _max?: SubjectsMaxAggregateInputType
  }

  export type SubjectsGroupByOutputType = {
    id: number
    name: string
    class_id: number
    school_year: string | null
    coefficient: number | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  type GetSubjectsGroupByPayload<T extends SubjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
        }
      >
    >


  export type SubjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: boolean | Subjects$lessonsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    workHours?: boolean | Subjects$workHoursArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>

  export type SubjectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>

  export type SubjectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>

  export type SubjectsSelectScalar = {
    id?: boolean
    name?: boolean
    class_id?: boolean
    school_year?: boolean
    coefficient?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SubjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "class_id" | "school_year" | "coefficient" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["subjects"]>
  export type SubjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Subjects$lessonsArgs<ExtArgs>
    class?: boolean | ClassesDefaultArgs<ExtArgs>
    workHours?: boolean | Subjects$workHoursArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }
  export type SubjectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassesDefaultArgs<ExtArgs>
  }

  export type $SubjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subjects"
    objects: {
      lessons: Prisma.$LessonsPayload<ExtArgs>[]
      class: Prisma.$ClassesPayload<ExtArgs>
      workHours: Prisma.$TeacherWorkHoursPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      class_id: number
      school_year: string | null
      coefficient: number | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["subjects"]>
    composites: {}
  }

  type SubjectsGetPayload<S extends boolean | null | undefined | SubjectsDefaultArgs> = $Result.GetResult<Prisma.$SubjectsPayload, S>

  type SubjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectsCountAggregateInputType | true
    }

  export interface SubjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subjects'], meta: { name: 'Subjects' } }
    /**
     * Find zero or one Subjects that matches the filter.
     * @param {SubjectsFindUniqueArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectsFindUniqueArgs>(args: SelectSubset<T, SubjectsFindUniqueArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectsFindUniqueOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsFindFirstArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectsFindFirstArgs>(args?: SelectSubset<T, SubjectsFindFirstArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsFindFirstOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subjects.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subjects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectsWithIdOnly = await prisma.subjects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectsFindManyArgs>(args?: SelectSubset<T, SubjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subjects.
     * @param {SubjectsCreateArgs} args - Arguments to create a Subjects.
     * @example
     * // Create one Subjects
     * const Subjects = await prisma.subjects.create({
     *   data: {
     *     // ... data to create a Subjects
     *   }
     * })
     * 
     */
    create<T extends SubjectsCreateArgs>(args: SelectSubset<T, SubjectsCreateArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectsCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectsCreateManyArgs>(args?: SelectSubset<T, SubjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectsCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectsWithIdOnly = await prisma.subjects.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subjects.
     * @param {SubjectsDeleteArgs} args - Arguments to delete one Subjects.
     * @example
     * // Delete one Subjects
     * const Subjects = await prisma.subjects.delete({
     *   where: {
     *     // ... filter to delete one Subjects
     *   }
     * })
     * 
     */
    delete<T extends SubjectsDeleteArgs>(args: SelectSubset<T, SubjectsDeleteArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subjects.
     * @param {SubjectsUpdateArgs} args - Arguments to update one Subjects.
     * @example
     * // Update one Subjects
     * const subjects = await prisma.subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectsUpdateArgs>(args: SelectSubset<T, SubjectsUpdateArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectsDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectsDeleteManyArgs>(args?: SelectSubset<T, SubjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectsUpdateManyArgs>(args: SelectSubset<T, SubjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectsUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectsWithIdOnly = await prisma.subjects.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subjects.
     * @param {SubjectsUpsertArgs} args - Arguments to update or create a Subjects.
     * @example
     * // Update or create a Subjects
     * const subjects = await prisma.subjects.upsert({
     *   create: {
     *     // ... data to create a Subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjects we want to update
     *   }
     * })
     */
    upsert<T extends SubjectsUpsertArgs>(args: SelectSubset<T, SubjectsUpsertArgs<ExtArgs>>): Prisma__SubjectsClient<$Result.GetResult<Prisma.$SubjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subjects.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectsCountArgs>(
      args?: Subset<T, SubjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectsAggregateArgs>(args: Subset<T, SubjectsAggregateArgs>): Prisma.PrismaPromise<GetSubjectsAggregateType<T>>

    /**
     * Group by Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectsGroupByArgs['orderBy'] }
        : { orderBy?: SubjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subjects model
   */
  readonly fields: SubjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Subjects$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Subjects$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class<T extends ClassesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassesDefaultArgs<ExtArgs>>): Prisma__ClassesClient<$Result.GetResult<Prisma.$ClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workHours<T extends Subjects$workHoursArgs<ExtArgs> = {}>(args?: Subset<T, Subjects$workHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subjects model
   */
  interface SubjectsFieldRefs {
    readonly id: FieldRef<"Subjects", 'Int'>
    readonly name: FieldRef<"Subjects", 'String'>
    readonly class_id: FieldRef<"Subjects", 'Int'>
    readonly school_year: FieldRef<"Subjects", 'String'>
    readonly coefficient: FieldRef<"Subjects", 'Int'>
    readonly supabase_id: FieldRef<"Subjects", 'String'>
    readonly last_modified: FieldRef<"Subjects", 'DateTime'>
    readonly needs_sync: FieldRef<"Subjects", 'Boolean'>
    readonly is_deleted: FieldRef<"Subjects", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Subjects findUnique
   */
  export type SubjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects findUniqueOrThrow
   */
  export type SubjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects findFirst
   */
  export type SubjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Subjects findFirstOrThrow
   */
  export type SubjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Subjects findMany
   */
  export type SubjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectsOrderByWithRelationInput | SubjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * Subjects create
   */
  export type SubjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a Subjects.
     */
    data: XOR<SubjectsCreateInput, SubjectsUncheckedCreateInput>
  }

  /**
   * Subjects createMany
   */
  export type SubjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectsCreateManyInput | SubjectsCreateManyInput[]
  }

  /**
   * Subjects createManyAndReturn
   */
  export type SubjectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectsCreateManyInput | SubjectsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subjects update
   */
  export type SubjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a Subjects.
     */
    data: XOR<SubjectsUpdateInput, SubjectsUncheckedUpdateInput>
    /**
     * Choose, which Subjects to update.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects updateMany
   */
  export type SubjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectsUpdateManyMutationInput, SubjectsUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectsWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subjects updateManyAndReturn
   */
  export type SubjectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectsUpdateManyMutationInput, SubjectsUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectsWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subjects upsert
   */
  export type SubjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the Subjects to update in case it exists.
     */
    where: SubjectsWhereUniqueInput
    /**
     * In case the Subjects found by the `where` argument doesn't exist, create a new Subjects with this data.
     */
    create: XOR<SubjectsCreateInput, SubjectsUncheckedCreateInput>
    /**
     * In case the Subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectsUpdateInput, SubjectsUncheckedUpdateInput>
  }

  /**
   * Subjects delete
   */
  export type SubjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
    /**
     * Filter which Subjects to delete.
     */
    where: SubjectsWhereUniqueInput
  }

  /**
   * Subjects deleteMany
   */
  export type SubjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectsWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subjects.lessons
   */
  export type Subjects$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lessons
     */
    select?: LessonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lessons
     */
    omit?: LessonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonsInclude<ExtArgs> | null
    where?: LessonsWhereInput
    orderBy?: LessonsOrderByWithRelationInput | LessonsOrderByWithRelationInput[]
    cursor?: LessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * Subjects.workHours
   */
  export type Subjects$workHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkHours
     */
    select?: TeacherWorkHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherWorkHours
     */
    omit?: TeacherWorkHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherWorkHoursInclude<ExtArgs> | null
    where?: TeacherWorkHoursWhereInput
    orderBy?: TeacherWorkHoursOrderByWithRelationInput | TeacherWorkHoursOrderByWithRelationInput[]
    cursor?: TeacherWorkHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherWorkHoursScalarFieldEnum | TeacherWorkHoursScalarFieldEnum[]
  }

  /**
   * Subjects without action
   */
  export type SubjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subjects
     */
    select?: SubjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subjects
     */
    omit?: SubjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectsInclude<ExtArgs> | null
  }


  /**
   * Model Notes
   */

  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    quarter: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    quarter: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    type: string | null
    quarter: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    lesson_id: number | null
    value: number | null
    type: string | null
    quarter: number | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    student_id: number
    lesson_id: number
    value: number
    type: number
    quarter: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    quarter?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    quarter?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    type?: true
    quarter?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    type?: true
    quarter?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    student_id?: true
    lesson_id?: true
    value?: true
    type?: true
    quarter?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type NotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to aggregate.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type NotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotesWhereInput
    orderBy?: NotesOrderByWithAggregationInput | NotesOrderByWithAggregationInput[]
    by: NotesScalarFieldEnum[] | NotesScalarFieldEnum
    having?: NotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }

  export type NotesGroupByOutputType = {
    id: number
    student_id: number
    lesson_id: number
    value: number | null
    type: string | null
    quarter: number | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends NotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type NotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type NotesSelectScalar = {
    id?: boolean
    student_id?: boolean
    lesson_id?: boolean
    value?: boolean
    type?: boolean
    quarter?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "lesson_id" | "value" | "type" | "quarter" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["notes"]>
  export type NotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type NotesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type NotesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $NotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notes"
    objects: {
      lesson: Prisma.$LessonsPayload<ExtArgs>
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      lesson_id: number
      value: number | null
      type: string | null
      quarter: number | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["notes"]>
    composites: {}
  }

  type NotesGetPayload<S extends boolean | null | undefined | NotesDefaultArgs> = $Result.GetResult<Prisma.$NotesPayload, S>

  type NotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface NotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notes'], meta: { name: 'Notes' } }
    /**
     * Find zero or one Notes that matches the filter.
     * @param {NotesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotesFindUniqueArgs>(args: SelectSubset<T, NotesFindUniqueArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotesFindUniqueOrThrowArgs>(args: SelectSubset<T, NotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotesFindFirstArgs>(args?: SelectSubset<T, NotesFindFirstArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotesFindFirstOrThrowArgs>(args?: SelectSubset<T, NotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotesFindManyArgs>(args?: SelectSubset<T, NotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notes.
     * @param {NotesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
     */
    create<T extends NotesCreateArgs>(args: SelectSubset<T, NotesCreateArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {NotesCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotesCreateManyArgs>(args?: SelectSubset<T, NotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NotesCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotesCreateManyAndReturnArgs>(args?: SelectSubset<T, NotesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notes.
     * @param {NotesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
     */
    delete<T extends NotesDeleteArgs>(args: SelectSubset<T, NotesDeleteArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notes.
     * @param {NotesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotesUpdateArgs>(args: SelectSubset<T, NotesUpdateArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {NotesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotesDeleteManyArgs>(args?: SelectSubset<T, NotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotesUpdateManyArgs>(args: SelectSubset<T, NotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {NotesUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotesUpdateManyAndReturnArgs>(args: SelectSubset<T, NotesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notes.
     * @param {NotesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
     */
    upsert<T extends NotesUpsertArgs>(args: SelectSubset<T, NotesUpsertArgs<ExtArgs>>): Prisma__NotesClient<$Result.GetResult<Prisma.$NotesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NotesCountArgs>(
      args?: Subset<T, NotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesGroupByArgs['orderBy'] }
        : { orderBy?: NotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notes model
   */
  readonly fields: NotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonsDefaultArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notes model
   */
  interface NotesFieldRefs {
    readonly id: FieldRef<"Notes", 'Int'>
    readonly student_id: FieldRef<"Notes", 'Int'>
    readonly lesson_id: FieldRef<"Notes", 'Int'>
    readonly value: FieldRef<"Notes", 'Float'>
    readonly type: FieldRef<"Notes", 'String'>
    readonly quarter: FieldRef<"Notes", 'Int'>
    readonly supabase_id: FieldRef<"Notes", 'String'>
    readonly last_modified: FieldRef<"Notes", 'DateTime'>
    readonly needs_sync: FieldRef<"Notes", 'Boolean'>
    readonly is_deleted: FieldRef<"Notes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notes findUnique
   */
  export type NotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes findUniqueOrThrow
   */
  export type NotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes findFirst
   */
  export type NotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes findFirstOrThrow
   */
  export type NotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes findMany
   */
  export type NotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NotesOrderByWithRelationInput | NotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * Notes create
   */
  export type NotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The data needed to create a Notes.
     */
    data: XOR<NotesCreateInput, NotesUncheckedCreateInput>
  }

  /**
   * Notes createMany
   */
  export type NotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NotesCreateManyInput | NotesCreateManyInput[]
  }

  /**
   * Notes createManyAndReturn
   */
  export type NotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NotesCreateManyInput | NotesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notes update
   */
  export type NotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The data needed to update a Notes.
     */
    data: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
    /**
     * Choose, which Notes to update.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes updateMany
   */
  export type NotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NotesWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Notes updateManyAndReturn
   */
  export type NotesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * The data used to update Notes.
     */
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NotesWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notes upsert
   */
  export type NotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * The filter to search for the Notes to update in case it exists.
     */
    where: NotesWhereUniqueInput
    /**
     * In case the Notes found by the `where` argument doesn't exist, create a new Notes with this data.
     */
    create: XOR<NotesCreateInput, NotesUncheckedCreateInput>
    /**
     * In case the Notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotesUpdateInput, NotesUncheckedUpdateInput>
  }

  /**
   * Notes delete
   */
  export type NotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
    /**
     * Filter which Notes to delete.
     */
    where: NotesWhereUniqueInput
  }

  /**
   * Notes deleteMany
   */
  export type NotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NotesWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Notes without action
   */
  export type NotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notes
     */
    select?: NotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notes
     */
    omit?: NotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotesInclude<ExtArgs> | null
  }


  /**
   * Model Parents
   */

  export type AggregateParents = {
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  export type ParentsAvgAggregateOutputType = {
    id: number | null
  }

  export type ParentsSumAggregateOutputType = {
    id: number | null
  }

  export type ParentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    profession: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    school_id: string | null
  }

  export type ParentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    profession: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
    school_id: string | null
  }

  export type ParentsCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    phone: number
    email: number
    adress: number
    gender: number
    profession: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    school_id: number
    _all: number
  }


  export type ParentsAvgAggregateInputType = {
    id?: true
  }

  export type ParentsSumAggregateInputType = {
    id?: true
  }

  export type ParentsMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    profession?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    school_id?: true
  }

  export type ParentsMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    profession?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    school_id?: true
  }

  export type ParentsCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    profession?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    school_id?: true
    _all?: true
  }

  export type ParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to aggregate.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentsMaxAggregateInputType
  }

  export type GetParentsAggregateType<T extends ParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParents[P]>
      : GetScalarType<T[P], AggregateParents[P]>
  }




  export type ParentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentsWhereInput
    orderBy?: ParentsOrderByWithAggregationInput | ParentsOrderByWithAggregationInput[]
    by: ParentsScalarFieldEnum[] | ParentsScalarFieldEnum
    having?: ParentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentsCountAggregateInputType | true
    _avg?: ParentsAvgAggregateInputType
    _sum?: ParentsSumAggregateInputType
    _min?: ParentsMinAggregateInputType
    _max?: ParentsMaxAggregateInputType
  }

  export type ParentsGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    profession: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    school_id: string | null
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  type GetParentsGroupByPayload<T extends ParentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentsGroupByOutputType[P]>
            : GetScalarType<T[P], ParentsGroupByOutputType[P]>
        }
      >
    >


  export type ParentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
    student_parents?: boolean | Parents$student_parentsArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>

  export type ParentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["parents"]>

  export type ParentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
  }, ExtArgs["result"]["parents"]>

  export type ParentsSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    profession?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: boolean
  }

  export type ParentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "phone" | "email" | "adress" | "gender" | "profession" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted" | "school_id", ExtArgs["result"]["parents"]>
  export type ParentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_parents?: boolean | Parents$student_parentsArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ParentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ParentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parents"
    objects: {
      student_parents: Prisma.$StudentParentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      phone: string | null
      email: string | null
      adress: string | null
      gender: string | null
      profession: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
      school_id: string | null
    }, ExtArgs["result"]["parents"]>
    composites: {}
  }

  type ParentsGetPayload<S extends boolean | null | undefined | ParentsDefaultArgs> = $Result.GetResult<Prisma.$ParentsPayload, S>

  type ParentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentsCountAggregateInputType | true
    }

  export interface ParentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parents'], meta: { name: 'Parents' } }
    /**
     * Find zero or one Parents that matches the filter.
     * @param {ParentsFindUniqueArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentsFindUniqueArgs>(args: SelectSubset<T, ParentsFindUniqueArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentsFindUniqueOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentsFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsFindFirstArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentsFindFirstArgs>(args?: SelectSubset<T, ParentsFindFirstArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsFindFirstOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentsFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parents.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentsWithIdOnly = await prisma.parents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentsFindManyArgs>(args?: SelectSubset<T, ParentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parents.
     * @param {ParentsCreateArgs} args - Arguments to create a Parents.
     * @example
     * // Create one Parents
     * const Parents = await prisma.parents.create({
     *   data: {
     *     // ... data to create a Parents
     *   }
     * })
     * 
     */
    create<T extends ParentsCreateArgs>(args: SelectSubset<T, ParentsCreateArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentsCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentsCreateManyArgs>(args?: SelectSubset<T, ParentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentsCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentsWithIdOnly = await prisma.parents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentsCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parents.
     * @param {ParentsDeleteArgs} args - Arguments to delete one Parents.
     * @example
     * // Delete one Parents
     * const Parents = await prisma.parents.delete({
     *   where: {
     *     // ... filter to delete one Parents
     *   }
     * })
     * 
     */
    delete<T extends ParentsDeleteArgs>(args: SelectSubset<T, ParentsDeleteArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parents.
     * @param {ParentsUpdateArgs} args - Arguments to update one Parents.
     * @example
     * // Update one Parents
     * const parents = await prisma.parents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentsUpdateArgs>(args: SelectSubset<T, ParentsUpdateArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentsDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentsDeleteManyArgs>(args?: SelectSubset<T, ParentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentsUpdateManyArgs>(args: SelectSubset<T, ParentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {ParentsUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `id`
     * const parentsWithIdOnly = await prisma.parents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentsUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parents.
     * @param {ParentsUpsertArgs} args - Arguments to update or create a Parents.
     * @example
     * // Update or create a Parents
     * const parents = await prisma.parents.upsert({
     *   create: {
     *     // ... data to create a Parents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parents we want to update
     *   }
     * })
     */
    upsert<T extends ParentsUpsertArgs>(args: SelectSubset<T, ParentsUpsertArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parents.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentsCountArgs>(
      args?: Subset<T, ParentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentsAggregateArgs>(args: Subset<T, ParentsAggregateArgs>): Prisma.PrismaPromise<GetParentsAggregateType<T>>

    /**
     * Group by Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentsGroupByArgs['orderBy'] }
        : { orderBy?: ParentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parents model
   */
  readonly fields: ParentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student_parents<T extends Parents$student_parentsArgs<ExtArgs> = {}>(args?: Subset<T, Parents$student_parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parents model
   */
  interface ParentsFieldRefs {
    readonly id: FieldRef<"Parents", 'Int'>
    readonly name: FieldRef<"Parents", 'String'>
    readonly first_name: FieldRef<"Parents", 'String'>
    readonly phone: FieldRef<"Parents", 'String'>
    readonly email: FieldRef<"Parents", 'String'>
    readonly adress: FieldRef<"Parents", 'String'>
    readonly gender: FieldRef<"Parents", 'String'>
    readonly profession: FieldRef<"Parents", 'String'>
    readonly supabase_id: FieldRef<"Parents", 'String'>
    readonly last_modified: FieldRef<"Parents", 'DateTime'>
    readonly needs_sync: FieldRef<"Parents", 'Boolean'>
    readonly is_deleted: FieldRef<"Parents", 'Boolean'>
    readonly school_id: FieldRef<"Parents", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parents findUnique
   */
  export type ParentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents findUniqueOrThrow
   */
  export type ParentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents findFirst
   */
  export type ParentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * Parents findFirstOrThrow
   */
  export type ParentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * Parents findMany
   */
  export type ParentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentsOrderByWithRelationInput | ParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * Parents create
   */
  export type ParentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Parents.
     */
    data?: XOR<ParentsCreateInput, ParentsUncheckedCreateInput>
  }

  /**
   * Parents createMany
   */
  export type ParentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentsCreateManyInput | ParentsCreateManyInput[]
  }

  /**
   * Parents createManyAndReturn
   */
  export type ParentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentsCreateManyInput | ParentsCreateManyInput[]
  }

  /**
   * Parents update
   */
  export type ParentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Parents.
     */
    data: XOR<ParentsUpdateInput, ParentsUncheckedUpdateInput>
    /**
     * Choose, which Parents to update.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents updateMany
   */
  export type ParentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentsUpdateManyMutationInput, ParentsUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentsWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parents updateManyAndReturn
   */
  export type ParentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentsUpdateManyMutationInput, ParentsUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentsWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parents upsert
   */
  export type ParentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Parents to update in case it exists.
     */
    where: ParentsWhereUniqueInput
    /**
     * In case the Parents found by the `where` argument doesn't exist, create a new Parents with this data.
     */
    create: XOR<ParentsCreateInput, ParentsUncheckedCreateInput>
    /**
     * In case the Parents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentsUpdateInput, ParentsUncheckedUpdateInput>
  }

  /**
   * Parents delete
   */
  export type ParentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
    /**
     * Filter which Parents to delete.
     */
    where: ParentsWhereUniqueInput
  }

  /**
   * Parents deleteMany
   */
  export type ParentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentsWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parents.student_parents
   */
  export type Parents$student_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    where?: StudentParentsWhereInput
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    cursor?: StudentParentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * Parents without action
   */
  export type ParentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parents
     */
    select?: ParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parents
     */
    omit?: ParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentsInclude<ExtArgs> | null
  }


  /**
   * Model StudentParents
   */

  export type AggregateStudentParents = {
    _count: StudentParentsCountAggregateOutputType | null
    _avg: StudentParentsAvgAggregateOutputType | null
    _sum: StudentParentsSumAggregateOutputType | null
    _min: StudentParentsMinAggregateOutputType | null
    _max: StudentParentsMaxAggregateOutputType | null
  }

  export type StudentParentsAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
  }

  export type StudentParentsSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
  }

  export type StudentParentsMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
    relation: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type StudentParentsMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    parent_id: number | null
    relation: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type StudentParentsCountAggregateOutputType = {
    id: number
    student_id: number
    parent_id: number
    relation: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type StudentParentsAvgAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
  }

  export type StudentParentsSumAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
  }

  export type StudentParentsMinAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
    relation?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type StudentParentsMaxAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
    relation?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type StudentParentsCountAggregateInputType = {
    id?: true
    student_id?: true
    parent_id?: true
    relation?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type StudentParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to aggregate.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParents
    **/
    _count?: true | StudentParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentParentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentParentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentsMaxAggregateInputType
  }

  export type GetStudentParentsAggregateType<T extends StudentParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParents[P]>
      : GetScalarType<T[P], AggregateStudentParents[P]>
  }




  export type StudentParentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentsWhereInput
    orderBy?: StudentParentsOrderByWithAggregationInput | StudentParentsOrderByWithAggregationInput[]
    by: StudentParentsScalarFieldEnum[] | StudentParentsScalarFieldEnum
    having?: StudentParentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentsCountAggregateInputType | true
    _avg?: StudentParentsAvgAggregateInputType
    _sum?: StudentParentsSumAggregateInputType
    _min?: StudentParentsMinAggregateInputType
    _max?: StudentParentsMaxAggregateInputType
  }

  export type StudentParentsGroupByOutputType = {
    id: number
    student_id: number
    parent_id: number
    relation: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: StudentParentsCountAggregateOutputType | null
    _avg: StudentParentsAvgAggregateOutputType | null
    _sum: StudentParentsSumAggregateOutputType | null
    _min: StudentParentsMinAggregateOutputType | null
    _max: StudentParentsMaxAggregateOutputType | null
  }

  type GetStudentParentsGroupByPayload<T extends StudentParentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParents"]>

  export type StudentParentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParents"]>

  export type StudentParentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParents"]>

  export type StudentParentsSelectScalar = {
    id?: boolean
    student_id?: boolean
    parent_id?: boolean
    relation?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "parent_id" | "relation" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["studentParents"]>
  export type StudentParentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type StudentParentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type StudentParentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentsDefaultArgs<ExtArgs>
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $StudentParentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentParents"
    objects: {
      parent: Prisma.$ParentsPayload<ExtArgs>
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      parent_id: number
      relation: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["studentParents"]>
    composites: {}
  }

  type StudentParentsGetPayload<S extends boolean | null | undefined | StudentParentsDefaultArgs> = $Result.GetResult<Prisma.$StudentParentsPayload, S>

  type StudentParentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentParentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentParentsCountAggregateInputType | true
    }

  export interface StudentParentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentParents'], meta: { name: 'StudentParents' } }
    /**
     * Find zero or one StudentParents that matches the filter.
     * @param {StudentParentsFindUniqueArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentParentsFindUniqueArgs>(args: SelectSubset<T, StudentParentsFindUniqueArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentParents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentParentsFindUniqueOrThrowArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentParentsFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentParentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindFirstArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentParentsFindFirstArgs>(args?: SelectSubset<T, StudentParentsFindFirstArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindFirstOrThrowArgs} args - Arguments to find a StudentParents
     * @example
     * // Get one StudentParents
     * const studentParents = await prisma.studentParents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentParentsFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentParentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParents
     * const studentParents = await prisma.studentParents.findMany()
     * 
     * // Get first 10 StudentParents
     * const studentParents = await prisma.studentParents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentParentsWithIdOnly = await prisma.studentParents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentParentsFindManyArgs>(args?: SelectSubset<T, StudentParentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentParents.
     * @param {StudentParentsCreateArgs} args - Arguments to create a StudentParents.
     * @example
     * // Create one StudentParents
     * const StudentParents = await prisma.studentParents.create({
     *   data: {
     *     // ... data to create a StudentParents
     *   }
     * })
     * 
     */
    create<T extends StudentParentsCreateArgs>(args: SelectSubset<T, StudentParentsCreateArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentParents.
     * @param {StudentParentsCreateManyArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParents = await prisma.studentParents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentParentsCreateManyArgs>(args?: SelectSubset<T, StudentParentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentParents and returns the data saved in the database.
     * @param {StudentParentsCreateManyAndReturnArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParents = await prisma.studentParents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentParents and only return the `id`
     * const studentParentsWithIdOnly = await prisma.studentParents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentParentsCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentParentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentParents.
     * @param {StudentParentsDeleteArgs} args - Arguments to delete one StudentParents.
     * @example
     * // Delete one StudentParents
     * const StudentParents = await prisma.studentParents.delete({
     *   where: {
     *     // ... filter to delete one StudentParents
     *   }
     * })
     * 
     */
    delete<T extends StudentParentsDeleteArgs>(args: SelectSubset<T, StudentParentsDeleteArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentParents.
     * @param {StudentParentsUpdateArgs} args - Arguments to update one StudentParents.
     * @example
     * // Update one StudentParents
     * const studentParents = await prisma.studentParents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentParentsUpdateArgs>(args: SelectSubset<T, StudentParentsUpdateArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentParents.
     * @param {StudentParentsDeleteManyArgs} args - Arguments to filter StudentParents to delete.
     * @example
     * // Delete a few StudentParents
     * const { count } = await prisma.studentParents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentParentsDeleteManyArgs>(args?: SelectSubset<T, StudentParentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParents
     * const studentParents = await prisma.studentParents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentParentsUpdateManyArgs>(args: SelectSubset<T, StudentParentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents and returns the data updated in the database.
     * @param {StudentParentsUpdateManyAndReturnArgs} args - Arguments to update many StudentParents.
     * @example
     * // Update many StudentParents
     * const studentParents = await prisma.studentParents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentParents and only return the `id`
     * const studentParentsWithIdOnly = await prisma.studentParents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentParentsUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentParentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentParents.
     * @param {StudentParentsUpsertArgs} args - Arguments to update or create a StudentParents.
     * @example
     * // Update or create a StudentParents
     * const studentParents = await prisma.studentParents.upsert({
     *   create: {
     *     // ... data to create a StudentParents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParents we want to update
     *   }
     * })
     */
    upsert<T extends StudentParentsUpsertArgs>(args: SelectSubset<T, StudentParentsUpsertArgs<ExtArgs>>): Prisma__StudentParentsClient<$Result.GetResult<Prisma.$StudentParentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsCountArgs} args - Arguments to filter StudentParents to count.
     * @example
     * // Count the number of StudentParents
     * const count = await prisma.studentParents.count({
     *   where: {
     *     // ... the filter for the StudentParents we want to count
     *   }
     * })
    **/
    count<T extends StudentParentsCountArgs>(
      args?: Subset<T, StudentParentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentsAggregateArgs>(args: Subset<T, StudentParentsAggregateArgs>): Prisma.PrismaPromise<GetStudentParentsAggregateType<T>>

    /**
     * Group by StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentParents model
   */
  readonly fields: StudentParentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentParentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ParentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentsDefaultArgs<ExtArgs>>): Prisma__ParentsClient<$Result.GetResult<Prisma.$ParentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentParents model
   */
  interface StudentParentsFieldRefs {
    readonly id: FieldRef<"StudentParents", 'Int'>
    readonly student_id: FieldRef<"StudentParents", 'Int'>
    readonly parent_id: FieldRef<"StudentParents", 'Int'>
    readonly relation: FieldRef<"StudentParents", 'String'>
    readonly supabase_id: FieldRef<"StudentParents", 'String'>
    readonly last_modified: FieldRef<"StudentParents", 'DateTime'>
    readonly needs_sync: FieldRef<"StudentParents", 'Boolean'>
    readonly is_deleted: FieldRef<"StudentParents", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StudentParents findUnique
   */
  export type StudentParentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents findUniqueOrThrow
   */
  export type StudentParentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents findFirst
   */
  export type StudentParentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * StudentParents findFirstOrThrow
   */
  export type StudentParentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * StudentParents findMany
   */
  export type StudentParentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentsOrderByWithRelationInput | StudentParentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParents.
     */
    cursor?: StudentParentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    distinct?: StudentParentsScalarFieldEnum | StudentParentsScalarFieldEnum[]
  }

  /**
   * StudentParents create
   */
  export type StudentParentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentParents.
     */
    data: XOR<StudentParentsCreateInput, StudentParentsUncheckedCreateInput>
  }

  /**
   * StudentParents createMany
   */
  export type StudentParentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentsCreateManyInput | StudentParentsCreateManyInput[]
  }

  /**
   * StudentParents createManyAndReturn
   */
  export type StudentParentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentsCreateManyInput | StudentParentsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParents update
   */
  export type StudentParentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentParents.
     */
    data: XOR<StudentParentsUpdateInput, StudentParentsUncheckedUpdateInput>
    /**
     * Choose, which StudentParents to update.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents updateMany
   */
  export type StudentParentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentsWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
  }

  /**
   * StudentParents updateManyAndReturn
   */
  export type StudentParentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentsWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParents upsert
   */
  export type StudentParentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentParents to update in case it exists.
     */
    where: StudentParentsWhereUniqueInput
    /**
     * In case the StudentParents found by the `where` argument doesn't exist, create a new StudentParents with this data.
     */
    create: XOR<StudentParentsCreateInput, StudentParentsUncheckedCreateInput>
    /**
     * In case the StudentParents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentsUpdateInput, StudentParentsUncheckedUpdateInput>
  }

  /**
   * StudentParents delete
   */
  export type StudentParentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
    /**
     * Filter which StudentParents to delete.
     */
    where: StudentParentsWhereUniqueInput
  }

  /**
   * StudentParents deleteMany
   */
  export type StudentParentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to delete
     */
    where?: StudentParentsWhereInput
    /**
     * Limit how many StudentParents to delete.
     */
    limit?: number
  }

  /**
   * StudentParents without action
   */
  export type StudentParentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParents
     */
    select?: StudentParentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParents
     */
    omit?: StudentParentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentsInclude<ExtArgs> | null
  }


  /**
   * Model Payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    registration_id: number | null
    fee_id: number | null
    amount: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    registration_id: number | null
    fee_id: number | null
    amount: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    registration_id: number | null
    fee_id: number | null
    amount: number | null
    method: string | null
    date: string | null
    reference: string | null
    emitter_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    registration_id: number | null
    fee_id: number | null
    amount: number | null
    method: string | null
    date: string | null
    reference: string | null
    emitter_id: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    registration_id: number
    fee_id: number
    amount: number
    method: number
    date: number
    reference: number
    emitter_id: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    registration_id?: true
    fee_id?: true
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    registration_id?: true
    fee_id?: true
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    registration_id?: true
    fee_id?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    emitter_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    registration_id?: true
    fee_id?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    emitter_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    registration_id?: true
    fee_id?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    emitter_id?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to aggregate.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithAggregationInput | PaymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    registration_id: number | null
    fee_id: number | null
    amount: number | null
    method: string | null
    date: string | null
    reference: string | null
    emitter_id: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_id?: boolean
    fee_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    fee?: boolean | Payments$feeArgs<ExtArgs>
    registration?: boolean | Payments$registrationArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_id?: boolean
    fee_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    fee?: boolean | Payments$feeArgs<ExtArgs>
    registration?: boolean | Payments$registrationArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_id?: boolean
    fee_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    fee?: boolean | Payments$feeArgs<ExtArgs>
    registration?: boolean | Payments$registrationArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectScalar = {
    id?: boolean
    registration_id?: boolean
    fee_id?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    emitter_id?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "registration_id" | "fee_id" | "amount" | "method" | "date" | "reference" | "emitter_id" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["payments"]>
  export type PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | Payments$feeArgs<ExtArgs>
    registration?: boolean | Payments$registrationArgs<ExtArgs>
  }
  export type PaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | Payments$feeArgs<ExtArgs>
    registration?: boolean | Payments$registrationArgs<ExtArgs>
  }
  export type PaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | Payments$feeArgs<ExtArgs>
    registration?: boolean | Payments$registrationArgs<ExtArgs>
  }

  export type $PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payments"
    objects: {
      fee: Prisma.$FeesPayload<ExtArgs> | null
      registration: Prisma.$RegistrationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      registration_id: number | null
      fee_id: number | null
      amount: number | null
      method: string | null
      date: string | null
      reference: string | null
      emitter_id: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type PaymentsGetPayload<S extends boolean | null | undefined | PaymentsDefaultArgs> = $Result.GetResult<Prisma.$PaymentsPayload, S>

  type PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payments'], meta: { name: 'Payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {PaymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentsFindUniqueArgs>(args: SelectSubset<T, PaymentsFindUniqueArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentsFindFirstArgs>(args?: SelectSubset<T, PaymentsFindFirstArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentsFindManyArgs>(args?: SelectSubset<T, PaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {PaymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends PaymentsCreateArgs>(args: SelectSubset<T, PaymentsCreateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentsCreateManyArgs>(args?: SelectSubset<T, PaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {PaymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends PaymentsDeleteArgs>(args: SelectSubset<T, PaymentsDeleteArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {PaymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentsUpdateArgs>(args: SelectSubset<T, PaymentsUpdateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentsDeleteManyArgs>(args?: SelectSubset<T, PaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentsUpdateManyArgs>(args: SelectSubset<T, PaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {PaymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends PaymentsUpsertArgs>(args: SelectSubset<T, PaymentsUpsertArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentsCountArgs>(
      args?: Subset<T, PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payments model
   */
  readonly fields: PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fee<T extends Payments$feeArgs<ExtArgs> = {}>(args?: Subset<T, Payments$feeArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    registration<T extends Payments$registrationArgs<ExtArgs> = {}>(args?: Subset<T, Payments$registrationArgs<ExtArgs>>): Prisma__RegistrationsClient<$Result.GetResult<Prisma.$RegistrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payments model
   */
  interface PaymentsFieldRefs {
    readonly id: FieldRef<"Payments", 'Int'>
    readonly registration_id: FieldRef<"Payments", 'Int'>
    readonly fee_id: FieldRef<"Payments", 'Int'>
    readonly amount: FieldRef<"Payments", 'Float'>
    readonly method: FieldRef<"Payments", 'String'>
    readonly date: FieldRef<"Payments", 'String'>
    readonly reference: FieldRef<"Payments", 'String'>
    readonly emitter_id: FieldRef<"Payments", 'String'>
    readonly supabase_id: FieldRef<"Payments", 'String'>
    readonly last_modified: FieldRef<"Payments", 'DateTime'>
    readonly needs_sync: FieldRef<"Payments", 'Boolean'>
    readonly is_deleted: FieldRef<"Payments", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Payments findUnique
   */
  export type PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findUniqueOrThrow
   */
  export type PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findFirst
   */
  export type PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findFirstOrThrow
   */
  export type PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findMany
   */
  export type PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments create
   */
  export type PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Payments.
     */
    data?: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
  }

  /**
   * Payments createMany
   */
  export type PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
  }

  /**
   * Payments createManyAndReturn
   */
  export type PaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments update
   */
  export type PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Payments.
     */
    data: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Payments to update.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments updateMany
   */
  export type PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payments updateManyAndReturn
   */
  export type PaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments upsert
   */
  export type PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Payments to update in case it exists.
     */
    where: PaymentsWhereUniqueInput
    /**
     * In case the Payments found by the `where` argument doesn't exist, create a new Payments with this data.
     */
    create: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
    /**
     * In case the Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
  }

  /**
   * Payments delete
   */
  export type PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Payments to delete.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments deleteMany
   */
  export type PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payments.fee
   */
  export type Payments$feeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    where?: FeesWhereInput
  }

  /**
   * Payments.registration
   */
  export type Payments$registrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Registrations
     */
    select?: RegistrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Registrations
     */
    omit?: RegistrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistrationsInclude<ExtArgs> | null
    where?: RegistrationsWhereInput
  }

  /**
   * Payments without action
   */
  export type PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model Fees
   */

  export type AggregateFees = {
    _count: FeesCountAggregateOutputType | null
    _avg: FeesAvgAggregateOutputType | null
    _sum: FeesSumAggregateOutputType | null
    _min: FeesMinAggregateOutputType | null
    _max: FeesMaxAggregateOutputType | null
  }

  export type FeesAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type FeesSumAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type FeesMinAggregateOutputType = {
    id: number | null
    name: string | null
    amount: number | null
    due_date: string | null
    school_year: string | null
    level: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FeesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    amount: number | null
    due_date: string | null
    school_year: string | null
    level: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type FeesCountAggregateOutputType = {
    id: number
    name: number
    amount: number
    due_date: number
    school_year: number
    level: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type FeesAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type FeesSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type FeesMinAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    due_date?: true
    school_year?: true
    level?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FeesMaxAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    due_date?: true
    school_year?: true
    level?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type FeesCountAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    due_date?: true
    school_year?: true
    level?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type FeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fees to aggregate.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fees
    **/
    _count?: true | FeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeesMaxAggregateInputType
  }

  export type GetFeesAggregateType<T extends FeesAggregateArgs> = {
        [P in keyof T & keyof AggregateFees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFees[P]>
      : GetScalarType<T[P], AggregateFees[P]>
  }




  export type FeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeesWhereInput
    orderBy?: FeesOrderByWithAggregationInput | FeesOrderByWithAggregationInput[]
    by: FeesScalarFieldEnum[] | FeesScalarFieldEnum
    having?: FeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeesCountAggregateInputType | true
    _avg?: FeesAvgAggregateInputType
    _sum?: FeesSumAggregateInputType
    _min?: FeesMinAggregateInputType
    _max?: FeesMaxAggregateInputType
  }

  export type FeesGroupByOutputType = {
    id: number
    name: string | null
    amount: number | null
    due_date: string | null
    school_year: string | null
    level: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: FeesCountAggregateOutputType | null
    _avg: FeesAvgAggregateOutputType | null
    _sum: FeesSumAggregateOutputType | null
    _min: FeesMinAggregateOutputType | null
    _max: FeesMaxAggregateOutputType | null
  }

  type GetFeesGroupByPayload<T extends FeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeesGroupByOutputType[P]>
            : GetScalarType<T[P], FeesGroupByOutputType[P]>
        }
      >
    >


  export type FeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: boolean | Fees$paymentsArgs<ExtArgs>
    _count?: boolean | FeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fees"]>

  export type FeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["fees"]>

  export type FeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["fees"]>

  export type FeesSelectScalar = {
    id?: boolean
    name?: boolean
    amount?: boolean
    due_date?: boolean
    school_year?: boolean
    level?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "amount" | "due_date" | "school_year" | "level" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["fees"]>
  export type FeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Fees$paymentsArgs<ExtArgs>
    _count?: boolean | FeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fees"
    objects: {
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      amount: number | null
      due_date: string | null
      school_year: string | null
      level: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["fees"]>
    composites: {}
  }

  type FeesGetPayload<S extends boolean | null | undefined | FeesDefaultArgs> = $Result.GetResult<Prisma.$FeesPayload, S>

  type FeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeesCountAggregateInputType | true
    }

  export interface FeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fees'], meta: { name: 'Fees' } }
    /**
     * Find zero or one Fees that matches the filter.
     * @param {FeesFindUniqueArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeesFindUniqueArgs>(args: SelectSubset<T, FeesFindUniqueArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeesFindUniqueOrThrowArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeesFindUniqueOrThrowArgs>(args: SelectSubset<T, FeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindFirstArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeesFindFirstArgs>(args?: SelectSubset<T, FeesFindFirstArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindFirstOrThrowArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeesFindFirstOrThrowArgs>(args?: SelectSubset<T, FeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fees
     * const fees = await prisma.fees.findMany()
     * 
     * // Get first 10 Fees
     * const fees = await prisma.fees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feesWithIdOnly = await prisma.fees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeesFindManyArgs>(args?: SelectSubset<T, FeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fees.
     * @param {FeesCreateArgs} args - Arguments to create a Fees.
     * @example
     * // Create one Fees
     * const Fees = await prisma.fees.create({
     *   data: {
     *     // ... data to create a Fees
     *   }
     * })
     * 
     */
    create<T extends FeesCreateArgs>(args: SelectSubset<T, FeesCreateArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fees.
     * @param {FeesCreateManyArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fees = await prisma.fees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeesCreateManyArgs>(args?: SelectSubset<T, FeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fees and returns the data saved in the database.
     * @param {FeesCreateManyAndReturnArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fees = await prisma.fees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fees and only return the `id`
     * const feesWithIdOnly = await prisma.fees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeesCreateManyAndReturnArgs>(args?: SelectSubset<T, FeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fees.
     * @param {FeesDeleteArgs} args - Arguments to delete one Fees.
     * @example
     * // Delete one Fees
     * const Fees = await prisma.fees.delete({
     *   where: {
     *     // ... filter to delete one Fees
     *   }
     * })
     * 
     */
    delete<T extends FeesDeleteArgs>(args: SelectSubset<T, FeesDeleteArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fees.
     * @param {FeesUpdateArgs} args - Arguments to update one Fees.
     * @example
     * // Update one Fees
     * const fees = await prisma.fees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeesUpdateArgs>(args: SelectSubset<T, FeesUpdateArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fees.
     * @param {FeesDeleteManyArgs} args - Arguments to filter Fees to delete.
     * @example
     * // Delete a few Fees
     * const { count } = await prisma.fees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeesDeleteManyArgs>(args?: SelectSubset<T, FeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fees
     * const fees = await prisma.fees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeesUpdateManyArgs>(args: SelectSubset<T, FeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees and returns the data updated in the database.
     * @param {FeesUpdateManyAndReturnArgs} args - Arguments to update many Fees.
     * @example
     * // Update many Fees
     * const fees = await prisma.fees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fees and only return the `id`
     * const feesWithIdOnly = await prisma.fees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeesUpdateManyAndReturnArgs>(args: SelectSubset<T, FeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fees.
     * @param {FeesUpsertArgs} args - Arguments to update or create a Fees.
     * @example
     * // Update or create a Fees
     * const fees = await prisma.fees.upsert({
     *   create: {
     *     // ... data to create a Fees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fees we want to update
     *   }
     * })
     */
    upsert<T extends FeesUpsertArgs>(args: SelectSubset<T, FeesUpsertArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesCountArgs} args - Arguments to filter Fees to count.
     * @example
     * // Count the number of Fees
     * const count = await prisma.fees.count({
     *   where: {
     *     // ... the filter for the Fees we want to count
     *   }
     * })
    **/
    count<T extends FeesCountArgs>(
      args?: Subset<T, FeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeesAggregateArgs>(args: Subset<T, FeesAggregateArgs>): Prisma.PrismaPromise<GetFeesAggregateType<T>>

    /**
     * Group by Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeesGroupByArgs['orderBy'] }
        : { orderBy?: FeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fees model
   */
  readonly fields: FeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends Fees$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Fees$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fees model
   */
  interface FeesFieldRefs {
    readonly id: FieldRef<"Fees", 'Int'>
    readonly name: FieldRef<"Fees", 'String'>
    readonly amount: FieldRef<"Fees", 'Float'>
    readonly due_date: FieldRef<"Fees", 'String'>
    readonly school_year: FieldRef<"Fees", 'String'>
    readonly level: FieldRef<"Fees", 'String'>
    readonly supabase_id: FieldRef<"Fees", 'String'>
    readonly last_modified: FieldRef<"Fees", 'DateTime'>
    readonly needs_sync: FieldRef<"Fees", 'Boolean'>
    readonly is_deleted: FieldRef<"Fees", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Fees findUnique
   */
  export type FeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees findUniqueOrThrow
   */
  export type FeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees findFirst
   */
  export type FeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Fees findFirstOrThrow
   */
  export type FeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Fees findMany
   */
  export type FeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fees.
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Fees create
   */
  export type FeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * The data needed to create a Fees.
     */
    data?: XOR<FeesCreateInput, FeesUncheckedCreateInput>
  }

  /**
   * Fees createMany
   */
  export type FeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fees.
     */
    data: FeesCreateManyInput | FeesCreateManyInput[]
  }

  /**
   * Fees createManyAndReturn
   */
  export type FeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * The data used to create many Fees.
     */
    data: FeesCreateManyInput | FeesCreateManyInput[]
  }

  /**
   * Fees update
   */
  export type FeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * The data needed to update a Fees.
     */
    data: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>
    /**
     * Choose, which Fees to update.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees updateMany
   */
  export type FeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fees.
     */
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeesWhereInput
    /**
     * Limit how many Fees to update.
     */
    limit?: number
  }

  /**
   * Fees updateManyAndReturn
   */
  export type FeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * The data used to update Fees.
     */
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeesWhereInput
    /**
     * Limit how many Fees to update.
     */
    limit?: number
  }

  /**
   * Fees upsert
   */
  export type FeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * The filter to search for the Fees to update in case it exists.
     */
    where: FeesWhereUniqueInput
    /**
     * In case the Fees found by the `where` argument doesn't exist, create a new Fees with this data.
     */
    create: XOR<FeesCreateInput, FeesUncheckedCreateInput>
    /**
     * In case the Fees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>
  }

  /**
   * Fees delete
   */
  export type FeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter which Fees to delete.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees deleteMany
   */
  export type FeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fees to delete
     */
    where?: FeesWhereInput
    /**
     * Limit how many Fees to delete.
     */
    limit?: number
  }

  /**
   * Fees.payments
   */
  export type Fees$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Fees without action
   */
  export type FeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
  }


  /**
   * Model Attendances
   */

  export type AggregateAttendances = {
    _count: AttendancesCountAggregateOutputType | null
    _avg: AttendancesAvgAggregateOutputType | null
    _sum: AttendancesSumAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  export type AttendancesAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
  }

  export type AttendancesSumAggregateOutputType = {
    id: number | null
    student_id: number | null
  }

  export type AttendancesMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    date: string | null
    state: string | null
    justification: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type AttendancesMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    date: string | null
    state: string | null
    justification: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type AttendancesCountAggregateOutputType = {
    id: number
    student_id: number
    date: number
    state: number
    justification: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type AttendancesAvgAggregateInputType = {
    id?: true
    student_id?: true
  }

  export type AttendancesSumAggregateInputType = {
    id?: true
    student_id?: true
  }

  export type AttendancesMinAggregateInputType = {
    id?: true
    student_id?: true
    date?: true
    state?: true
    justification?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type AttendancesMaxAggregateInputType = {
    id?: true
    student_id?: true
    date?: true
    state?: true
    justification?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type AttendancesCountAggregateInputType = {
    id?: true
    student_id?: true
    date?: true
    state?: true
    justification?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type AttendancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to aggregate.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendancesMaxAggregateInputType
  }

  export type GetAttendancesAggregateType<T extends AttendancesAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendances[P]>
      : GetScalarType<T[P], AggregateAttendances[P]>
  }




  export type AttendancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendancesWhereInput
    orderBy?: AttendancesOrderByWithAggregationInput | AttendancesOrderByWithAggregationInput[]
    by: AttendancesScalarFieldEnum[] | AttendancesScalarFieldEnum
    having?: AttendancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendancesCountAggregateInputType | true
    _avg?: AttendancesAvgAggregateInputType
    _sum?: AttendancesSumAggregateInputType
    _min?: AttendancesMinAggregateInputType
    _max?: AttendancesMaxAggregateInputType
  }

  export type AttendancesGroupByOutputType = {
    id: number
    student_id: number
    date: string | null
    state: string | null
    justification: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: AttendancesCountAggregateOutputType | null
    _avg: AttendancesAvgAggregateOutputType | null
    _sum: AttendancesSumAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  type GetAttendancesGroupByPayload<T extends AttendancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
            : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
        }
      >
    >


  export type AttendancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type AttendancesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type AttendancesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type AttendancesSelectScalar = {
    id?: boolean
    student_id?: boolean
    date?: boolean
    state?: boolean
    justification?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "date" | "state" | "justification" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["attendances"]>
  export type AttendancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type AttendancesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type AttendancesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $AttendancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendances"
    objects: {
      student: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      date: string | null
      state: string | null
      justification: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["attendances"]>
    composites: {}
  }

  type AttendancesGetPayload<S extends boolean | null | undefined | AttendancesDefaultArgs> = $Result.GetResult<Prisma.$AttendancesPayload, S>

  type AttendancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendancesCountAggregateInputType | true
    }

  export interface AttendancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendances'], meta: { name: 'Attendances' } }
    /**
     * Find zero or one Attendances that matches the filter.
     * @param {AttendancesFindUniqueArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendancesFindUniqueArgs>(args: SelectSubset<T, AttendancesFindUniqueArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendancesFindUniqueOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendancesFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesFindFirstArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendancesFindFirstArgs>(args?: SelectSubset<T, AttendancesFindFirstArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesFindFirstOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendancesFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendances.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendancesWithIdOnly = await prisma.attendances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendancesFindManyArgs>(args?: SelectSubset<T, AttendancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendances.
     * @param {AttendancesCreateArgs} args - Arguments to create a Attendances.
     * @example
     * // Create one Attendances
     * const Attendances = await prisma.attendances.create({
     *   data: {
     *     // ... data to create a Attendances
     *   }
     * })
     * 
     */
    create<T extends AttendancesCreateArgs>(args: SelectSubset<T, AttendancesCreateArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendancesCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendances = await prisma.attendances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendancesCreateManyArgs>(args?: SelectSubset<T, AttendancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendancesCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendances = await prisma.attendances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendancesWithIdOnly = await prisma.attendances.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendancesCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendancesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendances.
     * @param {AttendancesDeleteArgs} args - Arguments to delete one Attendances.
     * @example
     * // Delete one Attendances
     * const Attendances = await prisma.attendances.delete({
     *   where: {
     *     // ... filter to delete one Attendances
     *   }
     * })
     * 
     */
    delete<T extends AttendancesDeleteArgs>(args: SelectSubset<T, AttendancesDeleteArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendances.
     * @param {AttendancesUpdateArgs} args - Arguments to update one Attendances.
     * @example
     * // Update one Attendances
     * const attendances = await prisma.attendances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendancesUpdateArgs>(args: SelectSubset<T, AttendancesUpdateArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendancesDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendancesDeleteManyArgs>(args?: SelectSubset<T, AttendancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendances = await prisma.attendances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendancesUpdateManyArgs>(args: SelectSubset<T, AttendancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendancesUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendances = await prisma.attendances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendancesWithIdOnly = await prisma.attendances.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendancesUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendancesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendances.
     * @param {AttendancesUpsertArgs} args - Arguments to update or create a Attendances.
     * @example
     * // Update or create a Attendances
     * const attendances = await prisma.attendances.upsert({
     *   create: {
     *     // ... data to create a Attendances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendances we want to update
     *   }
     * })
     */
    upsert<T extends AttendancesUpsertArgs>(args: SelectSubset<T, AttendancesUpsertArgs<ExtArgs>>): Prisma__AttendancesClient<$Result.GetResult<Prisma.$AttendancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendances.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendancesCountArgs>(
      args?: Subset<T, AttendancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendancesAggregateArgs>(args: Subset<T, AttendancesAggregateArgs>): Prisma.PrismaPromise<GetAttendancesAggregateType<T>>

    /**
     * Group by Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendancesGroupByArgs['orderBy'] }
        : { orderBy?: AttendancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendances model
   */
  readonly fields: AttendancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendances model
   */
  interface AttendancesFieldRefs {
    readonly id: FieldRef<"Attendances", 'Int'>
    readonly student_id: FieldRef<"Attendances", 'Int'>
    readonly date: FieldRef<"Attendances", 'String'>
    readonly state: FieldRef<"Attendances", 'String'>
    readonly justification: FieldRef<"Attendances", 'String'>
    readonly supabase_id: FieldRef<"Attendances", 'String'>
    readonly last_modified: FieldRef<"Attendances", 'DateTime'>
    readonly needs_sync: FieldRef<"Attendances", 'Boolean'>
    readonly is_deleted: FieldRef<"Attendances", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Attendances findUnique
   */
  export type AttendancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances findUniqueOrThrow
   */
  export type AttendancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances findFirst
   */
  export type AttendancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Attendances findFirstOrThrow
   */
  export type AttendancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Attendances findMany
   */
  export type AttendancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendancesOrderByWithRelationInput | AttendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * Attendances create
   */
  export type AttendancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendances.
     */
    data: XOR<AttendancesCreateInput, AttendancesUncheckedCreateInput>
  }

  /**
   * Attendances createMany
   */
  export type AttendancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendancesCreateManyInput | AttendancesCreateManyInput[]
  }

  /**
   * Attendances createManyAndReturn
   */
  export type AttendancesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendancesCreateManyInput | AttendancesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendances update
   */
  export type AttendancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendances.
     */
    data: XOR<AttendancesUpdateInput, AttendancesUncheckedUpdateInput>
    /**
     * Choose, which Attendances to update.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances updateMany
   */
  export type AttendancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendancesUpdateManyMutationInput, AttendancesUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendancesWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendances updateManyAndReturn
   */
  export type AttendancesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendancesUpdateManyMutationInput, AttendancesUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendancesWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendances upsert
   */
  export type AttendancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendances to update in case it exists.
     */
    where: AttendancesWhereUniqueInput
    /**
     * In case the Attendances found by the `where` argument doesn't exist, create a new Attendances with this data.
     */
    create: XOR<AttendancesCreateInput, AttendancesUncheckedCreateInput>
    /**
     * In case the Attendances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendancesUpdateInput, AttendancesUncheckedUpdateInput>
  }

  /**
   * Attendances delete
   */
  export type AttendancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
    /**
     * Filter which Attendances to delete.
     */
    where: AttendancesWhereUniqueInput
  }

  /**
   * Attendances deleteMany
   */
  export type AttendancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendancesWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendances without action
   */
  export type AttendancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendances
     */
    select?: AttendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendances
     */
    omit?: AttendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendancesInclude<ExtArgs> | null
  }


  /**
   * Model Employees
   */

  export type AggregateEmployees = {
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesAvgAggregateOutputType = {
    id: number | null
    salary: number | null
  }

  export type EmployeesSumAggregateOutputType = {
    id: number | null
    salary: number | null
  }

  export type EmployeesMinAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    job_title: string | null
    salary: number | null
    matricule: string | null
    school_id: string | null
    password_hash: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EmployeesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    job_title: string | null
    salary: number | null
    matricule: string | null
    school_id: string | null
    password_hash: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type EmployeesCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    phone: number
    email: number
    adress: number
    gender: number
    job_title: number
    salary: number
    matricule: number
    school_id: number
    password_hash: number
    supabase_id: number
    user_supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type EmployeesAvgAggregateInputType = {
    id?: true
    salary?: true
  }

  export type EmployeesSumAggregateInputType = {
    id?: true
    salary?: true
  }

  export type EmployeesMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    job_title?: true
    salary?: true
    matricule?: true
    school_id?: true
    password_hash?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EmployeesMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    job_title?: true
    salary?: true
    matricule?: true
    school_id?: true
    password_hash?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type EmployeesCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    phone?: true
    email?: true
    adress?: true
    gender?: true
    job_title?: true
    salary?: true
    matricule?: true
    school_id?: true
    password_hash?: true
    supabase_id?: true
    user_supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type EmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to aggregate.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }




  export type EmployeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesWhereInput
    orderBy?: EmployeesOrderByWithAggregationInput | EmployeesOrderByWithAggregationInput[]
    by: EmployeesScalarFieldEnum[] | EmployeesScalarFieldEnum
    having?: EmployeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesCountAggregateInputType | true
    _avg?: EmployeesAvgAggregateInputType
    _sum?: EmployeesSumAggregateInputType
    _min?: EmployeesMinAggregateInputType
    _max?: EmployeesMaxAggregateInputType
  }

  export type EmployeesGroupByOutputType = {
    id: number
    name: string | null
    first_name: string | null
    phone: string | null
    email: string | null
    adress: string | null
    gender: string | null
    job_title: string | null
    salary: number | null
    matricule: string | null
    school_id: string | null
    password_hash: string | null
    supabase_id: string | null
    user_supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  type GetEmployeesGroupByPayload<T extends EmployeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: boolean | Employees$salary_paymentsArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    phone?: boolean
    email?: boolean
    adress?: boolean
    gender?: boolean
    job_title?: boolean
    salary?: boolean
    matricule?: boolean
    school_id?: boolean
    password_hash?: boolean
    supabase_id?: boolean
    user_supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "phone" | "email" | "adress" | "gender" | "job_title" | "salary" | "matricule" | "school_id" | "password_hash" | "supabase_id" | "user_supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["employees"]>
  export type EmployeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salary_payments?: boolean | Employees$salary_paymentsArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employees"
    objects: {
      salary_payments: Prisma.$SalaryPaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      first_name: string | null
      phone: string | null
      email: string | null
      adress: string | null
      gender: string | null
      job_title: string | null
      salary: number | null
      matricule: string | null
      school_id: string | null
      password_hash: string | null
      supabase_id: string | null
      user_supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["employees"]>
    composites: {}
  }

  type EmployeesGetPayload<S extends boolean | null | undefined | EmployeesDefaultArgs> = $Result.GetResult<Prisma.$EmployeesPayload, S>

  type EmployeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeesCountAggregateInputType | true
    }

  export interface EmployeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employees'], meta: { name: 'Employees' } }
    /**
     * Find zero or one Employees that matches the filter.
     * @param {EmployeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesFindUniqueArgs>(args: SelectSubset<T, EmployeesFindUniqueArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeesFindUniqueOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesFindFirstArgs>(args?: SelectSubset<T, EmployeesFindFirstArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeesWithIdOnly = await prisma.employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeesFindManyArgs>(args?: SelectSubset<T, EmployeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employees.
     * @param {EmployeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
     */
    create<T extends EmployeesCreateArgs>(args: SelectSubset<T, EmployeesCreateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeesCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesCreateManyArgs>(args?: SelectSubset<T, EmployeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeesCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeesCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employees.
     * @param {EmployeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
     */
    delete<T extends EmployeesDeleteArgs>(args: SelectSubset<T, EmployeesDeleteArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employees.
     * @param {EmployeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesUpdateArgs>(args: SelectSubset<T, EmployeesUpdateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesDeleteManyArgs>(args?: SelectSubset<T, EmployeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesUpdateManyArgs>(args: SelectSubset<T, EmployeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeesUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeesUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employees.
     * @param {EmployeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesUpsertArgs>(args: SelectSubset<T, EmployeesUpsertArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeesCountArgs>(
      args?: Subset<T, EmployeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAggregateType<T>>

    /**
     * Group by Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employees model
   */
  readonly fields: EmployeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salary_payments<T extends Employees$salary_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Employees$salary_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employees model
   */
  interface EmployeesFieldRefs {
    readonly id: FieldRef<"Employees", 'Int'>
    readonly name: FieldRef<"Employees", 'String'>
    readonly first_name: FieldRef<"Employees", 'String'>
    readonly phone: FieldRef<"Employees", 'String'>
    readonly email: FieldRef<"Employees", 'String'>
    readonly adress: FieldRef<"Employees", 'String'>
    readonly gender: FieldRef<"Employees", 'String'>
    readonly job_title: FieldRef<"Employees", 'String'>
    readonly salary: FieldRef<"Employees", 'Float'>
    readonly matricule: FieldRef<"Employees", 'String'>
    readonly school_id: FieldRef<"Employees", 'String'>
    readonly password_hash: FieldRef<"Employees", 'String'>
    readonly supabase_id: FieldRef<"Employees", 'String'>
    readonly user_supabase_id: FieldRef<"Employees", 'String'>
    readonly last_modified: FieldRef<"Employees", 'DateTime'>
    readonly needs_sync: FieldRef<"Employees", 'Boolean'>
    readonly is_deleted: FieldRef<"Employees", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Employees findUnique
   */
  export type EmployeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findUniqueOrThrow
   */
  export type EmployeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findFirst
   */
  export type EmployeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findFirstOrThrow
   */
  export type EmployeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findMany
   */
  export type EmployeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees create
   */
  export type EmployeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to create a Employees.
     */
    data?: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
  }

  /**
   * Employees createMany
   */
  export type EmployeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
  }

  /**
   * Employees createManyAndReturn
   */
  export type EmployeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
  }

  /**
   * Employees update
   */
  export type EmployeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to update a Employees.
     */
    data: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
    /**
     * Choose, which Employees to update.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees updateMany
   */
  export type EmployeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employees updateManyAndReturn
   */
  export type EmployeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employees upsert
   */
  export type EmployeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The filter to search for the Employees to update in case it exists.
     */
    where: EmployeesWhereUniqueInput
    /**
     * In case the Employees found by the `where` argument doesn't exist, create a new Employees with this data.
     */
    create: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
    /**
     * In case the Employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
  }

  /**
   * Employees delete
   */
  export type EmployeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter which Employees to delete.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees deleteMany
   */
  export type EmployeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employees.salary_payments
   */
  export type Employees$salary_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    where?: SalaryPaymentsWhereInput
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    cursor?: SalaryPaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * Employees without action
   */
  export type EmployeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
  }


  /**
   * Model SalaryPayments
   */

  export type AggregateSalaryPayments = {
    _count: SalaryPaymentsCountAggregateOutputType | null
    _avg: SalaryPaymentsAvgAggregateOutputType | null
    _sum: SalaryPaymentsSumAggregateOutputType | null
    _min: SalaryPaymentsMinAggregateOutputType | null
    _max: SalaryPaymentsMaxAggregateOutputType | null
  }

  export type SalaryPaymentsAvgAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
  }

  export type SalaryPaymentsSumAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
  }

  export type SalaryPaymentsMinAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
    payment_date: string | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SalaryPaymentsMaxAggregateOutputType = {
    id: number | null
    employee_id: number | null
    base_salary: number | null
    bonus_amount: number | null
    total_amount: number | null
    payment_date: string | null
    notes: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SalaryPaymentsCountAggregateOutputType = {
    id: number
    employee_id: number
    base_salary: number
    bonus_amount: number
    total_amount: number
    payment_date: number
    notes: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type SalaryPaymentsAvgAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
  }

  export type SalaryPaymentsSumAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
  }

  export type SalaryPaymentsMinAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
    payment_date?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SalaryPaymentsMaxAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
    payment_date?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SalaryPaymentsCountAggregateInputType = {
    id?: true
    employee_id?: true
    base_salary?: true
    bonus_amount?: true
    total_amount?: true
    payment_date?: true
    notes?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type SalaryPaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to aggregate.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryPayments
    **/
    _count?: true | SalaryPaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryPaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryPaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryPaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryPaymentsMaxAggregateInputType
  }

  export type GetSalaryPaymentsAggregateType<T extends SalaryPaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryPayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryPayments[P]>
      : GetScalarType<T[P], AggregateSalaryPayments[P]>
  }




  export type SalaryPaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentsWhereInput
    orderBy?: SalaryPaymentsOrderByWithAggregationInput | SalaryPaymentsOrderByWithAggregationInput[]
    by: SalaryPaymentsScalarFieldEnum[] | SalaryPaymentsScalarFieldEnum
    having?: SalaryPaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryPaymentsCountAggregateInputType | true
    _avg?: SalaryPaymentsAvgAggregateInputType
    _sum?: SalaryPaymentsSumAggregateInputType
    _min?: SalaryPaymentsMinAggregateInputType
    _max?: SalaryPaymentsMaxAggregateInputType
  }

  export type SalaryPaymentsGroupByOutputType = {
    id: number
    employee_id: number
    base_salary: number
    bonus_amount: number
    total_amount: number
    payment_date: string
    notes: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: SalaryPaymentsCountAggregateOutputType | null
    _avg: SalaryPaymentsAvgAggregateOutputType | null
    _sum: SalaryPaymentsSumAggregateOutputType | null
    _min: SalaryPaymentsMinAggregateOutputType | null
    _max: SalaryPaymentsMaxAggregateOutputType | null
  }

  type GetSalaryPaymentsGroupByPayload<T extends SalaryPaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryPaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryPaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryPaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryPaymentsGroupByOutputType[P]>
        }
      >
    >


  export type SalaryPaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayments"]>

  export type SalaryPaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayments"]>

  export type SalaryPaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayments"]>

  export type SalaryPaymentsSelectScalar = {
    id?: boolean
    employee_id?: boolean
    base_salary?: boolean
    bonus_amount?: boolean
    total_amount?: boolean
    payment_date?: boolean
    notes?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "base_salary" | "bonus_amount" | "total_amount" | "payment_date" | "notes" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["salaryPayments"]>
  export type SalaryPaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }

  export type $SalaryPaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryPayments"
    objects: {
      employee: Prisma.$EmployeesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employee_id: number
      base_salary: number
      bonus_amount: number
      total_amount: number
      payment_date: string
      notes: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["salaryPayments"]>
    composites: {}
  }

  type SalaryPaymentsGetPayload<S extends boolean | null | undefined | SalaryPaymentsDefaultArgs> = $Result.GetResult<Prisma.$SalaryPaymentsPayload, S>

  type SalaryPaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryPaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryPaymentsCountAggregateInputType | true
    }

  export interface SalaryPaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryPayments'], meta: { name: 'SalaryPayments' } }
    /**
     * Find zero or one SalaryPayments that matches the filter.
     * @param {SalaryPaymentsFindUniqueArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryPaymentsFindUniqueArgs>(args: SelectSubset<T, SalaryPaymentsFindUniqueArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryPayments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryPaymentsFindUniqueOrThrowArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryPaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryPaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsFindFirstArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryPaymentsFindFirstArgs>(args?: SelectSubset<T, SalaryPaymentsFindFirstArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryPayments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsFindFirstOrThrowArgs} args - Arguments to find a SalaryPayments
     * @example
     * // Get one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryPaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryPaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findMany()
     * 
     * // Get first 10 SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryPaymentsWithIdOnly = await prisma.salaryPayments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryPaymentsFindManyArgs>(args?: SelectSubset<T, SalaryPaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryPayments.
     * @param {SalaryPaymentsCreateArgs} args - Arguments to create a SalaryPayments.
     * @example
     * // Create one SalaryPayments
     * const SalaryPayments = await prisma.salaryPayments.create({
     *   data: {
     *     // ... data to create a SalaryPayments
     *   }
     * })
     * 
     */
    create<T extends SalaryPaymentsCreateArgs>(args: SelectSubset<T, SalaryPaymentsCreateArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryPayments.
     * @param {SalaryPaymentsCreateManyArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryPaymentsCreateManyArgs>(args?: SelectSubset<T, SalaryPaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryPayments and returns the data saved in the database.
     * @param {SalaryPaymentsCreateManyAndReturnArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryPayments and only return the `id`
     * const salaryPaymentsWithIdOnly = await prisma.salaryPayments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryPaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryPaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryPayments.
     * @param {SalaryPaymentsDeleteArgs} args - Arguments to delete one SalaryPayments.
     * @example
     * // Delete one SalaryPayments
     * const SalaryPayments = await prisma.salaryPayments.delete({
     *   where: {
     *     // ... filter to delete one SalaryPayments
     *   }
     * })
     * 
     */
    delete<T extends SalaryPaymentsDeleteArgs>(args: SelectSubset<T, SalaryPaymentsDeleteArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryPayments.
     * @param {SalaryPaymentsUpdateArgs} args - Arguments to update one SalaryPayments.
     * @example
     * // Update one SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryPaymentsUpdateArgs>(args: SelectSubset<T, SalaryPaymentsUpdateArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryPayments.
     * @param {SalaryPaymentsDeleteManyArgs} args - Arguments to filter SalaryPayments to delete.
     * @example
     * // Delete a few SalaryPayments
     * const { count } = await prisma.salaryPayments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryPaymentsDeleteManyArgs>(args?: SelectSubset<T, SalaryPaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryPaymentsUpdateManyArgs>(args: SelectSubset<T, SalaryPaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments and returns the data updated in the database.
     * @param {SalaryPaymentsUpdateManyAndReturnArgs} args - Arguments to update many SalaryPayments.
     * @example
     * // Update many SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryPayments and only return the `id`
     * const salaryPaymentsWithIdOnly = await prisma.salaryPayments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryPaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryPaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryPayments.
     * @param {SalaryPaymentsUpsertArgs} args - Arguments to update or create a SalaryPayments.
     * @example
     * // Update or create a SalaryPayments
     * const salaryPayments = await prisma.salaryPayments.upsert({
     *   create: {
     *     // ... data to create a SalaryPayments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryPayments we want to update
     *   }
     * })
     */
    upsert<T extends SalaryPaymentsUpsertArgs>(args: SelectSubset<T, SalaryPaymentsUpsertArgs<ExtArgs>>): Prisma__SalaryPaymentsClient<$Result.GetResult<Prisma.$SalaryPaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsCountArgs} args - Arguments to filter SalaryPayments to count.
     * @example
     * // Count the number of SalaryPayments
     * const count = await prisma.salaryPayments.count({
     *   where: {
     *     // ... the filter for the SalaryPayments we want to count
     *   }
     * })
    **/
    count<T extends SalaryPaymentsCountArgs>(
      args?: Subset<T, SalaryPaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryPaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryPaymentsAggregateArgs>(args: Subset<T, SalaryPaymentsAggregateArgs>): Prisma.PrismaPromise<GetSalaryPaymentsAggregateType<T>>

    /**
     * Group by SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryPaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryPaymentsGroupByArgs['orderBy'] }
        : { orderBy?: SalaryPaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryPaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryPayments model
   */
  readonly fields: SalaryPaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryPayments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryPaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeesDefaultArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryPayments model
   */
  interface SalaryPaymentsFieldRefs {
    readonly id: FieldRef<"SalaryPayments", 'Int'>
    readonly employee_id: FieldRef<"SalaryPayments", 'Int'>
    readonly base_salary: FieldRef<"SalaryPayments", 'Float'>
    readonly bonus_amount: FieldRef<"SalaryPayments", 'Float'>
    readonly total_amount: FieldRef<"SalaryPayments", 'Float'>
    readonly payment_date: FieldRef<"SalaryPayments", 'String'>
    readonly notes: FieldRef<"SalaryPayments", 'String'>
    readonly supabase_id: FieldRef<"SalaryPayments", 'String'>
    readonly last_modified: FieldRef<"SalaryPayments", 'DateTime'>
    readonly needs_sync: FieldRef<"SalaryPayments", 'Boolean'>
    readonly is_deleted: FieldRef<"SalaryPayments", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SalaryPayments findUnique
   */
  export type SalaryPaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments findUniqueOrThrow
   */
  export type SalaryPaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments findFirst
   */
  export type SalaryPaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * SalaryPayments findFirstOrThrow
   */
  export type SalaryPaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * SalaryPayments findMany
   */
  export type SalaryPaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentsOrderByWithRelationInput | SalaryPaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryPayments.
     */
    cursor?: SalaryPaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    distinct?: SalaryPaymentsScalarFieldEnum | SalaryPaymentsScalarFieldEnum[]
  }

  /**
   * SalaryPayments create
   */
  export type SalaryPaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryPayments.
     */
    data: XOR<SalaryPaymentsCreateInput, SalaryPaymentsUncheckedCreateInput>
  }

  /**
   * SalaryPayments createMany
   */
  export type SalaryPaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentsCreateManyInput | SalaryPaymentsCreateManyInput[]
  }

  /**
   * SalaryPayments createManyAndReturn
   */
  export type SalaryPaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentsCreateManyInput | SalaryPaymentsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayments update
   */
  export type SalaryPaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryPayments.
     */
    data: XOR<SalaryPaymentsUpdateInput, SalaryPaymentsUncheckedUpdateInput>
    /**
     * Choose, which SalaryPayments to update.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments updateMany
   */
  export type SalaryPaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentsUpdateManyMutationInput, SalaryPaymentsUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentsWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
  }

  /**
   * SalaryPayments updateManyAndReturn
   */
  export type SalaryPaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentsUpdateManyMutationInput, SalaryPaymentsUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentsWhereInput
    /**
     * Limit how many SalaryPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayments upsert
   */
  export type SalaryPaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryPayments to update in case it exists.
     */
    where: SalaryPaymentsWhereUniqueInput
    /**
     * In case the SalaryPayments found by the `where` argument doesn't exist, create a new SalaryPayments with this data.
     */
    create: XOR<SalaryPaymentsCreateInput, SalaryPaymentsUncheckedCreateInput>
    /**
     * In case the SalaryPayments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryPaymentsUpdateInput, SalaryPaymentsUncheckedUpdateInput>
  }

  /**
   * SalaryPayments delete
   */
  export type SalaryPaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
    /**
     * Filter which SalaryPayments to delete.
     */
    where: SalaryPaymentsWhereUniqueInput
  }

  /**
   * SalaryPayments deleteMany
   */
  export type SalaryPaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to delete
     */
    where?: SalaryPaymentsWhereInput
    /**
     * Limit how many SalaryPayments to delete.
     */
    limit?: number
  }

  /**
   * SalaryPayments without action
   */
  export type SalaryPaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayments
     */
    select?: SalaryPaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryPayments
     */
    omit?: SalaryPaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentsInclude<ExtArgs> | null
  }


  /**
   * Model Schedules
   */

  export type AggregateSchedules = {
    _count: SchedulesCountAggregateOutputType | null
    _avg: SchedulesAvgAggregateOutputType | null
    _sum: SchedulesSumAggregateOutputType | null
    _min: SchedulesMinAggregateOutputType | null
    _max: SchedulesMaxAggregateOutputType | null
  }

  export type SchedulesAvgAggregateOutputType = {
    id: number | null
    lesson_id: number | null
  }

  export type SchedulesSumAggregateOutputType = {
    id: number | null
    lesson_id: number | null
  }

  export type SchedulesMinAggregateOutputType = {
    id: number | null
    lesson_id: number | null
    day_of_week: string | null
    start_time: string | null
    end_time: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SchedulesMaxAggregateOutputType = {
    id: number | null
    lesson_id: number | null
    day_of_week: string | null
    start_time: string | null
    end_time: string | null
    supabase_id: string | null
    last_modified: Date | null
    needs_sync: boolean | null
    is_deleted: boolean | null
  }

  export type SchedulesCountAggregateOutputType = {
    id: number
    lesson_id: number
    day_of_week: number
    start_time: number
    end_time: number
    supabase_id: number
    last_modified: number
    needs_sync: number
    is_deleted: number
    _all: number
  }


  export type SchedulesAvgAggregateInputType = {
    id?: true
    lesson_id?: true
  }

  export type SchedulesSumAggregateInputType = {
    id?: true
    lesson_id?: true
  }

  export type SchedulesMinAggregateInputType = {
    id?: true
    lesson_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SchedulesMaxAggregateInputType = {
    id?: true
    lesson_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
  }

  export type SchedulesCountAggregateInputType = {
    id?: true
    lesson_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    supabase_id?: true
    last_modified?: true
    needs_sync?: true
    is_deleted?: true
    _all?: true
  }

  export type SchedulesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to aggregate.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | SchedulesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchedulesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchedulesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchedulesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchedulesMaxAggregateInputType
  }

  export type GetSchedulesAggregateType<T extends SchedulesAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedules]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedules[P]>
      : GetScalarType<T[P], AggregateSchedules[P]>
  }




  export type SchedulesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchedulesWhereInput
    orderBy?: SchedulesOrderByWithAggregationInput | SchedulesOrderByWithAggregationInput[]
    by: SchedulesScalarFieldEnum[] | SchedulesScalarFieldEnum
    having?: SchedulesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchedulesCountAggregateInputType | true
    _avg?: SchedulesAvgAggregateInputType
    _sum?: SchedulesSumAggregateInputType
    _min?: SchedulesMinAggregateInputType
    _max?: SchedulesMaxAggregateInputType
  }

  export type SchedulesGroupByOutputType = {
    id: number
    lesson_id: number
    day_of_week: string | null
    start_time: string | null
    end_time: string | null
    supabase_id: string | null
    last_modified: Date
    needs_sync: boolean
    is_deleted: boolean
    _count: SchedulesCountAggregateOutputType | null
    _avg: SchedulesAvgAggregateOutputType | null
    _sum: SchedulesSumAggregateOutputType | null
    _min: SchedulesMinAggregateOutputType | null
    _max: SchedulesMaxAggregateOutputType | null
  }

  type GetSchedulesGroupByPayload<T extends SchedulesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchedulesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchedulesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchedulesGroupByOutputType[P]>
            : GetScalarType<T[P], SchedulesGroupByOutputType[P]>
        }
      >
    >


  export type SchedulesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedules"]>

  export type SchedulesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedules"]>

  export type SchedulesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedules"]>

  export type SchedulesSelectScalar = {
    id?: boolean
    lesson_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    supabase_id?: boolean
    last_modified?: boolean
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lesson_id" | "day_of_week" | "start_time" | "end_time" | "supabase_id" | "last_modified" | "needs_sync" | "is_deleted", ExtArgs["result"]["schedules"]>
  export type SchedulesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }
  export type SchedulesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }
  export type SchedulesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonsDefaultArgs<ExtArgs>
  }

  export type $SchedulesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedules"
    objects: {
      lesson: Prisma.$LessonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lesson_id: number
      day_of_week: string | null
      start_time: string | null
      end_time: string | null
      supabase_id: string | null
      last_modified: Date
      needs_sync: boolean
      is_deleted: boolean
    }, ExtArgs["result"]["schedules"]>
    composites: {}
  }

  type SchedulesGetPayload<S extends boolean | null | undefined | SchedulesDefaultArgs> = $Result.GetResult<Prisma.$SchedulesPayload, S>

  type SchedulesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchedulesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchedulesCountAggregateInputType | true
    }

  export interface SchedulesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedules'], meta: { name: 'Schedules' } }
    /**
     * Find zero or one Schedules that matches the filter.
     * @param {SchedulesFindUniqueArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchedulesFindUniqueArgs>(args: SelectSubset<T, SchedulesFindUniqueArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedules that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchedulesFindUniqueOrThrowArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchedulesFindUniqueOrThrowArgs>(args: SelectSubset<T, SchedulesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesFindFirstArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchedulesFindFirstArgs>(args?: SelectSubset<T, SchedulesFindFirstArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedules that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesFindFirstOrThrowArgs} args - Arguments to find a Schedules
     * @example
     * // Get one Schedules
     * const schedules = await prisma.schedules.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchedulesFindFirstOrThrowArgs>(args?: SelectSubset<T, SchedulesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedules.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedules.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schedulesWithIdOnly = await prisma.schedules.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchedulesFindManyArgs>(args?: SelectSubset<T, SchedulesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedules.
     * @param {SchedulesCreateArgs} args - Arguments to create a Schedules.
     * @example
     * // Create one Schedules
     * const Schedules = await prisma.schedules.create({
     *   data: {
     *     // ... data to create a Schedules
     *   }
     * })
     * 
     */
    create<T extends SchedulesCreateArgs>(args: SelectSubset<T, SchedulesCreateArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {SchedulesCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedules = await prisma.schedules.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchedulesCreateManyArgs>(args?: SelectSubset<T, SchedulesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {SchedulesCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedules = await prisma.schedules.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const schedulesWithIdOnly = await prisma.schedules.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchedulesCreateManyAndReturnArgs>(args?: SelectSubset<T, SchedulesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedules.
     * @param {SchedulesDeleteArgs} args - Arguments to delete one Schedules.
     * @example
     * // Delete one Schedules
     * const Schedules = await prisma.schedules.delete({
     *   where: {
     *     // ... filter to delete one Schedules
     *   }
     * })
     * 
     */
    delete<T extends SchedulesDeleteArgs>(args: SelectSubset<T, SchedulesDeleteArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedules.
     * @param {SchedulesUpdateArgs} args - Arguments to update one Schedules.
     * @example
     * // Update one Schedules
     * const schedules = await prisma.schedules.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchedulesUpdateArgs>(args: SelectSubset<T, SchedulesUpdateArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {SchedulesDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedules.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchedulesDeleteManyArgs>(args?: SelectSubset<T, SchedulesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedules = await prisma.schedules.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchedulesUpdateManyArgs>(args: SelectSubset<T, SchedulesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {SchedulesUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedules = await prisma.schedules.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const schedulesWithIdOnly = await prisma.schedules.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchedulesUpdateManyAndReturnArgs>(args: SelectSubset<T, SchedulesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedules.
     * @param {SchedulesUpsertArgs} args - Arguments to update or create a Schedules.
     * @example
     * // Update or create a Schedules
     * const schedules = await prisma.schedules.upsert({
     *   create: {
     *     // ... data to create a Schedules
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedules we want to update
     *   }
     * })
     */
    upsert<T extends SchedulesUpsertArgs>(args: SelectSubset<T, SchedulesUpsertArgs<ExtArgs>>): Prisma__SchedulesClient<$Result.GetResult<Prisma.$SchedulesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedules.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends SchedulesCountArgs>(
      args?: Subset<T, SchedulesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchedulesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchedulesAggregateArgs>(args: Subset<T, SchedulesAggregateArgs>): Prisma.PrismaPromise<GetSchedulesAggregateType<T>>

    /**
     * Group by Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchedulesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchedulesGroupByArgs['orderBy'] }
        : { orderBy?: SchedulesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchedulesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchedulesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedules model
   */
  readonly fields: SchedulesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedules.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchedulesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonsDefaultArgs<ExtArgs>>): Prisma__LessonsClient<$Result.GetResult<Prisma.$LessonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedules model
   */
  interface SchedulesFieldRefs {
    readonly id: FieldRef<"Schedules", 'Int'>
    readonly lesson_id: FieldRef<"Schedules", 'Int'>
    readonly day_of_week: FieldRef<"Schedules", 'String'>
    readonly start_time: FieldRef<"Schedules", 'String'>
    readonly end_time: FieldRef<"Schedules", 'String'>
    readonly supabase_id: FieldRef<"Schedules", 'String'>
    readonly last_modified: FieldRef<"Schedules", 'DateTime'>
    readonly needs_sync: FieldRef<"Schedules", 'Boolean'>
    readonly is_deleted: FieldRef<"Schedules", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Schedules findUnique
   */
  export type SchedulesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules findUniqueOrThrow
   */
  export type SchedulesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules findFirst
   */
  export type SchedulesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Schedules findFirstOrThrow
   */
  export type SchedulesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Schedules findMany
   */
  export type SchedulesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: SchedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: SchedulesOrderByWithRelationInput | SchedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: SchedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: SchedulesScalarFieldEnum | SchedulesScalarFieldEnum[]
  }

  /**
   * Schedules create
   */
  export type SchedulesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedules.
     */
    data: XOR<SchedulesCreateInput, SchedulesUncheckedCreateInput>
  }

  /**
   * Schedules createMany
   */
  export type SchedulesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: SchedulesCreateManyInput | SchedulesCreateManyInput[]
  }

  /**
   * Schedules createManyAndReturn
   */
  export type SchedulesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: SchedulesCreateManyInput | SchedulesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedules update
   */
  export type SchedulesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedules.
     */
    data: XOR<SchedulesUpdateInput, SchedulesUncheckedUpdateInput>
    /**
     * Choose, which Schedules to update.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules updateMany
   */
  export type SchedulesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<SchedulesUpdateManyMutationInput, SchedulesUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: SchedulesWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedules updateManyAndReturn
   */
  export type SchedulesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<SchedulesUpdateManyMutationInput, SchedulesUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: SchedulesWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedules upsert
   */
  export type SchedulesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedules to update in case it exists.
     */
    where: SchedulesWhereUniqueInput
    /**
     * In case the Schedules found by the `where` argument doesn't exist, create a new Schedules with this data.
     */
    create: XOR<SchedulesCreateInput, SchedulesUncheckedCreateInput>
    /**
     * In case the Schedules was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchedulesUpdateInput, SchedulesUncheckedUpdateInput>
  }

  /**
   * Schedules delete
   */
  export type SchedulesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
    /**
     * Filter which Schedules to delete.
     */
    where: SchedulesWhereUniqueInput
  }

  /**
   * Schedules deleteMany
   */
  export type SchedulesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: SchedulesWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedules without action
   */
  export type SchedulesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedules
     */
    select?: SchedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedules
     */
    omit?: SchedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    schoolName: 'schoolName',
    schoolAddress: 'schoolAddress',
    loggedIn: 'loggedIn',
    userRole: 'userRole',
    schoolId: 'schoolId',
    userToken: 'userToken',
    last_sync: 'last_sync'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const ClassesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    school_id: 'school_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type ClassesScalarFieldEnum = (typeof ClassesScalarFieldEnum)[keyof typeof ClassesScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    genre: 'genre',
    birth_date: 'birth_date',
    picture_url: 'picture_url',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted',
    matricul: 'matricul'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const RegistrationsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    class_id: 'class_id',
    school_year: 'school_year',
    state: 'state',
    registration_date: 'registration_date',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type RegistrationsScalarFieldEnum = (typeof RegistrationsScalarFieldEnum)[keyof typeof RegistrationsScalarFieldEnum]


  export const TeachersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    phone: 'phone',
    email: 'email',
    adress: 'adress',
    password_hash: 'password_hash',
    role_id: 'role_id',
    speciality: 'speciality',
    matricule: 'matricule',
    supabase_id: 'supabase_id',
    user_supabase_id: 'user_supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted',
    hourlyRate: 'hourlyRate',
    school_id: 'school_id'
  };

  export type TeachersScalarFieldEnum = (typeof TeachersScalarFieldEnum)[keyof typeof TeachersScalarFieldEnum]


  export const TeacherWorkHoursScalarFieldEnum: {
    id: 'id',
    teacher_id: 'teacher_id',
    subject_id: 'subject_id',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    hours: 'hours',
    notes: 'notes',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type TeacherWorkHoursScalarFieldEnum = (typeof TeacherWorkHoursScalarFieldEnum)[keyof typeof TeacherWorkHoursScalarFieldEnum]


  export const LessonsScalarFieldEnum: {
    id: 'id',
    teacher_id: 'teacher_id',
    class_id: 'class_id',
    subject_id: 'subject_id',
    school_year: 'school_year',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type LessonsScalarFieldEnum = (typeof LessonsScalarFieldEnum)[keyof typeof LessonsScalarFieldEnum]


  export const SubjectsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    class_id: 'class_id',
    school_year: 'school_year',
    coefficient: 'coefficient',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type SubjectsScalarFieldEnum = (typeof SubjectsScalarFieldEnum)[keyof typeof SubjectsScalarFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    lesson_id: 'lesson_id',
    value: 'value',
    type: 'type',
    quarter: 'quarter',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const ParentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    phone: 'phone',
    email: 'email',
    adress: 'adress',
    gender: 'gender',
    profession: 'profession',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted',
    school_id: 'school_id'
  };

  export type ParentsScalarFieldEnum = (typeof ParentsScalarFieldEnum)[keyof typeof ParentsScalarFieldEnum]


  export const StudentParentsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    parent_id: 'parent_id',
    relation: 'relation',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type StudentParentsScalarFieldEnum = (typeof StudentParentsScalarFieldEnum)[keyof typeof StudentParentsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    registration_id: 'registration_id',
    fee_id: 'fee_id',
    amount: 'amount',
    method: 'method',
    date: 'date',
    reference: 'reference',
    emitter_id: 'emitter_id',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const FeesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    amount: 'amount',
    due_date: 'due_date',
    school_year: 'school_year',
    level: 'level',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type FeesScalarFieldEnum = (typeof FeesScalarFieldEnum)[keyof typeof FeesScalarFieldEnum]


  export const AttendancesScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    date: 'date',
    state: 'state',
    justification: 'justification',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type AttendancesScalarFieldEnum = (typeof AttendancesScalarFieldEnum)[keyof typeof AttendancesScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    phone: 'phone',
    email: 'email',
    adress: 'adress',
    gender: 'gender',
    job_title: 'job_title',
    salary: 'salary',
    matricule: 'matricule',
    school_id: 'school_id',
    password_hash: 'password_hash',
    supabase_id: 'supabase_id',
    user_supabase_id: 'user_supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const SalaryPaymentsScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    base_salary: 'base_salary',
    bonus_amount: 'bonus_amount',
    total_amount: 'total_amount',
    payment_date: 'payment_date',
    notes: 'notes',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type SalaryPaymentsScalarFieldEnum = (typeof SalaryPaymentsScalarFieldEnum)[keyof typeof SalaryPaymentsScalarFieldEnum]


  export const SchedulesScalarFieldEnum: {
    id: 'id',
    lesson_id: 'lesson_id',
    day_of_week: 'day_of_week',
    start_time: 'start_time',
    end_time: 'end_time',
    supabase_id: 'supabase_id',
    last_modified: 'last_modified',
    needs_sync: 'needs_sync',
    is_deleted: 'is_deleted'
  };

  export type SchedulesScalarFieldEnum = (typeof SchedulesScalarFieldEnum)[keyof typeof SchedulesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: IntFilter<"Settings"> | number
    schoolName?: StringNullableFilter<"Settings"> | string | null
    schoolAddress?: StringNullableFilter<"Settings"> | string | null
    loggedIn?: IntNullableFilter<"Settings"> | number | null
    userRole?: StringNullableFilter<"Settings"> | string | null
    schoolId?: StringNullableFilter<"Settings"> | string | null
    userToken?: StringNullableFilter<"Settings"> | string | null
    last_sync?: DateTimeNullableFilter<"Settings"> | Date | string | null
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    schoolName?: SortOrderInput | SortOrder
    schoolAddress?: SortOrderInput | SortOrder
    loggedIn?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    userToken?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    schoolName?: StringNullableFilter<"Settings"> | string | null
    schoolAddress?: StringNullableFilter<"Settings"> | string | null
    loggedIn?: IntNullableFilter<"Settings"> | number | null
    userRole?: StringNullableFilter<"Settings"> | string | null
    schoolId?: StringNullableFilter<"Settings"> | string | null
    userToken?: StringNullableFilter<"Settings"> | string | null
    last_sync?: DateTimeNullableFilter<"Settings"> | Date | string | null
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolName?: SortOrderInput | SortOrder
    schoolAddress?: SortOrderInput | SortOrder
    loggedIn?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    userToken?: SortOrderInput | SortOrder
    last_sync?: SortOrderInput | SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settings"> | number
    schoolName?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    schoolAddress?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    loggedIn?: IntNullableWithAggregatesFilter<"Settings"> | number | null
    userRole?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    schoolId?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    userToken?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    last_sync?: DateTimeNullableWithAggregatesFilter<"Settings"> | Date | string | null
  }

  export type ClassesWhereInput = {
    AND?: ClassesWhereInput | ClassesWhereInput[]
    OR?: ClassesWhereInput[]
    NOT?: ClassesWhereInput | ClassesWhereInput[]
    id?: IntFilter<"Classes"> | number
    name?: StringFilter<"Classes"> | string
    level?: StringNullableFilter<"Classes"> | string | null
    school_id?: StringNullableFilter<"Classes"> | string | null
    supabase_id?: StringNullableFilter<"Classes"> | string | null
    last_modified?: DateTimeFilter<"Classes"> | Date | string
    needs_sync?: BoolFilter<"Classes"> | boolean
    is_deleted?: BoolFilter<"Classes"> | boolean
    lessons?: LessonsListRelationFilter
    registrations?: RegistrationsListRelationFilter
    subjects?: SubjectsListRelationFilter
  }

  export type ClassesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lessons?: LessonsOrderByRelationAggregateInput
    registrations?: RegistrationsOrderByRelationAggregateInput
    subjects?: SubjectsOrderByRelationAggregateInput
  }

  export type ClassesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: ClassesWhereInput | ClassesWhereInput[]
    OR?: ClassesWhereInput[]
    NOT?: ClassesWhereInput | ClassesWhereInput[]
    name?: StringFilter<"Classes"> | string
    level?: StringNullableFilter<"Classes"> | string | null
    school_id?: StringNullableFilter<"Classes"> | string | null
    last_modified?: DateTimeFilter<"Classes"> | Date | string
    needs_sync?: BoolFilter<"Classes"> | boolean
    is_deleted?: BoolFilter<"Classes"> | boolean
    lessons?: LessonsListRelationFilter
    registrations?: RegistrationsListRelationFilter
    subjects?: SubjectsListRelationFilter
  }, "id" | "supabase_id">

  export type ClassesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: ClassesCountOrderByAggregateInput
    _avg?: ClassesAvgOrderByAggregateInput
    _max?: ClassesMaxOrderByAggregateInput
    _min?: ClassesMinOrderByAggregateInput
    _sum?: ClassesSumOrderByAggregateInput
  }

  export type ClassesScalarWhereWithAggregatesInput = {
    AND?: ClassesScalarWhereWithAggregatesInput | ClassesScalarWhereWithAggregatesInput[]
    OR?: ClassesScalarWhereWithAggregatesInput[]
    NOT?: ClassesScalarWhereWithAggregatesInput | ClassesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Classes"> | number
    name?: StringWithAggregatesFilter<"Classes"> | string
    level?: StringNullableWithAggregatesFilter<"Classes"> | string | null
    school_id?: StringNullableWithAggregatesFilter<"Classes"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Classes"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Classes"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Classes"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Classes"> | boolean
  }

  export type StudentsWhereInput = {
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    id?: IntFilter<"Students"> | number
    name?: StringNullableFilter<"Students"> | string | null
    first_name?: StringNullableFilter<"Students"> | string | null
    genre?: StringNullableFilter<"Students"> | string | null
    birth_date?: StringNullableFilter<"Students"> | string | null
    picture_url?: StringNullableFilter<"Students"> | string | null
    supabase_id?: StringNullableFilter<"Students"> | string | null
    last_modified?: DateTimeFilter<"Students"> | Date | string
    needs_sync?: BoolFilter<"Students"> | boolean
    is_deleted?: BoolFilter<"Students"> | boolean
    matricul?: StringNullableFilter<"Students"> | string | null
    attendances?: AttendancesListRelationFilter
    notes?: NotesListRelationFilter
    registrations?: RegistrationsListRelationFilter
    student_parents?: StudentParentsListRelationFilter
  }

  export type StudentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    picture_url?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrderInput | SortOrder
    attendances?: AttendancesOrderByRelationAggregateInput
    notes?: NotesOrderByRelationAggregateInput
    registrations?: RegistrationsOrderByRelationAggregateInput
    student_parents?: StudentParentsOrderByRelationAggregateInput
  }

  export type StudentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    matricul?: string
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    name?: StringNullableFilter<"Students"> | string | null
    first_name?: StringNullableFilter<"Students"> | string | null
    genre?: StringNullableFilter<"Students"> | string | null
    birth_date?: StringNullableFilter<"Students"> | string | null
    picture_url?: StringNullableFilter<"Students"> | string | null
    last_modified?: DateTimeFilter<"Students"> | Date | string
    needs_sync?: BoolFilter<"Students"> | boolean
    is_deleted?: BoolFilter<"Students"> | boolean
    attendances?: AttendancesListRelationFilter
    notes?: NotesListRelationFilter
    registrations?: RegistrationsListRelationFilter
    student_parents?: StudentParentsListRelationFilter
  }, "id" | "supabase_id" | "matricul">

  export type StudentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    picture_url?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrderInput | SortOrder
    _count?: StudentsCountOrderByAggregateInput
    _avg?: StudentsAvgOrderByAggregateInput
    _max?: StudentsMaxOrderByAggregateInput
    _min?: StudentsMinOrderByAggregateInput
    _sum?: StudentsSumOrderByAggregateInput
  }

  export type StudentsScalarWhereWithAggregatesInput = {
    AND?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    OR?: StudentsScalarWhereWithAggregatesInput[]
    NOT?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Students"> | number
    name?: StringNullableWithAggregatesFilter<"Students"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Students"> | string | null
    genre?: StringNullableWithAggregatesFilter<"Students"> | string | null
    birth_date?: StringNullableWithAggregatesFilter<"Students"> | string | null
    picture_url?: StringNullableWithAggregatesFilter<"Students"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Students"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Students"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Students"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Students"> | boolean
    matricul?: StringNullableWithAggregatesFilter<"Students"> | string | null
  }

  export type RegistrationsWhereInput = {
    AND?: RegistrationsWhereInput | RegistrationsWhereInput[]
    OR?: RegistrationsWhereInput[]
    NOT?: RegistrationsWhereInput | RegistrationsWhereInput[]
    id?: IntFilter<"Registrations"> | number
    student_id?: IntFilter<"Registrations"> | number
    class_id?: IntFilter<"Registrations"> | number
    school_year?: StringNullableFilter<"Registrations"> | string | null
    state?: StringNullableFilter<"Registrations"> | string | null
    registration_date?: StringNullableFilter<"Registrations"> | string | null
    supabase_id?: StringNullableFilter<"Registrations"> | string | null
    last_modified?: DateTimeFilter<"Registrations"> | Date | string
    needs_sync?: BoolFilter<"Registrations"> | boolean
    is_deleted?: BoolFilter<"Registrations"> | boolean
    payments?: PaymentsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type RegistrationsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    registration_date?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    payments?: PaymentsOrderByRelationAggregateInput
    class?: ClassesOrderByWithRelationInput
    student?: StudentsOrderByWithRelationInput
  }

  export type RegistrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: RegistrationsWhereInput | RegistrationsWhereInput[]
    OR?: RegistrationsWhereInput[]
    NOT?: RegistrationsWhereInput | RegistrationsWhereInput[]
    student_id?: IntFilter<"Registrations"> | number
    class_id?: IntFilter<"Registrations"> | number
    school_year?: StringNullableFilter<"Registrations"> | string | null
    state?: StringNullableFilter<"Registrations"> | string | null
    registration_date?: StringNullableFilter<"Registrations"> | string | null
    last_modified?: DateTimeFilter<"Registrations"> | Date | string
    needs_sync?: BoolFilter<"Registrations"> | boolean
    is_deleted?: BoolFilter<"Registrations"> | boolean
    payments?: PaymentsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id">

  export type RegistrationsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    registration_date?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: RegistrationsCountOrderByAggregateInput
    _avg?: RegistrationsAvgOrderByAggregateInput
    _max?: RegistrationsMaxOrderByAggregateInput
    _min?: RegistrationsMinOrderByAggregateInput
    _sum?: RegistrationsSumOrderByAggregateInput
  }

  export type RegistrationsScalarWhereWithAggregatesInput = {
    AND?: RegistrationsScalarWhereWithAggregatesInput | RegistrationsScalarWhereWithAggregatesInput[]
    OR?: RegistrationsScalarWhereWithAggregatesInput[]
    NOT?: RegistrationsScalarWhereWithAggregatesInput | RegistrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Registrations"> | number
    student_id?: IntWithAggregatesFilter<"Registrations"> | number
    class_id?: IntWithAggregatesFilter<"Registrations"> | number
    school_year?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    state?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    registration_date?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Registrations"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Registrations"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Registrations"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Registrations"> | boolean
  }

  export type TeachersWhereInput = {
    AND?: TeachersWhereInput | TeachersWhereInput[]
    OR?: TeachersWhereInput[]
    NOT?: TeachersWhereInput | TeachersWhereInput[]
    id?: IntFilter<"Teachers"> | number
    name?: StringNullableFilter<"Teachers"> | string | null
    first_name?: StringNullableFilter<"Teachers"> | string | null
    phone?: StringNullableFilter<"Teachers"> | string | null
    email?: StringNullableFilter<"Teachers"> | string | null
    adress?: StringNullableFilter<"Teachers"> | string | null
    password_hash?: StringNullableFilter<"Teachers"> | string | null
    role_id?: StringNullableFilter<"Teachers"> | string | null
    speciality?: StringNullableFilter<"Teachers"> | string | null
    matricule?: StringNullableFilter<"Teachers"> | string | null
    supabase_id?: StringNullableFilter<"Teachers"> | string | null
    user_supabase_id?: StringNullableFilter<"Teachers"> | string | null
    last_modified?: DateTimeFilter<"Teachers"> | Date | string
    needs_sync?: BoolFilter<"Teachers"> | boolean
    is_deleted?: BoolFilter<"Teachers"> | boolean
    hourlyRate?: FloatNullableFilter<"Teachers"> | number | null
    school_id?: StringNullableFilter<"Teachers"> | string | null
    lessons?: LessonsListRelationFilter
    workHours?: TeacherWorkHoursListRelationFilter
  }

  export type TeachersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    speciality?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    lessons?: LessonsOrderByRelationAggregateInput
    workHours?: TeacherWorkHoursOrderByRelationAggregateInput
  }

  export type TeachersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    supabase_id?: string
    AND?: TeachersWhereInput | TeachersWhereInput[]
    OR?: TeachersWhereInput[]
    NOT?: TeachersWhereInput | TeachersWhereInput[]
    name?: StringNullableFilter<"Teachers"> | string | null
    first_name?: StringNullableFilter<"Teachers"> | string | null
    phone?: StringNullableFilter<"Teachers"> | string | null
    adress?: StringNullableFilter<"Teachers"> | string | null
    password_hash?: StringNullableFilter<"Teachers"> | string | null
    role_id?: StringNullableFilter<"Teachers"> | string | null
    speciality?: StringNullableFilter<"Teachers"> | string | null
    matricule?: StringNullableFilter<"Teachers"> | string | null
    user_supabase_id?: StringNullableFilter<"Teachers"> | string | null
    last_modified?: DateTimeFilter<"Teachers"> | Date | string
    needs_sync?: BoolFilter<"Teachers"> | boolean
    is_deleted?: BoolFilter<"Teachers"> | boolean
    hourlyRate?: FloatNullableFilter<"Teachers"> | number | null
    school_id?: StringNullableFilter<"Teachers"> | string | null
    lessons?: LessonsListRelationFilter
    workHours?: TeacherWorkHoursListRelationFilter
  }, "id" | "email" | "supabase_id">

  export type TeachersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    role_id?: SortOrderInput | SortOrder
    speciality?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    _count?: TeachersCountOrderByAggregateInput
    _avg?: TeachersAvgOrderByAggregateInput
    _max?: TeachersMaxOrderByAggregateInput
    _min?: TeachersMinOrderByAggregateInput
    _sum?: TeachersSumOrderByAggregateInput
  }

  export type TeachersScalarWhereWithAggregatesInput = {
    AND?: TeachersScalarWhereWithAggregatesInput | TeachersScalarWhereWithAggregatesInput[]
    OR?: TeachersScalarWhereWithAggregatesInput[]
    NOT?: TeachersScalarWhereWithAggregatesInput | TeachersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Teachers"> | number
    name?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    email?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    adress?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    role_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    speciality?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    matricule?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    user_supabase_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Teachers"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Teachers"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Teachers"> | boolean
    hourlyRate?: FloatNullableWithAggregatesFilter<"Teachers"> | number | null
    school_id?: StringNullableWithAggregatesFilter<"Teachers"> | string | null
  }

  export type TeacherWorkHoursWhereInput = {
    AND?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    OR?: TeacherWorkHoursWhereInput[]
    NOT?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    id?: IntFilter<"TeacherWorkHours"> | number
    teacher_id?: IntFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    hours?: FloatFilter<"TeacherWorkHours"> | number
    notes?: StringNullableFilter<"TeacherWorkHours"> | string | null
    supabase_id?: StringNullableFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolFilter<"TeacherWorkHours"> | boolean
    subject?: XOR<SubjectsNullableScalarRelationFilter, SubjectsWhereInput> | null
    teacher?: XOR<TeachersScalarRelationFilter, TeachersWhereInput>
  }

  export type TeacherWorkHoursOrderByWithRelationInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    hours?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    subject?: SubjectsOrderByWithRelationInput
    teacher?: TeachersOrderByWithRelationInput
  }

  export type TeacherWorkHoursWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    OR?: TeacherWorkHoursWhereInput[]
    NOT?: TeacherWorkHoursWhereInput | TeacherWorkHoursWhereInput[]
    teacher_id?: IntFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    hours?: FloatFilter<"TeacherWorkHours"> | number
    notes?: StringNullableFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolFilter<"TeacherWorkHours"> | boolean
    subject?: XOR<SubjectsNullableScalarRelationFilter, SubjectsWhereInput> | null
    teacher?: XOR<TeachersScalarRelationFilter, TeachersWhereInput>
  }, "id" | "supabase_id">

  export type TeacherWorkHoursOrderByWithAggregationInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    hours?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: TeacherWorkHoursCountOrderByAggregateInput
    _avg?: TeacherWorkHoursAvgOrderByAggregateInput
    _max?: TeacherWorkHoursMaxOrderByAggregateInput
    _min?: TeacherWorkHoursMinOrderByAggregateInput
    _sum?: TeacherWorkHoursSumOrderByAggregateInput
  }

  export type TeacherWorkHoursScalarWhereWithAggregatesInput = {
    AND?: TeacherWorkHoursScalarWhereWithAggregatesInput | TeacherWorkHoursScalarWhereWithAggregatesInput[]
    OR?: TeacherWorkHoursScalarWhereWithAggregatesInput[]
    NOT?: TeacherWorkHoursScalarWhereWithAggregatesInput | TeacherWorkHoursScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherWorkHours"> | number
    teacher_id?: IntWithAggregatesFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableWithAggregatesFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    hours?: FloatWithAggregatesFilter<"TeacherWorkHours"> | number
    notes?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"TeacherWorkHours"> | boolean
  }

  export type LessonsWhereInput = {
    AND?: LessonsWhereInput | LessonsWhereInput[]
    OR?: LessonsWhereInput[]
    NOT?: LessonsWhereInput | LessonsWhereInput[]
    id?: IntFilter<"Lessons"> | number
    teacher_id?: IntNullableFilter<"Lessons"> | number | null
    class_id?: IntFilter<"Lessons"> | number
    subject_id?: IntFilter<"Lessons"> | number
    school_year?: StringNullableFilter<"Lessons"> | string | null
    supabase_id?: StringNullableFilter<"Lessons"> | string | null
    last_modified?: DateTimeFilter<"Lessons"> | Date | string
    needs_sync?: BoolFilter<"Lessons"> | boolean
    is_deleted?: BoolFilter<"Lessons"> | boolean
    subject?: XOR<SubjectsScalarRelationFilter, SubjectsWhereInput>
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    teacher?: XOR<TeachersNullableScalarRelationFilter, TeachersWhereInput> | null
    notes?: NotesListRelationFilter
    schedules?: SchedulesListRelationFilter
  }

  export type LessonsOrderByWithRelationInput = {
    id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    subject?: SubjectsOrderByWithRelationInput
    class?: ClassesOrderByWithRelationInput
    teacher?: TeachersOrderByWithRelationInput
    notes?: NotesOrderByRelationAggregateInput
    schedules?: SchedulesOrderByRelationAggregateInput
  }

  export type LessonsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: LessonsWhereInput | LessonsWhereInput[]
    OR?: LessonsWhereInput[]
    NOT?: LessonsWhereInput | LessonsWhereInput[]
    teacher_id?: IntNullableFilter<"Lessons"> | number | null
    class_id?: IntFilter<"Lessons"> | number
    subject_id?: IntFilter<"Lessons"> | number
    school_year?: StringNullableFilter<"Lessons"> | string | null
    last_modified?: DateTimeFilter<"Lessons"> | Date | string
    needs_sync?: BoolFilter<"Lessons"> | boolean
    is_deleted?: BoolFilter<"Lessons"> | boolean
    subject?: XOR<SubjectsScalarRelationFilter, SubjectsWhereInput>
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    teacher?: XOR<TeachersNullableScalarRelationFilter, TeachersWhereInput> | null
    notes?: NotesListRelationFilter
    schedules?: SchedulesListRelationFilter
  }, "id" | "supabase_id">

  export type LessonsOrderByWithAggregationInput = {
    id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: LessonsCountOrderByAggregateInput
    _avg?: LessonsAvgOrderByAggregateInput
    _max?: LessonsMaxOrderByAggregateInput
    _min?: LessonsMinOrderByAggregateInput
    _sum?: LessonsSumOrderByAggregateInput
  }

  export type LessonsScalarWhereWithAggregatesInput = {
    AND?: LessonsScalarWhereWithAggregatesInput | LessonsScalarWhereWithAggregatesInput[]
    OR?: LessonsScalarWhereWithAggregatesInput[]
    NOT?: LessonsScalarWhereWithAggregatesInput | LessonsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lessons"> | number
    teacher_id?: IntNullableWithAggregatesFilter<"Lessons"> | number | null
    class_id?: IntWithAggregatesFilter<"Lessons"> | number
    subject_id?: IntWithAggregatesFilter<"Lessons"> | number
    school_year?: StringNullableWithAggregatesFilter<"Lessons"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Lessons"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Lessons"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Lessons"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Lessons"> | boolean
  }

  export type SubjectsWhereInput = {
    AND?: SubjectsWhereInput | SubjectsWhereInput[]
    OR?: SubjectsWhereInput[]
    NOT?: SubjectsWhereInput | SubjectsWhereInput[]
    id?: IntFilter<"Subjects"> | number
    name?: StringFilter<"Subjects"> | string
    class_id?: IntFilter<"Subjects"> | number
    school_year?: StringNullableFilter<"Subjects"> | string | null
    coefficient?: IntNullableFilter<"Subjects"> | number | null
    supabase_id?: StringNullableFilter<"Subjects"> | string | null
    last_modified?: DateTimeFilter<"Subjects"> | Date | string
    needs_sync?: BoolFilter<"Subjects"> | boolean
    is_deleted?: BoolFilter<"Subjects"> | boolean
    lessons?: LessonsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    workHours?: TeacherWorkHoursListRelationFilter
  }

  export type SubjectsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lessons?: LessonsOrderByRelationAggregateInput
    class?: ClassesOrderByWithRelationInput
    workHours?: TeacherWorkHoursOrderByRelationAggregateInput
  }

  export type SubjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: SubjectsWhereInput | SubjectsWhereInput[]
    OR?: SubjectsWhereInput[]
    NOT?: SubjectsWhereInput | SubjectsWhereInput[]
    name?: StringFilter<"Subjects"> | string
    class_id?: IntFilter<"Subjects"> | number
    school_year?: StringNullableFilter<"Subjects"> | string | null
    coefficient?: IntNullableFilter<"Subjects"> | number | null
    last_modified?: DateTimeFilter<"Subjects"> | Date | string
    needs_sync?: BoolFilter<"Subjects"> | boolean
    is_deleted?: BoolFilter<"Subjects"> | boolean
    lessons?: LessonsListRelationFilter
    class?: XOR<ClassesScalarRelationFilter, ClassesWhereInput>
    workHours?: TeacherWorkHoursListRelationFilter
  }, "id" | "supabase_id">

  export type SubjectsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: SubjectsCountOrderByAggregateInput
    _avg?: SubjectsAvgOrderByAggregateInput
    _max?: SubjectsMaxOrderByAggregateInput
    _min?: SubjectsMinOrderByAggregateInput
    _sum?: SubjectsSumOrderByAggregateInput
  }

  export type SubjectsScalarWhereWithAggregatesInput = {
    AND?: SubjectsScalarWhereWithAggregatesInput | SubjectsScalarWhereWithAggregatesInput[]
    OR?: SubjectsScalarWhereWithAggregatesInput[]
    NOT?: SubjectsScalarWhereWithAggregatesInput | SubjectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subjects"> | number
    name?: StringWithAggregatesFilter<"Subjects"> | string
    class_id?: IntWithAggregatesFilter<"Subjects"> | number
    school_year?: StringNullableWithAggregatesFilter<"Subjects"> | string | null
    coefficient?: IntNullableWithAggregatesFilter<"Subjects"> | number | null
    supabase_id?: StringNullableWithAggregatesFilter<"Subjects"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Subjects"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Subjects"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Subjects"> | boolean
  }

  export type NotesWhereInput = {
    AND?: NotesWhereInput | NotesWhereInput[]
    OR?: NotesWhereInput[]
    NOT?: NotesWhereInput | NotesWhereInput[]
    id?: IntFilter<"Notes"> | number
    student_id?: IntFilter<"Notes"> | number
    lesson_id?: IntFilter<"Notes"> | number
    value?: FloatNullableFilter<"Notes"> | number | null
    type?: StringNullableFilter<"Notes"> | string | null
    quarter?: IntNullableFilter<"Notes"> | number | null
    supabase_id?: StringNullableFilter<"Notes"> | string | null
    last_modified?: DateTimeFilter<"Notes"> | Date | string
    needs_sync?: BoolFilter<"Notes"> | boolean
    is_deleted?: BoolFilter<"Notes"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type NotesOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    quarter?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lesson?: LessonsOrderByWithRelationInput
    student?: StudentsOrderByWithRelationInput
  }

  export type NotesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: NotesWhereInput | NotesWhereInput[]
    OR?: NotesWhereInput[]
    NOT?: NotesWhereInput | NotesWhereInput[]
    student_id?: IntFilter<"Notes"> | number
    lesson_id?: IntFilter<"Notes"> | number
    value?: FloatNullableFilter<"Notes"> | number | null
    type?: StringNullableFilter<"Notes"> | string | null
    quarter?: IntNullableFilter<"Notes"> | number | null
    last_modified?: DateTimeFilter<"Notes"> | Date | string
    needs_sync?: BoolFilter<"Notes"> | boolean
    is_deleted?: BoolFilter<"Notes"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id">

  export type NotesOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    quarter?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: NotesCountOrderByAggregateInput
    _avg?: NotesAvgOrderByAggregateInput
    _max?: NotesMaxOrderByAggregateInput
    _min?: NotesMinOrderByAggregateInput
    _sum?: NotesSumOrderByAggregateInput
  }

  export type NotesScalarWhereWithAggregatesInput = {
    AND?: NotesScalarWhereWithAggregatesInput | NotesScalarWhereWithAggregatesInput[]
    OR?: NotesScalarWhereWithAggregatesInput[]
    NOT?: NotesScalarWhereWithAggregatesInput | NotesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notes"> | number
    student_id?: IntWithAggregatesFilter<"Notes"> | number
    lesson_id?: IntWithAggregatesFilter<"Notes"> | number
    value?: FloatNullableWithAggregatesFilter<"Notes"> | number | null
    type?: StringNullableWithAggregatesFilter<"Notes"> | string | null
    quarter?: IntNullableWithAggregatesFilter<"Notes"> | number | null
    supabase_id?: StringNullableWithAggregatesFilter<"Notes"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Notes"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Notes"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Notes"> | boolean
  }

  export type ParentsWhereInput = {
    AND?: ParentsWhereInput | ParentsWhereInput[]
    OR?: ParentsWhereInput[]
    NOT?: ParentsWhereInput | ParentsWhereInput[]
    id?: IntFilter<"Parents"> | number
    name?: StringNullableFilter<"Parents"> | string | null
    first_name?: StringNullableFilter<"Parents"> | string | null
    phone?: StringNullableFilter<"Parents"> | string | null
    email?: StringNullableFilter<"Parents"> | string | null
    adress?: StringNullableFilter<"Parents"> | string | null
    gender?: StringNullableFilter<"Parents"> | string | null
    profession?: StringNullableFilter<"Parents"> | string | null
    supabase_id?: StringNullableFilter<"Parents"> | string | null
    last_modified?: DateTimeFilter<"Parents"> | Date | string
    needs_sync?: BoolFilter<"Parents"> | boolean
    is_deleted?: BoolFilter<"Parents"> | boolean
    school_id?: StringNullableFilter<"Parents"> | string | null
    student_parents?: StudentParentsListRelationFilter
  }

  export type ParentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrderInput | SortOrder
    student_parents?: StudentParentsOrderByRelationAggregateInput
  }

  export type ParentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: ParentsWhereInput | ParentsWhereInput[]
    OR?: ParentsWhereInput[]
    NOT?: ParentsWhereInput | ParentsWhereInput[]
    name?: StringNullableFilter<"Parents"> | string | null
    first_name?: StringNullableFilter<"Parents"> | string | null
    phone?: StringNullableFilter<"Parents"> | string | null
    email?: StringNullableFilter<"Parents"> | string | null
    adress?: StringNullableFilter<"Parents"> | string | null
    gender?: StringNullableFilter<"Parents"> | string | null
    profession?: StringNullableFilter<"Parents"> | string | null
    last_modified?: DateTimeFilter<"Parents"> | Date | string
    needs_sync?: BoolFilter<"Parents"> | boolean
    is_deleted?: BoolFilter<"Parents"> | boolean
    school_id?: StringNullableFilter<"Parents"> | string | null
    student_parents?: StudentParentsListRelationFilter
  }, "id" | "supabase_id">

  export type ParentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrderInput | SortOrder
    _count?: ParentsCountOrderByAggregateInput
    _avg?: ParentsAvgOrderByAggregateInput
    _max?: ParentsMaxOrderByAggregateInput
    _min?: ParentsMinOrderByAggregateInput
    _sum?: ParentsSumOrderByAggregateInput
  }

  export type ParentsScalarWhereWithAggregatesInput = {
    AND?: ParentsScalarWhereWithAggregatesInput | ParentsScalarWhereWithAggregatesInput[]
    OR?: ParentsScalarWhereWithAggregatesInput[]
    NOT?: ParentsScalarWhereWithAggregatesInput | ParentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parents"> | number
    name?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    email?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    adress?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    profession?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Parents"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Parents"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Parents"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Parents"> | boolean
    school_id?: StringNullableWithAggregatesFilter<"Parents"> | string | null
  }

  export type StudentParentsWhereInput = {
    AND?: StudentParentsWhereInput | StudentParentsWhereInput[]
    OR?: StudentParentsWhereInput[]
    NOT?: StudentParentsWhereInput | StudentParentsWhereInput[]
    id?: IntFilter<"StudentParents"> | number
    student_id?: IntFilter<"StudentParents"> | number
    parent_id?: IntFilter<"StudentParents"> | number
    relation?: StringNullableFilter<"StudentParents"> | string | null
    supabase_id?: StringNullableFilter<"StudentParents"> | string | null
    last_modified?: DateTimeFilter<"StudentParents"> | Date | string
    needs_sync?: BoolFilter<"StudentParents"> | boolean
    is_deleted?: BoolFilter<"StudentParents"> | boolean
    parent?: XOR<ParentsScalarRelationFilter, ParentsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type StudentParentsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    parent?: ParentsOrderByWithRelationInput
    student?: StudentsOrderByWithRelationInput
  }

  export type StudentParentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    student_id_parent_id_unique?: StudentParentsStudent_id_parent_id_uniqueCompoundUniqueInput
    AND?: StudentParentsWhereInput | StudentParentsWhereInput[]
    OR?: StudentParentsWhereInput[]
    NOT?: StudentParentsWhereInput | StudentParentsWhereInput[]
    student_id?: IntFilter<"StudentParents"> | number
    parent_id?: IntFilter<"StudentParents"> | number
    relation?: StringNullableFilter<"StudentParents"> | string | null
    last_modified?: DateTimeFilter<"StudentParents"> | Date | string
    needs_sync?: BoolFilter<"StudentParents"> | boolean
    is_deleted?: BoolFilter<"StudentParents"> | boolean
    parent?: XOR<ParentsScalarRelationFilter, ParentsWhereInput>
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id" | "student_id_parent_id_unique">

  export type StudentParentsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: StudentParentsCountOrderByAggregateInput
    _avg?: StudentParentsAvgOrderByAggregateInput
    _max?: StudentParentsMaxOrderByAggregateInput
    _min?: StudentParentsMinOrderByAggregateInput
    _sum?: StudentParentsSumOrderByAggregateInput
  }

  export type StudentParentsScalarWhereWithAggregatesInput = {
    AND?: StudentParentsScalarWhereWithAggregatesInput | StudentParentsScalarWhereWithAggregatesInput[]
    OR?: StudentParentsScalarWhereWithAggregatesInput[]
    NOT?: StudentParentsScalarWhereWithAggregatesInput | StudentParentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentParents"> | number
    student_id?: IntWithAggregatesFilter<"StudentParents"> | number
    parent_id?: IntWithAggregatesFilter<"StudentParents"> | number
    relation?: StringNullableWithAggregatesFilter<"StudentParents"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"StudentParents"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"StudentParents"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"StudentParents"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"StudentParents"> | boolean
  }

  export type PaymentsWhereInput = {
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    id?: IntFilter<"Payments"> | number
    registration_id?: IntNullableFilter<"Payments"> | number | null
    fee_id?: IntNullableFilter<"Payments"> | number | null
    amount?: FloatNullableFilter<"Payments"> | number | null
    method?: StringNullableFilter<"Payments"> | string | null
    date?: StringNullableFilter<"Payments"> | string | null
    reference?: StringNullableFilter<"Payments"> | string | null
    emitter_id?: StringNullableFilter<"Payments"> | string | null
    supabase_id?: StringNullableFilter<"Payments"> | string | null
    last_modified?: DateTimeFilter<"Payments"> | Date | string
    needs_sync?: BoolFilter<"Payments"> | boolean
    is_deleted?: BoolFilter<"Payments"> | boolean
    fee?: XOR<FeesNullableScalarRelationFilter, FeesWhereInput> | null
    registration?: XOR<RegistrationsNullableScalarRelationFilter, RegistrationsWhereInput> | null
  }

  export type PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    registration_id?: SortOrderInput | SortOrder
    fee_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    emitter_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    fee?: FeesOrderByWithRelationInput
    registration?: RegistrationsOrderByWithRelationInput
  }

  export type PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    registration_id?: IntNullableFilter<"Payments"> | number | null
    fee_id?: IntNullableFilter<"Payments"> | number | null
    amount?: FloatNullableFilter<"Payments"> | number | null
    method?: StringNullableFilter<"Payments"> | string | null
    date?: StringNullableFilter<"Payments"> | string | null
    reference?: StringNullableFilter<"Payments"> | string | null
    emitter_id?: StringNullableFilter<"Payments"> | string | null
    last_modified?: DateTimeFilter<"Payments"> | Date | string
    needs_sync?: BoolFilter<"Payments"> | boolean
    is_deleted?: BoolFilter<"Payments"> | boolean
    fee?: XOR<FeesNullableScalarRelationFilter, FeesWhereInput> | null
    registration?: XOR<RegistrationsNullableScalarRelationFilter, RegistrationsWhereInput> | null
  }, "id" | "supabase_id">

  export type PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    registration_id?: SortOrderInput | SortOrder
    fee_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    emitter_id?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: PaymentsCountOrderByAggregateInput
    _avg?: PaymentsAvgOrderByAggregateInput
    _max?: PaymentsMaxOrderByAggregateInput
    _min?: PaymentsMinOrderByAggregateInput
    _sum?: PaymentsSumOrderByAggregateInput
  }

  export type PaymentsScalarWhereWithAggregatesInput = {
    AND?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    OR?: PaymentsScalarWhereWithAggregatesInput[]
    NOT?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payments"> | number
    registration_id?: IntNullableWithAggregatesFilter<"Payments"> | number | null
    fee_id?: IntNullableWithAggregatesFilter<"Payments"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"Payments"> | number | null
    method?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    date?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    emitter_id?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Payments"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Payments"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Payments"> | boolean
  }

  export type FeesWhereInput = {
    AND?: FeesWhereInput | FeesWhereInput[]
    OR?: FeesWhereInput[]
    NOT?: FeesWhereInput | FeesWhereInput[]
    id?: IntFilter<"Fees"> | number
    name?: StringNullableFilter<"Fees"> | string | null
    amount?: FloatNullableFilter<"Fees"> | number | null
    due_date?: StringNullableFilter<"Fees"> | string | null
    school_year?: StringNullableFilter<"Fees"> | string | null
    level?: StringNullableFilter<"Fees"> | string | null
    supabase_id?: StringNullableFilter<"Fees"> | string | null
    last_modified?: DateTimeFilter<"Fees"> | Date | string
    needs_sync?: BoolFilter<"Fees"> | boolean
    is_deleted?: BoolFilter<"Fees"> | boolean
    payments?: PaymentsListRelationFilter
  }

  export type FeesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    school_year?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    payments?: PaymentsOrderByRelationAggregateInput
  }

  export type FeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: FeesWhereInput | FeesWhereInput[]
    OR?: FeesWhereInput[]
    NOT?: FeesWhereInput | FeesWhereInput[]
    name?: StringNullableFilter<"Fees"> | string | null
    amount?: FloatNullableFilter<"Fees"> | number | null
    due_date?: StringNullableFilter<"Fees"> | string | null
    school_year?: StringNullableFilter<"Fees"> | string | null
    level?: StringNullableFilter<"Fees"> | string | null
    last_modified?: DateTimeFilter<"Fees"> | Date | string
    needs_sync?: BoolFilter<"Fees"> | boolean
    is_deleted?: BoolFilter<"Fees"> | boolean
    payments?: PaymentsListRelationFilter
  }, "id" | "supabase_id">

  export type FeesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    school_year?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: FeesCountOrderByAggregateInput
    _avg?: FeesAvgOrderByAggregateInput
    _max?: FeesMaxOrderByAggregateInput
    _min?: FeesMinOrderByAggregateInput
    _sum?: FeesSumOrderByAggregateInput
  }

  export type FeesScalarWhereWithAggregatesInput = {
    AND?: FeesScalarWhereWithAggregatesInput | FeesScalarWhereWithAggregatesInput[]
    OR?: FeesScalarWhereWithAggregatesInput[]
    NOT?: FeesScalarWhereWithAggregatesInput | FeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fees"> | number
    name?: StringNullableWithAggregatesFilter<"Fees"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"Fees"> | number | null
    due_date?: StringNullableWithAggregatesFilter<"Fees"> | string | null
    school_year?: StringNullableWithAggregatesFilter<"Fees"> | string | null
    level?: StringNullableWithAggregatesFilter<"Fees"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Fees"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Fees"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Fees"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Fees"> | boolean
  }

  export type AttendancesWhereInput = {
    AND?: AttendancesWhereInput | AttendancesWhereInput[]
    OR?: AttendancesWhereInput[]
    NOT?: AttendancesWhereInput | AttendancesWhereInput[]
    id?: IntFilter<"Attendances"> | number
    student_id?: IntFilter<"Attendances"> | number
    date?: StringNullableFilter<"Attendances"> | string | null
    state?: StringNullableFilter<"Attendances"> | string | null
    justification?: StringNullableFilter<"Attendances"> | string | null
    supabase_id?: StringNullableFilter<"Attendances"> | string | null
    last_modified?: DateTimeFilter<"Attendances"> | Date | string
    needs_sync?: BoolFilter<"Attendances"> | boolean
    is_deleted?: BoolFilter<"Attendances"> | boolean
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type AttendancesOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    student?: StudentsOrderByWithRelationInput
  }

  export type AttendancesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: AttendancesWhereInput | AttendancesWhereInput[]
    OR?: AttendancesWhereInput[]
    NOT?: AttendancesWhereInput | AttendancesWhereInput[]
    student_id?: IntFilter<"Attendances"> | number
    date?: StringNullableFilter<"Attendances"> | string | null
    state?: StringNullableFilter<"Attendances"> | string | null
    justification?: StringNullableFilter<"Attendances"> | string | null
    last_modified?: DateTimeFilter<"Attendances"> | Date | string
    needs_sync?: BoolFilter<"Attendances"> | boolean
    is_deleted?: BoolFilter<"Attendances"> | boolean
    student?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id" | "supabase_id">

  export type AttendancesOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: AttendancesCountOrderByAggregateInput
    _avg?: AttendancesAvgOrderByAggregateInput
    _max?: AttendancesMaxOrderByAggregateInput
    _min?: AttendancesMinOrderByAggregateInput
    _sum?: AttendancesSumOrderByAggregateInput
  }

  export type AttendancesScalarWhereWithAggregatesInput = {
    AND?: AttendancesScalarWhereWithAggregatesInput | AttendancesScalarWhereWithAggregatesInput[]
    OR?: AttendancesScalarWhereWithAggregatesInput[]
    NOT?: AttendancesScalarWhereWithAggregatesInput | AttendancesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attendances"> | number
    student_id?: IntWithAggregatesFilter<"Attendances"> | number
    date?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    state?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    justification?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Attendances"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Attendances"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Attendances"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Attendances"> | boolean
  }

  export type EmployeesWhereInput = {
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    id?: IntFilter<"Employees"> | number
    name?: StringNullableFilter<"Employees"> | string | null
    first_name?: StringNullableFilter<"Employees"> | string | null
    phone?: StringNullableFilter<"Employees"> | string | null
    email?: StringNullableFilter<"Employees"> | string | null
    adress?: StringNullableFilter<"Employees"> | string | null
    gender?: StringNullableFilter<"Employees"> | string | null
    job_title?: StringNullableFilter<"Employees"> | string | null
    salary?: FloatNullableFilter<"Employees"> | number | null
    matricule?: StringNullableFilter<"Employees"> | string | null
    school_id?: StringNullableFilter<"Employees"> | string | null
    password_hash?: StringNullableFilter<"Employees"> | string | null
    supabase_id?: StringNullableFilter<"Employees"> | string | null
    user_supabase_id?: StringNullableFilter<"Employees"> | string | null
    last_modified?: DateTimeFilter<"Employees"> | Date | string
    needs_sync?: BoolFilter<"Employees"> | boolean
    is_deleted?: BoolFilter<"Employees"> | boolean
    salary_payments?: SalaryPaymentsListRelationFilter
  }

  export type EmployeesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    job_title?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    salary_payments?: SalaryPaymentsOrderByRelationAggregateInput
  }

  export type EmployeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    name?: StringNullableFilter<"Employees"> | string | null
    first_name?: StringNullableFilter<"Employees"> | string | null
    phone?: StringNullableFilter<"Employees"> | string | null
    email?: StringNullableFilter<"Employees"> | string | null
    adress?: StringNullableFilter<"Employees"> | string | null
    gender?: StringNullableFilter<"Employees"> | string | null
    job_title?: StringNullableFilter<"Employees"> | string | null
    salary?: FloatNullableFilter<"Employees"> | number | null
    matricule?: StringNullableFilter<"Employees"> | string | null
    school_id?: StringNullableFilter<"Employees"> | string | null
    password_hash?: StringNullableFilter<"Employees"> | string | null
    user_supabase_id?: StringNullableFilter<"Employees"> | string | null
    last_modified?: DateTimeFilter<"Employees"> | Date | string
    needs_sync?: BoolFilter<"Employees"> | boolean
    is_deleted?: BoolFilter<"Employees"> | boolean
    salary_payments?: SalaryPaymentsListRelationFilter
  }, "id" | "supabase_id">

  export type EmployeesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    adress?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    job_title?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    school_id?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    user_supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: EmployeesCountOrderByAggregateInput
    _avg?: EmployeesAvgOrderByAggregateInput
    _max?: EmployeesMaxOrderByAggregateInput
    _min?: EmployeesMinOrderByAggregateInput
    _sum?: EmployeesSumOrderByAggregateInput
  }

  export type EmployeesScalarWhereWithAggregatesInput = {
    AND?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    OR?: EmployeesScalarWhereWithAggregatesInput[]
    NOT?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employees"> | number
    name?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    email?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    adress?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    job_title?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    salary?: FloatNullableWithAggregatesFilter<"Employees"> | number | null
    matricule?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    school_id?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    user_supabase_id?: StringNullableWithAggregatesFilter<"Employees"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Employees"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Employees"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Employees"> | boolean
  }

  export type SalaryPaymentsWhereInput = {
    AND?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    OR?: SalaryPaymentsWhereInput[]
    NOT?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    id?: IntFilter<"SalaryPayments"> | number
    employee_id?: IntFilter<"SalaryPayments"> | number
    base_salary?: FloatFilter<"SalaryPayments"> | number
    bonus_amount?: FloatFilter<"SalaryPayments"> | number
    total_amount?: FloatFilter<"SalaryPayments"> | number
    payment_date?: StringFilter<"SalaryPayments"> | string
    notes?: StringNullableFilter<"SalaryPayments"> | string | null
    supabase_id?: StringNullableFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolFilter<"SalaryPayments"> | boolean
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }

  export type SalaryPaymentsOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    employee?: EmployeesOrderByWithRelationInput
  }

  export type SalaryPaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    OR?: SalaryPaymentsWhereInput[]
    NOT?: SalaryPaymentsWhereInput | SalaryPaymentsWhereInput[]
    employee_id?: IntFilter<"SalaryPayments"> | number
    base_salary?: FloatFilter<"SalaryPayments"> | number
    bonus_amount?: FloatFilter<"SalaryPayments"> | number
    total_amount?: FloatFilter<"SalaryPayments"> | number
    payment_date?: StringFilter<"SalaryPayments"> | string
    notes?: StringNullableFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolFilter<"SalaryPayments"> | boolean
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }, "id" | "supabase_id">

  export type SalaryPaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: SalaryPaymentsCountOrderByAggregateInput
    _avg?: SalaryPaymentsAvgOrderByAggregateInput
    _max?: SalaryPaymentsMaxOrderByAggregateInput
    _min?: SalaryPaymentsMinOrderByAggregateInput
    _sum?: SalaryPaymentsSumOrderByAggregateInput
  }

  export type SalaryPaymentsScalarWhereWithAggregatesInput = {
    AND?: SalaryPaymentsScalarWhereWithAggregatesInput | SalaryPaymentsScalarWhereWithAggregatesInput[]
    OR?: SalaryPaymentsScalarWhereWithAggregatesInput[]
    NOT?: SalaryPaymentsScalarWhereWithAggregatesInput | SalaryPaymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryPayments"> | number
    employee_id?: IntWithAggregatesFilter<"SalaryPayments"> | number
    base_salary?: FloatWithAggregatesFilter<"SalaryPayments"> | number
    bonus_amount?: FloatWithAggregatesFilter<"SalaryPayments"> | number
    total_amount?: FloatWithAggregatesFilter<"SalaryPayments"> | number
    payment_date?: StringWithAggregatesFilter<"SalaryPayments"> | string
    notes?: StringNullableWithAggregatesFilter<"SalaryPayments"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"SalaryPayments"> | boolean
  }

  export type SchedulesWhereInput = {
    AND?: SchedulesWhereInput | SchedulesWhereInput[]
    OR?: SchedulesWhereInput[]
    NOT?: SchedulesWhereInput | SchedulesWhereInput[]
    id?: IntFilter<"Schedules"> | number
    lesson_id?: IntFilter<"Schedules"> | number
    day_of_week?: StringNullableFilter<"Schedules"> | string | null
    start_time?: StringNullableFilter<"Schedules"> | string | null
    end_time?: StringNullableFilter<"Schedules"> | string | null
    supabase_id?: StringNullableFilter<"Schedules"> | string | null
    last_modified?: DateTimeFilter<"Schedules"> | Date | string
    needs_sync?: BoolFilter<"Schedules"> | boolean
    is_deleted?: BoolFilter<"Schedules"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
  }

  export type SchedulesOrderByWithRelationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    lesson?: LessonsOrderByWithRelationInput
  }

  export type SchedulesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    supabase_id?: string
    AND?: SchedulesWhereInput | SchedulesWhereInput[]
    OR?: SchedulesWhereInput[]
    NOT?: SchedulesWhereInput | SchedulesWhereInput[]
    lesson_id?: IntFilter<"Schedules"> | number
    day_of_week?: StringNullableFilter<"Schedules"> | string | null
    start_time?: StringNullableFilter<"Schedules"> | string | null
    end_time?: StringNullableFilter<"Schedules"> | string | null
    last_modified?: DateTimeFilter<"Schedules"> | Date | string
    needs_sync?: BoolFilter<"Schedules"> | boolean
    is_deleted?: BoolFilter<"Schedules"> | boolean
    lesson?: XOR<LessonsScalarRelationFilter, LessonsWhereInput>
  }, "id" | "supabase_id">

  export type SchedulesOrderByWithAggregationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    supabase_id?: SortOrderInput | SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    _count?: SchedulesCountOrderByAggregateInput
    _avg?: SchedulesAvgOrderByAggregateInput
    _max?: SchedulesMaxOrderByAggregateInput
    _min?: SchedulesMinOrderByAggregateInput
    _sum?: SchedulesSumOrderByAggregateInput
  }

  export type SchedulesScalarWhereWithAggregatesInput = {
    AND?: SchedulesScalarWhereWithAggregatesInput | SchedulesScalarWhereWithAggregatesInput[]
    OR?: SchedulesScalarWhereWithAggregatesInput[]
    NOT?: SchedulesScalarWhereWithAggregatesInput | SchedulesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Schedules"> | number
    lesson_id?: IntWithAggregatesFilter<"Schedules"> | number
    day_of_week?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    start_time?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    supabase_id?: StringNullableWithAggregatesFilter<"Schedules"> | string | null
    last_modified?: DateTimeWithAggregatesFilter<"Schedules"> | Date | string
    needs_sync?: BoolWithAggregatesFilter<"Schedules"> | boolean
    is_deleted?: BoolWithAggregatesFilter<"Schedules"> | boolean
  }

  export type SettingsCreateInput = {
    schoolName?: string | null
    schoolAddress?: string | null
    loggedIn?: number | null
    userRole?: string | null
    schoolId?: string | null
    userToken?: string | null
    last_sync?: Date | string | null
  }

  export type SettingsUncheckedCreateInput = {
    id?: number
    schoolName?: string | null
    schoolAddress?: string | null
    loggedIn?: number | null
    userRole?: string | null
    schoolId?: string | null
    userToken?: string | null
    last_sync?: Date | string | null
  }

  export type SettingsUpdateInput = {
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingsCreateManyInput = {
    id?: number
    schoolName?: string | null
    schoolAddress?: string | null
    loggedIn?: number | null
    userRole?: string | null
    schoolId?: string | null
    userToken?: string | null
    last_sync?: Date | string | null
  }

  export type SettingsUpdateManyMutationInput = {
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: NullableIntFieldUpdateOperationsInput | number | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    last_sync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassesCreateInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassesCreateManyInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type ClassesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentsCreateInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    notes?: NotesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    notes?: NotesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentsCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
  }

  export type StudentsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegistrationsCreateInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutRegistrationInput
    class: ClassesCreateNestedOneWithoutRegistrationsInput
    student: StudentsCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateInput = {
    id?: number
    student_id: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type RegistrationsUpdateInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutRegistrationNestedInput
    class?: ClassesUpdateOneRequiredWithoutRegistrationsNestedInput
    student?: StudentsUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type RegistrationsCreateManyInput = {
    id?: number
    student_id: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsUpdateManyMutationInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegistrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeachersCreateInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsCreateNestedManyWithoutTeacherInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsUncheckedCreateNestedManyWithoutTeacherInput
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUpdateManyWithoutTeacherNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUncheckedUpdateManyWithoutTeacherNestedInput
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
  }

  export type TeachersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeacherWorkHoursCreateInput = {
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: SubjectsCreateNestedOneWithoutWorkHoursInput
    teacher: TeachersCreateNestedOneWithoutWorkHoursInput
  }

  export type TeacherWorkHoursUncheckedCreateInput = {
    id?: number
    teacher_id: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneWithoutWorkHoursNestedInput
    teacher?: TeachersUpdateOneRequiredWithoutWorkHoursNestedInput
  }

  export type TeacherWorkHoursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursCreateManyInput = {
    id?: number
    teacher_id: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsCreateInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsUpdateInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsCreateManyInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateManyMutationInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubjectsCreateInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutSubjectInput
    class: ClassesCreateNestedOneWithoutSubjectsInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUncheckedCreateInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutSubjectInput
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutSubjectNestedInput
    class?: ClassesUpdateOneRequiredWithoutSubjectsNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutSubjectNestedInput
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsCreateManyInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SubjectsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubjectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesCreateInput = {
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lesson: LessonsCreateNestedOneWithoutNotesInput
    student: StudentsCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateInput = {
    id?: number
    student_id: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesUpdateInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson?: LessonsUpdateOneRequiredWithoutNotesNestedInput
    student?: StudentsUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesCreateManyInput = {
    id?: number
    student_id: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesUpdateManyMutationInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParentsCreateInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
    student_parents?: StudentParentsCreateNestedManyWithoutParentInput
  }

  export type ParentsUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    student_parents?: StudentParentsUpdateManyWithoutParentNestedInput
  }

  export type ParentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    student_parents?: StudentParentsUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentsCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
  }

  export type ParentsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentParentsCreateInput = {
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    parent: ParentsCreateNestedOneWithoutStudent_parentsInput
    student: StudentsCreateNestedOneWithoutStudent_parentsInput
  }

  export type StudentParentsUncheckedCreateInput = {
    id?: number
    student_id: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsUpdateInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    parent?: ParentsUpdateOneRequiredWithoutStudent_parentsNestedInput
    student?: StudentsUpdateOneRequiredWithoutStudent_parentsNestedInput
  }

  export type StudentParentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsCreateManyInput = {
    id?: number
    student_id: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsUpdateManyMutationInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateInput = {
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    fee?: FeesCreateNestedOneWithoutPaymentsInput
    registration?: RegistrationsCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateInput = {
    id?: number
    registration_id?: number | null
    fee_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsUpdateInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    fee?: FeesUpdateOneWithoutPaymentsNestedInput
    registration?: RegistrationsUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateManyInput = {
    id?: number
    registration_id?: number | null
    fee_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsUpdateManyMutationInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeesCreateInput = {
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutFeeInput
  }

  export type FeesUncheckedCreateInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeesCreateManyInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesCreateInput = {
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    student: StudentsCreateNestedOneWithoutAttendancesInput
  }

  export type AttendancesUncheckedCreateInput = {
    id?: number
    student_id: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentsUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendancesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesCreateManyInput = {
    id?: number
    student_id: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesCreateInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: SalaryPaymentsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    salary_payments?: SalaryPaymentsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    salary_payments?: SalaryPaymentsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    salary_payments?: SalaryPaymentsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesCreateManyInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsCreateInput = {
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    employee: EmployeesCreateNestedOneWithoutSalary_paymentsInput
  }

  export type SalaryPaymentsUncheckedCreateInput = {
    id?: number
    employee_id: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUpdateInput = {
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    employee?: EmployeesUpdateOneRequiredWithoutSalary_paymentsNestedInput
  }

  export type SalaryPaymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsCreateManyInput = {
    id?: number
    employee_id: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUpdateManyMutationInput = {
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesCreateInput = {
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lesson: LessonsCreateNestedOneWithoutSchedulesInput
  }

  export type SchedulesUncheckedCreateInput = {
    id?: number
    lesson_id: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesUpdateInput = {
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson?: LessonsUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type SchedulesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesCreateManyInput = {
    id?: number
    lesson_id: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesUpdateManyMutationInput = {
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    schoolAddress?: SortOrder
    loggedIn?: SortOrder
    userRole?: SortOrder
    schoolId?: SortOrder
    userToken?: SortOrder
    last_sync?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    loggedIn?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    schoolAddress?: SortOrder
    loggedIn?: SortOrder
    userRole?: SortOrder
    schoolId?: SortOrder
    userToken?: SortOrder
    last_sync?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    schoolAddress?: SortOrder
    loggedIn?: SortOrder
    userRole?: SortOrder
    schoolId?: SortOrder
    userToken?: SortOrder
    last_sync?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    id?: SortOrder
    loggedIn?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LessonsListRelationFilter = {
    every?: LessonsWhereInput
    some?: LessonsWhereInput
    none?: LessonsWhereInput
  }

  export type RegistrationsListRelationFilter = {
    every?: RegistrationsWhereInput
    some?: RegistrationsWhereInput
    none?: RegistrationsWhereInput
  }

  export type SubjectsListRelationFilter = {
    every?: SubjectsWhereInput
    some?: SubjectsWhereInput
    none?: SubjectsWhereInput
  }

  export type LessonsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegistrationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type ClassesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClassesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type ClassesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type ClassesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AttendancesListRelationFilter = {
    every?: AttendancesWhereInput
    some?: AttendancesWhereInput
    none?: AttendancesWhereInput
  }

  export type NotesListRelationFilter = {
    every?: NotesWhereInput
    some?: NotesWhereInput
    none?: NotesWhereInput
  }

  export type StudentParentsListRelationFilter = {
    every?: StudentParentsWhereInput
    some?: StudentParentsWhereInput
    none?: StudentParentsWhereInput
  }

  export type AttendancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentParentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    genre?: SortOrder
    birth_date?: SortOrder
    picture_url?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrder
  }

  export type StudentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StudentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    genre?: SortOrder
    birth_date?: SortOrder
    picture_url?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrder
  }

  export type StudentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    genre?: SortOrder
    birth_date?: SortOrder
    picture_url?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    matricul?: SortOrder
  }

  export type StudentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaymentsListRelationFilter = {
    every?: PaymentsWhereInput
    some?: PaymentsWhereInput
    none?: PaymentsWhereInput
  }

  export type ClassesScalarRelationFilter = {
    is?: ClassesWhereInput
    isNot?: ClassesWhereInput
  }

  export type StudentsScalarRelationFilter = {
    is?: StudentsWhereInput
    isNot?: StudentsWhereInput
  }

  export type PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegistrationsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    state?: SortOrder
    registration_date?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type RegistrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
  }

  export type RegistrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    state?: SortOrder
    registration_date?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type RegistrationsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    state?: SortOrder
    registration_date?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type RegistrationsSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TeacherWorkHoursListRelationFilter = {
    every?: TeacherWorkHoursWhereInput
    some?: TeacherWorkHoursWhereInput
    none?: TeacherWorkHoursWhereInput
  }

  export type TeacherWorkHoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeachersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    password_hash?: SortOrder
    role_id?: SortOrder
    speciality?: SortOrder
    matricule?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrder
    school_id?: SortOrder
  }

  export type TeachersAvgOrderByAggregateInput = {
    id?: SortOrder
    hourlyRate?: SortOrder
  }

  export type TeachersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    password_hash?: SortOrder
    role_id?: SortOrder
    speciality?: SortOrder
    matricule?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrder
    school_id?: SortOrder
  }

  export type TeachersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    password_hash?: SortOrder
    role_id?: SortOrder
    speciality?: SortOrder
    matricule?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    hourlyRate?: SortOrder
    school_id?: SortOrder
  }

  export type TeachersSumOrderByAggregateInput = {
    id?: SortOrder
    hourlyRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SubjectsNullableScalarRelationFilter = {
    is?: SubjectsWhereInput | null
    isNot?: SubjectsWhereInput | null
  }

  export type TeachersScalarRelationFilter = {
    is?: TeachersWhereInput
    isNot?: TeachersWhereInput
  }

  export type TeacherWorkHoursCountOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    hours?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type TeacherWorkHoursAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    hours?: SortOrder
  }

  export type TeacherWorkHoursMaxOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    hours?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type TeacherWorkHoursMinOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    hours?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type TeacherWorkHoursSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    subject_id?: SortOrder
    hours?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SubjectsScalarRelationFilter = {
    is?: SubjectsWhereInput
    isNot?: SubjectsWhereInput
  }

  export type TeachersNullableScalarRelationFilter = {
    is?: TeachersWhereInput | null
    isNot?: TeachersWhereInput | null
  }

  export type SchedulesListRelationFilter = {
    every?: SchedulesWhereInput
    some?: SchedulesWhereInput
    none?: SchedulesWhereInput
  }

  export type SchedulesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonsCountOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type LessonsAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
  }

  export type LessonsMaxOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type LessonsMinOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    school_year?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type LessonsSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
  }

  export type SubjectsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    coefficient?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SubjectsAvgOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
    coefficient?: SortOrder
  }

  export type SubjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    coefficient?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SubjectsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class_id?: SortOrder
    school_year?: SortOrder
    coefficient?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SubjectsSumOrderByAggregateInput = {
    id?: SortOrder
    class_id?: SortOrder
    coefficient?: SortOrder
  }

  export type LessonsScalarRelationFilter = {
    is?: LessonsWhereInput
    isNot?: LessonsWhereInput
  }

  export type NotesCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    type?: SortOrder
    quarter?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type NotesAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    quarter?: SortOrder
  }

  export type NotesMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    type?: SortOrder
    quarter?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type NotesMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    type?: SortOrder
    quarter?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type NotesSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    value?: SortOrder
    quarter?: SortOrder
  }

  export type ParentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    profession?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrder
  }

  export type ParentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    profession?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrder
  }

  export type ParentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    profession?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
    school_id?: SortOrder
  }

  export type ParentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParentsScalarRelationFilter = {
    is?: ParentsWhereInput
    isNot?: ParentsWhereInput
  }

  export type StudentParentsStudent_id_parent_id_uniqueCompoundUniqueInput = {
    student_id: number
    parent_id: number
  }

  export type StudentParentsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type StudentParentsAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
  }

  export type StudentParentsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type StudentParentsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
    relation?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type StudentParentsSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    parent_id?: SortOrder
  }

  export type FeesNullableScalarRelationFilter = {
    is?: FeesWhereInput | null
    isNot?: FeesWhereInput | null
  }

  export type RegistrationsNullableScalarRelationFilter = {
    is?: RegistrationsWhereInput | null
    isNot?: RegistrationsWhereInput | null
  }

  export type PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    fee_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    emitter_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type PaymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    fee_id?: SortOrder
    amount?: SortOrder
  }

  export type PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    fee_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    emitter_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    fee_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    emitter_id?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type PaymentsSumOrderByAggregateInput = {
    id?: SortOrder
    registration_id?: SortOrder
    fee_id?: SortOrder
    amount?: SortOrder
  }

  export type FeesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    school_year?: SortOrder
    level?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FeesAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type FeesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    school_year?: SortOrder
    level?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FeesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    school_year?: SortOrder
    level?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type FeesSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type AttendancesCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrder
    state?: SortOrder
    justification?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type AttendancesAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
  }

  export type AttendancesMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrder
    state?: SortOrder
    justification?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type AttendancesMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    date?: SortOrder
    state?: SortOrder
    justification?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type AttendancesSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
  }

  export type SalaryPaymentsListRelationFilter = {
    every?: SalaryPaymentsWhereInput
    some?: SalaryPaymentsWhereInput
    none?: SalaryPaymentsWhereInput
  }

  export type SalaryPaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    job_title?: SortOrder
    salary?: SortOrder
    matricule?: SortOrder
    school_id?: SortOrder
    password_hash?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeesAvgOrderByAggregateInput = {
    id?: SortOrder
    salary?: SortOrder
  }

  export type EmployeesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    job_title?: SortOrder
    salary?: SortOrder
    matricule?: SortOrder
    school_id?: SortOrder
    password_hash?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    adress?: SortOrder
    gender?: SortOrder
    job_title?: SortOrder
    salary?: SortOrder
    matricule?: SortOrder
    school_id?: SortOrder
    password_hash?: SortOrder
    supabase_id?: SortOrder
    user_supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type EmployeesSumOrderByAggregateInput = {
    id?: SortOrder
    salary?: SortOrder
  }

  export type EmployeesScalarRelationFilter = {
    is?: EmployeesWhereInput
    isNot?: EmployeesWhereInput
  }

  export type SalaryPaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SalaryPaymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type SalaryPaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SalaryPaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SalaryPaymentsSumOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    base_salary?: SortOrder
    bonus_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type SchedulesCountOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SchedulesAvgOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
  }

  export type SchedulesMaxOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SchedulesMinOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    supabase_id?: SortOrder
    last_modified?: SortOrder
    needs_sync?: SortOrder
    is_deleted?: SortOrder
  }

  export type SchedulesSumOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LessonsCreateNestedManyWithoutClassInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type RegistrationsCreateNestedManyWithoutClassInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type SubjectsCreateNestedManyWithoutClassInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
  }

  export type LessonsUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type RegistrationsUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type SubjectsUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type LessonsUpdateManyWithoutClassNestedInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutClassInput | LessonsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutClassInput | LessonsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutClassInput | LessonsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type RegistrationsUpdateManyWithoutClassNestedInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutClassInput | RegistrationsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutClassInput | RegistrationsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutClassInput | RegistrationsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type SubjectsUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    upsert?: SubjectsUpsertWithWhereUniqueWithoutClassInput | SubjectsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    set?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    disconnect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    delete?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    update?: SubjectsUpdateWithWhereUniqueWithoutClassInput | SubjectsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubjectsUpdateManyWithWhereWithoutClassInput | SubjectsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
  }

  export type LessonsUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput> | LessonsCreateWithoutClassInput[] | LessonsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutClassInput | LessonsCreateOrConnectWithoutClassInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutClassInput | LessonsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: LessonsCreateManyClassInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutClassInput | LessonsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutClassInput | LessonsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type RegistrationsUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput> | RegistrationsCreateWithoutClassInput[] | RegistrationsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutClassInput | RegistrationsCreateOrConnectWithoutClassInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutClassInput | RegistrationsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: RegistrationsCreateManyClassInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutClassInput | RegistrationsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutClassInput | RegistrationsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type SubjectsUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput> | SubjectsCreateWithoutClassInput[] | SubjectsUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubjectsCreateOrConnectWithoutClassInput | SubjectsCreateOrConnectWithoutClassInput[]
    upsert?: SubjectsUpsertWithWhereUniqueWithoutClassInput | SubjectsUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubjectsCreateManyClassInputEnvelope
    set?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    disconnect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    delete?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    connect?: SubjectsWhereUniqueInput | SubjectsWhereUniqueInput[]
    update?: SubjectsUpdateWithWhereUniqueWithoutClassInput | SubjectsUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubjectsUpdateManyWithWhereWithoutClassInput | SubjectsUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
  }

  export type AttendancesCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
  }

  export type NotesCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type RegistrationsCreateNestedManyWithoutStudentInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type StudentParentsCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type AttendancesUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
  }

  export type NotesUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type RegistrationsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
  }

  export type StudentParentsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type AttendancesUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    upsert?: AttendancesUpsertWithWhereUniqueWithoutStudentInput | AttendancesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    set?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    disconnect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    delete?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    update?: AttendancesUpdateWithWhereUniqueWithoutStudentInput | AttendancesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendancesUpdateManyWithWhereWithoutStudentInput | AttendancesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
  }

  export type NotesUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutStudentInput | NotesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutStudentInput | NotesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutStudentInput | NotesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type RegistrationsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutStudentInput | RegistrationsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutStudentInput | RegistrationsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutStudentInput | RegistrationsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type StudentParentsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutStudentInput | StudentParentsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutStudentInput | StudentParentsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutStudentInput | StudentParentsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type AttendancesUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput> | AttendancesCreateWithoutStudentInput[] | AttendancesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendancesCreateOrConnectWithoutStudentInput | AttendancesCreateOrConnectWithoutStudentInput[]
    upsert?: AttendancesUpsertWithWhereUniqueWithoutStudentInput | AttendancesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendancesCreateManyStudentInputEnvelope
    set?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    disconnect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    delete?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    connect?: AttendancesWhereUniqueInput | AttendancesWhereUniqueInput[]
    update?: AttendancesUpdateWithWhereUniqueWithoutStudentInput | AttendancesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendancesUpdateManyWithWhereWithoutStudentInput | AttendancesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
  }

  export type NotesUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput> | NotesCreateWithoutStudentInput[] | NotesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutStudentInput | NotesCreateOrConnectWithoutStudentInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutStudentInput | NotesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotesCreateManyStudentInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutStudentInput | NotesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutStudentInput | NotesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type RegistrationsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput> | RegistrationsCreateWithoutStudentInput[] | RegistrationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RegistrationsCreateOrConnectWithoutStudentInput | RegistrationsCreateOrConnectWithoutStudentInput[]
    upsert?: RegistrationsUpsertWithWhereUniqueWithoutStudentInput | RegistrationsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RegistrationsCreateManyStudentInputEnvelope
    set?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    disconnect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    delete?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    connect?: RegistrationsWhereUniqueInput | RegistrationsWhereUniqueInput[]
    update?: RegistrationsUpdateWithWhereUniqueWithoutStudentInput | RegistrationsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RegistrationsUpdateManyWithWhereWithoutStudentInput | RegistrationsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
  }

  export type StudentParentsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput> | StudentParentsCreateWithoutStudentInput[] | StudentParentsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutStudentInput | StudentParentsCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutStudentInput | StudentParentsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentsCreateManyStudentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutStudentInput | StudentParentsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutStudentInput | StudentParentsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type PaymentsCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ClassesCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutRegistrationsInput
    connect?: ClassesWhereUniqueInput
  }

  export type StudentsCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutRegistrationsInput
    connect?: StudentsWhereUniqueInput
  }

  export type PaymentsUncheckedCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentsUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutRegistrationInput | PaymentsUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutRegistrationInput | PaymentsUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutRegistrationInput | PaymentsUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ClassesUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutRegistrationsInput
    upsert?: ClassesUpsertWithoutRegistrationsInput
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutRegistrationsInput, ClassesUpdateWithoutRegistrationsInput>, ClassesUncheckedUpdateWithoutRegistrationsInput>
  }

  export type StudentsUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutRegistrationsInput
    upsert?: StudentsUpsertWithoutRegistrationsInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutRegistrationsInput, StudentsUpdateWithoutRegistrationsInput>, StudentsUncheckedUpdateWithoutRegistrationsInput>
  }

  export type PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput> | PaymentsCreateWithoutRegistrationInput[] | PaymentsUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutRegistrationInput | PaymentsCreateOrConnectWithoutRegistrationInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutRegistrationInput | PaymentsUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PaymentsCreateManyRegistrationInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutRegistrationInput | PaymentsUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutRegistrationInput | PaymentsUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type LessonsCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type TeacherWorkHoursCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type LessonsUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type TeacherWorkHoursUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LessonsUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutTeacherInput | LessonsUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutTeacherInput | LessonsUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutTeacherInput | LessonsUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type TeacherWorkHoursUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput | TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type LessonsUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput> | LessonsCreateWithoutTeacherInput[] | LessonsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutTeacherInput | LessonsCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutTeacherInput | LessonsUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonsCreateManyTeacherInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutTeacherInput | LessonsUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutTeacherInput | LessonsUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput> | TeacherWorkHoursCreateWithoutTeacherInput[] | TeacherWorkHoursUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutTeacherInput | TeacherWorkHoursCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherWorkHoursCreateManyTeacherInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput | TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type SubjectsCreateNestedOneWithoutWorkHoursInput = {
    create?: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutWorkHoursInput
    connect?: SubjectsWhereUniqueInput
  }

  export type TeachersCreateNestedOneWithoutWorkHoursInput = {
    create?: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutWorkHoursInput
    connect?: TeachersWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SubjectsUpdateOneWithoutWorkHoursNestedInput = {
    create?: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutWorkHoursInput
    upsert?: SubjectsUpsertWithoutWorkHoursInput
    disconnect?: SubjectsWhereInput | boolean
    delete?: SubjectsWhereInput | boolean
    connect?: SubjectsWhereUniqueInput
    update?: XOR<XOR<SubjectsUpdateToOneWithWhereWithoutWorkHoursInput, SubjectsUpdateWithoutWorkHoursInput>, SubjectsUncheckedUpdateWithoutWorkHoursInput>
  }

  export type TeachersUpdateOneRequiredWithoutWorkHoursNestedInput = {
    create?: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutWorkHoursInput
    upsert?: TeachersUpsertWithoutWorkHoursInput
    connect?: TeachersWhereUniqueInput
    update?: XOR<XOR<TeachersUpdateToOneWithWhereWithoutWorkHoursInput, TeachersUpdateWithoutWorkHoursInput>, TeachersUncheckedUpdateWithoutWorkHoursInput>
  }

  export type SubjectsCreateNestedOneWithoutLessonsInput = {
    create?: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutLessonsInput
    connect?: SubjectsWhereUniqueInput
  }

  export type ClassesCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutLessonsInput
    connect?: ClassesWhereUniqueInput
  }

  export type TeachersCreateNestedOneWithoutLessonsInput = {
    create?: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutLessonsInput
    connect?: TeachersWhereUniqueInput
  }

  export type NotesCreateNestedManyWithoutLessonInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type SchedulesCreateNestedManyWithoutLessonInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
  }

  export type NotesUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
  }

  export type SchedulesUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
  }

  export type SubjectsUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: SubjectsCreateOrConnectWithoutLessonsInput
    upsert?: SubjectsUpsertWithoutLessonsInput
    connect?: SubjectsWhereUniqueInput
    update?: XOR<XOR<SubjectsUpdateToOneWithWhereWithoutLessonsInput, SubjectsUpdateWithoutLessonsInput>, SubjectsUncheckedUpdateWithoutLessonsInput>
  }

  export type ClassesUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutLessonsInput
    upsert?: ClassesUpsertWithoutLessonsInput
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutLessonsInput, ClassesUpdateWithoutLessonsInput>, ClassesUncheckedUpdateWithoutLessonsInput>
  }

  export type TeachersUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutLessonsInput
    upsert?: TeachersUpsertWithoutLessonsInput
    disconnect?: TeachersWhereInput | boolean
    delete?: TeachersWhereInput | boolean
    connect?: TeachersWhereUniqueInput
    update?: XOR<XOR<TeachersUpdateToOneWithWhereWithoutLessonsInput, TeachersUpdateWithoutLessonsInput>, TeachersUncheckedUpdateWithoutLessonsInput>
  }

  export type NotesUpdateManyWithoutLessonNestedInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutLessonInput | NotesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutLessonInput | NotesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutLessonInput | NotesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type SchedulesUpdateManyWithoutLessonNestedInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    upsert?: SchedulesUpsertWithWhereUniqueWithoutLessonInput | SchedulesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    set?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    disconnect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    delete?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    update?: SchedulesUpdateWithWhereUniqueWithoutLessonInput | SchedulesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: SchedulesUpdateManyWithWhereWithoutLessonInput | SchedulesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
  }

  export type NotesUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput> | NotesCreateWithoutLessonInput[] | NotesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: NotesCreateOrConnectWithoutLessonInput | NotesCreateOrConnectWithoutLessonInput[]
    upsert?: NotesUpsertWithWhereUniqueWithoutLessonInput | NotesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: NotesCreateManyLessonInputEnvelope
    set?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    disconnect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    delete?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    connect?: NotesWhereUniqueInput | NotesWhereUniqueInput[]
    update?: NotesUpdateWithWhereUniqueWithoutLessonInput | NotesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: NotesUpdateManyWithWhereWithoutLessonInput | NotesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: NotesScalarWhereInput | NotesScalarWhereInput[]
  }

  export type SchedulesUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput> | SchedulesCreateWithoutLessonInput[] | SchedulesUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: SchedulesCreateOrConnectWithoutLessonInput | SchedulesCreateOrConnectWithoutLessonInput[]
    upsert?: SchedulesUpsertWithWhereUniqueWithoutLessonInput | SchedulesUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: SchedulesCreateManyLessonInputEnvelope
    set?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    disconnect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    delete?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    connect?: SchedulesWhereUniqueInput | SchedulesWhereUniqueInput[]
    update?: SchedulesUpdateWithWhereUniqueWithoutLessonInput | SchedulesUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: SchedulesUpdateManyWithWhereWithoutLessonInput | SchedulesUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
  }

  export type LessonsCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type ClassesCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutSubjectsInput
    connect?: ClassesWhereUniqueInput
  }

  export type TeacherWorkHoursCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type LessonsUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
  }

  export type TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
  }

  export type LessonsUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutSubjectInput | LessonsUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutSubjectInput | LessonsUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutSubjectInput | LessonsUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type ClassesUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassesCreateOrConnectWithoutSubjectsInput
    upsert?: ClassesUpsertWithoutSubjectsInput
    connect?: ClassesWhereUniqueInput
    update?: XOR<XOR<ClassesUpdateToOneWithWhereWithoutSubjectsInput, ClassesUpdateWithoutSubjectsInput>, ClassesUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherWorkHoursUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput | TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type LessonsUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput> | LessonsCreateWithoutSubjectInput[] | LessonsUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LessonsCreateOrConnectWithoutSubjectInput | LessonsCreateOrConnectWithoutSubjectInput[]
    upsert?: LessonsUpsertWithWhereUniqueWithoutSubjectInput | LessonsUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LessonsCreateManySubjectInputEnvelope
    set?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    disconnect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    delete?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    connect?: LessonsWhereUniqueInput | LessonsWhereUniqueInput[]
    update?: LessonsUpdateWithWhereUniqueWithoutSubjectInput | LessonsUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LessonsUpdateManyWithWhereWithoutSubjectInput | LessonsUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput> | TeacherWorkHoursCreateWithoutSubjectInput[] | TeacherWorkHoursUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherWorkHoursCreateOrConnectWithoutSubjectInput | TeacherWorkHoursCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherWorkHoursCreateManySubjectInputEnvelope
    set?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    disconnect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    delete?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    connect?: TeacherWorkHoursWhereUniqueInput | TeacherWorkHoursWhereUniqueInput[]
    update?: TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput | TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput | TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
  }

  export type LessonsCreateNestedOneWithoutNotesInput = {
    create?: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutNotesInput
    connect?: LessonsWhereUniqueInput
  }

  export type StudentsCreateNestedOneWithoutNotesInput = {
    create?: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutNotesInput
    connect?: StudentsWhereUniqueInput
  }

  export type LessonsUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutNotesInput
    upsert?: LessonsUpsertWithoutNotesInput
    connect?: LessonsWhereUniqueInput
    update?: XOR<XOR<LessonsUpdateToOneWithWhereWithoutNotesInput, LessonsUpdateWithoutNotesInput>, LessonsUncheckedUpdateWithoutNotesInput>
  }

  export type StudentsUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutNotesInput
    upsert?: StudentsUpsertWithoutNotesInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutNotesInput, StudentsUpdateWithoutNotesInput>, StudentsUncheckedUpdateWithoutNotesInput>
  }

  export type StudentParentsCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type StudentParentsUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
  }

  export type StudentParentsUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutParentInput | StudentParentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutParentInput | StudentParentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutParentInput | StudentParentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type StudentParentsUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput> | StudentParentsCreateWithoutParentInput[] | StudentParentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentsCreateOrConnectWithoutParentInput | StudentParentsCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentsUpsertWithWhereUniqueWithoutParentInput | StudentParentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentsCreateManyParentInputEnvelope
    set?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    disconnect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    delete?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    connect?: StudentParentsWhereUniqueInput | StudentParentsWhereUniqueInput[]
    update?: StudentParentsUpdateWithWhereUniqueWithoutParentInput | StudentParentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentsUpdateManyWithWhereWithoutParentInput | StudentParentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
  }

  export type ParentsCreateNestedOneWithoutStudent_parentsInput = {
    create?: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: ParentsCreateOrConnectWithoutStudent_parentsInput
    connect?: ParentsWhereUniqueInput
  }

  export type StudentsCreateNestedOneWithoutStudent_parentsInput = {
    create?: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutStudent_parentsInput
    connect?: StudentsWhereUniqueInput
  }

  export type ParentsUpdateOneRequiredWithoutStudent_parentsNestedInput = {
    create?: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: ParentsCreateOrConnectWithoutStudent_parentsInput
    upsert?: ParentsUpsertWithoutStudent_parentsInput
    connect?: ParentsWhereUniqueInput
    update?: XOR<XOR<ParentsUpdateToOneWithWhereWithoutStudent_parentsInput, ParentsUpdateWithoutStudent_parentsInput>, ParentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type StudentsUpdateOneRequiredWithoutStudent_parentsNestedInput = {
    create?: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutStudent_parentsInput
    upsert?: StudentsUpsertWithoutStudent_parentsInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutStudent_parentsInput, StudentsUpdateWithoutStudent_parentsInput>, StudentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type FeesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<FeesCreateWithoutPaymentsInput, FeesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeesCreateOrConnectWithoutPaymentsInput
    connect?: FeesWhereUniqueInput
  }

  export type RegistrationsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: RegistrationsCreateOrConnectWithoutPaymentsInput
    connect?: RegistrationsWhereUniqueInput
  }

  export type FeesUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<FeesCreateWithoutPaymentsInput, FeesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeesCreateOrConnectWithoutPaymentsInput
    upsert?: FeesUpsertWithoutPaymentsInput
    disconnect?: FeesWhereInput | boolean
    delete?: FeesWhereInput | boolean
    connect?: FeesWhereUniqueInput
    update?: XOR<XOR<FeesUpdateToOneWithWhereWithoutPaymentsInput, FeesUpdateWithoutPaymentsInput>, FeesUncheckedUpdateWithoutPaymentsInput>
  }

  export type RegistrationsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: RegistrationsCreateOrConnectWithoutPaymentsInput
    upsert?: RegistrationsUpsertWithoutPaymentsInput
    disconnect?: RegistrationsWhereInput | boolean
    delete?: RegistrationsWhereInput | boolean
    connect?: RegistrationsWhereUniqueInput
    update?: XOR<XOR<RegistrationsUpdateToOneWithWhereWithoutPaymentsInput, RegistrationsUpdateWithoutPaymentsInput>, RegistrationsUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentsCreateNestedManyWithoutFeeInput = {
    create?: XOR<PaymentsCreateWithoutFeeInput, PaymentsUncheckedCreateWithoutFeeInput> | PaymentsCreateWithoutFeeInput[] | PaymentsUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFeeInput | PaymentsCreateOrConnectWithoutFeeInput[]
    createMany?: PaymentsCreateManyFeeInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutFeeInput = {
    create?: XOR<PaymentsCreateWithoutFeeInput, PaymentsUncheckedCreateWithoutFeeInput> | PaymentsCreateWithoutFeeInput[] | PaymentsUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFeeInput | PaymentsCreateOrConnectWithoutFeeInput[]
    createMany?: PaymentsCreateManyFeeInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentsUpdateManyWithoutFeeNestedInput = {
    create?: XOR<PaymentsCreateWithoutFeeInput, PaymentsUncheckedCreateWithoutFeeInput> | PaymentsCreateWithoutFeeInput[] | PaymentsUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFeeInput | PaymentsCreateOrConnectWithoutFeeInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutFeeInput | PaymentsUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: PaymentsCreateManyFeeInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutFeeInput | PaymentsUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutFeeInput | PaymentsUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutFeeNestedInput = {
    create?: XOR<PaymentsCreateWithoutFeeInput, PaymentsUncheckedCreateWithoutFeeInput> | PaymentsCreateWithoutFeeInput[] | PaymentsUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutFeeInput | PaymentsCreateOrConnectWithoutFeeInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutFeeInput | PaymentsUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: PaymentsCreateManyFeeInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutFeeInput | PaymentsUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutFeeInput | PaymentsUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type StudentsCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutAttendancesInput
    connect?: StudentsWhereUniqueInput
  }

  export type StudentsUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutAttendancesInput
    upsert?: StudentsUpsertWithoutAttendancesInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutAttendancesInput, StudentsUpdateWithoutAttendancesInput>, StudentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type SalaryPaymentsCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
  }

  export type SalaryPaymentsUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
  }

  export type SalaryPaymentsUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    disconnect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    delete?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    update?: SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
  }

  export type SalaryPaymentsUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput> | SalaryPaymentsCreateWithoutEmployeeInput[] | SalaryPaymentsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentsCreateOrConnectWithoutEmployeeInput | SalaryPaymentsCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentsCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    disconnect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    delete?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    connect?: SalaryPaymentsWhereUniqueInput | SalaryPaymentsWhereUniqueInput[]
    update?: SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
  }

  export type EmployeesCreateNestedOneWithoutSalary_paymentsInput = {
    create?: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutSalary_paymentsInput
    connect?: EmployeesWhereUniqueInput
  }

  export type EmployeesUpdateOneRequiredWithoutSalary_paymentsNestedInput = {
    create?: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutSalary_paymentsInput
    upsert?: EmployeesUpsertWithoutSalary_paymentsInput
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutSalary_paymentsInput, EmployeesUpdateWithoutSalary_paymentsInput>, EmployeesUncheckedUpdateWithoutSalary_paymentsInput>
  }

  export type LessonsCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutSchedulesInput
    connect?: LessonsWhereUniqueInput
  }

  export type LessonsUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LessonsCreateOrConnectWithoutSchedulesInput
    upsert?: LessonsUpsertWithoutSchedulesInput
    connect?: LessonsWhereUniqueInput
    update?: XOR<XOR<LessonsUpdateToOneWithWhereWithoutSchedulesInput, LessonsUpdateWithoutSchedulesInput>, LessonsUncheckedUpdateWithoutSchedulesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LessonsCreateWithoutClassInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutClassInput = {
    id?: number
    teacher_id?: number | null
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutClassInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput>
  }

  export type LessonsCreateManyClassInputEnvelope = {
    data: LessonsCreateManyClassInput | LessonsCreateManyClassInput[]
  }

  export type RegistrationsCreateWithoutClassInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutRegistrationInput
    student: StudentsCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateWithoutClassInput = {
    id?: number
    student_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type RegistrationsCreateOrConnectWithoutClassInput = {
    where: RegistrationsWhereUniqueInput
    create: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput>
  }

  export type RegistrationsCreateManyClassInputEnvelope = {
    data: RegistrationsCreateManyClassInput | RegistrationsCreateManyClassInput[]
  }

  export type SubjectsCreateWithoutClassInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutSubjectInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUncheckedCreateWithoutClassInput = {
    id?: number
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutSubjectInput
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsCreateOrConnectWithoutClassInput = {
    where: SubjectsWhereUniqueInput
    create: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput>
  }

  export type SubjectsCreateManyClassInputEnvelope = {
    data: SubjectsCreateManyClassInput | SubjectsCreateManyClassInput[]
  }

  export type LessonsUpsertWithWhereUniqueWithoutClassInput = {
    where: LessonsWhereUniqueInput
    update: XOR<LessonsUpdateWithoutClassInput, LessonsUncheckedUpdateWithoutClassInput>
    create: XOR<LessonsCreateWithoutClassInput, LessonsUncheckedCreateWithoutClassInput>
  }

  export type LessonsUpdateWithWhereUniqueWithoutClassInput = {
    where: LessonsWhereUniqueInput
    data: XOR<LessonsUpdateWithoutClassInput, LessonsUncheckedUpdateWithoutClassInput>
  }

  export type LessonsUpdateManyWithWhereWithoutClassInput = {
    where: LessonsScalarWhereInput
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyWithoutClassInput>
  }

  export type LessonsScalarWhereInput = {
    AND?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
    OR?: LessonsScalarWhereInput[]
    NOT?: LessonsScalarWhereInput | LessonsScalarWhereInput[]
    id?: IntFilter<"Lessons"> | number
    teacher_id?: IntNullableFilter<"Lessons"> | number | null
    class_id?: IntFilter<"Lessons"> | number
    subject_id?: IntFilter<"Lessons"> | number
    school_year?: StringNullableFilter<"Lessons"> | string | null
    supabase_id?: StringNullableFilter<"Lessons"> | string | null
    last_modified?: DateTimeFilter<"Lessons"> | Date | string
    needs_sync?: BoolFilter<"Lessons"> | boolean
    is_deleted?: BoolFilter<"Lessons"> | boolean
  }

  export type RegistrationsUpsertWithWhereUniqueWithoutClassInput = {
    where: RegistrationsWhereUniqueInput
    update: XOR<RegistrationsUpdateWithoutClassInput, RegistrationsUncheckedUpdateWithoutClassInput>
    create: XOR<RegistrationsCreateWithoutClassInput, RegistrationsUncheckedCreateWithoutClassInput>
  }

  export type RegistrationsUpdateWithWhereUniqueWithoutClassInput = {
    where: RegistrationsWhereUniqueInput
    data: XOR<RegistrationsUpdateWithoutClassInput, RegistrationsUncheckedUpdateWithoutClassInput>
  }

  export type RegistrationsUpdateManyWithWhereWithoutClassInput = {
    where: RegistrationsScalarWhereInput
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyWithoutClassInput>
  }

  export type RegistrationsScalarWhereInput = {
    AND?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
    OR?: RegistrationsScalarWhereInput[]
    NOT?: RegistrationsScalarWhereInput | RegistrationsScalarWhereInput[]
    id?: IntFilter<"Registrations"> | number
    student_id?: IntFilter<"Registrations"> | number
    class_id?: IntFilter<"Registrations"> | number
    school_year?: StringNullableFilter<"Registrations"> | string | null
    state?: StringNullableFilter<"Registrations"> | string | null
    registration_date?: StringNullableFilter<"Registrations"> | string | null
    supabase_id?: StringNullableFilter<"Registrations"> | string | null
    last_modified?: DateTimeFilter<"Registrations"> | Date | string
    needs_sync?: BoolFilter<"Registrations"> | boolean
    is_deleted?: BoolFilter<"Registrations"> | boolean
  }

  export type SubjectsUpsertWithWhereUniqueWithoutClassInput = {
    where: SubjectsWhereUniqueInput
    update: XOR<SubjectsUpdateWithoutClassInput, SubjectsUncheckedUpdateWithoutClassInput>
    create: XOR<SubjectsCreateWithoutClassInput, SubjectsUncheckedCreateWithoutClassInput>
  }

  export type SubjectsUpdateWithWhereUniqueWithoutClassInput = {
    where: SubjectsWhereUniqueInput
    data: XOR<SubjectsUpdateWithoutClassInput, SubjectsUncheckedUpdateWithoutClassInput>
  }

  export type SubjectsUpdateManyWithWhereWithoutClassInput = {
    where: SubjectsScalarWhereInput
    data: XOR<SubjectsUpdateManyMutationInput, SubjectsUncheckedUpdateManyWithoutClassInput>
  }

  export type SubjectsScalarWhereInput = {
    AND?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
    OR?: SubjectsScalarWhereInput[]
    NOT?: SubjectsScalarWhereInput | SubjectsScalarWhereInput[]
    id?: IntFilter<"Subjects"> | number
    name?: StringFilter<"Subjects"> | string
    class_id?: IntFilter<"Subjects"> | number
    school_year?: StringNullableFilter<"Subjects"> | string | null
    coefficient?: IntNullableFilter<"Subjects"> | number | null
    supabase_id?: StringNullableFilter<"Subjects"> | string | null
    last_modified?: DateTimeFilter<"Subjects"> | Date | string
    needs_sync?: BoolFilter<"Subjects"> | boolean
    is_deleted?: BoolFilter<"Subjects"> | boolean
  }

  export type AttendancesCreateWithoutStudentInput = {
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUncheckedCreateWithoutStudentInput = {
    id?: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesCreateOrConnectWithoutStudentInput = {
    where: AttendancesWhereUniqueInput
    create: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput>
  }

  export type AttendancesCreateManyStudentInputEnvelope = {
    data: AttendancesCreateManyStudentInput | AttendancesCreateManyStudentInput[]
  }

  export type NotesCreateWithoutStudentInput = {
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lesson: LessonsCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateWithoutStudentInput = {
    id?: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesCreateOrConnectWithoutStudentInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput>
  }

  export type NotesCreateManyStudentInputEnvelope = {
    data: NotesCreateManyStudentInput | NotesCreateManyStudentInput[]
  }

  export type RegistrationsCreateWithoutStudentInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsCreateNestedManyWithoutRegistrationInput
    class: ClassesCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateWithoutStudentInput = {
    id?: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    payments?: PaymentsUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type RegistrationsCreateOrConnectWithoutStudentInput = {
    where: RegistrationsWhereUniqueInput
    create: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput>
  }

  export type RegistrationsCreateManyStudentInputEnvelope = {
    data: RegistrationsCreateManyStudentInput | RegistrationsCreateManyStudentInput[]
  }

  export type StudentParentsCreateWithoutStudentInput = {
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    parent: ParentsCreateNestedOneWithoutStudent_parentsInput
  }

  export type StudentParentsUncheckedCreateWithoutStudentInput = {
    id?: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsCreateOrConnectWithoutStudentInput = {
    where: StudentParentsWhereUniqueInput
    create: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentsCreateManyStudentInputEnvelope = {
    data: StudentParentsCreateManyStudentInput | StudentParentsCreateManyStudentInput[]
  }

  export type AttendancesUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendancesWhereUniqueInput
    update: XOR<AttendancesUpdateWithoutStudentInput, AttendancesUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendancesCreateWithoutStudentInput, AttendancesUncheckedCreateWithoutStudentInput>
  }

  export type AttendancesUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendancesWhereUniqueInput
    data: XOR<AttendancesUpdateWithoutStudentInput, AttendancesUncheckedUpdateWithoutStudentInput>
  }

  export type AttendancesUpdateManyWithWhereWithoutStudentInput = {
    where: AttendancesScalarWhereInput
    data: XOR<AttendancesUpdateManyMutationInput, AttendancesUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendancesScalarWhereInput = {
    AND?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
    OR?: AttendancesScalarWhereInput[]
    NOT?: AttendancesScalarWhereInput | AttendancesScalarWhereInput[]
    id?: IntFilter<"Attendances"> | number
    student_id?: IntFilter<"Attendances"> | number
    date?: StringNullableFilter<"Attendances"> | string | null
    state?: StringNullableFilter<"Attendances"> | string | null
    justification?: StringNullableFilter<"Attendances"> | string | null
    supabase_id?: StringNullableFilter<"Attendances"> | string | null
    last_modified?: DateTimeFilter<"Attendances"> | Date | string
    needs_sync?: BoolFilter<"Attendances"> | boolean
    is_deleted?: BoolFilter<"Attendances"> | boolean
  }

  export type NotesUpsertWithWhereUniqueWithoutStudentInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutStudentInput, NotesUncheckedUpdateWithoutStudentInput>
    create: XOR<NotesCreateWithoutStudentInput, NotesUncheckedCreateWithoutStudentInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutStudentInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutStudentInput, NotesUncheckedUpdateWithoutStudentInput>
  }

  export type NotesUpdateManyWithWhereWithoutStudentInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutStudentInput>
  }

  export type NotesScalarWhereInput = {
    AND?: NotesScalarWhereInput | NotesScalarWhereInput[]
    OR?: NotesScalarWhereInput[]
    NOT?: NotesScalarWhereInput | NotesScalarWhereInput[]
    id?: IntFilter<"Notes"> | number
    student_id?: IntFilter<"Notes"> | number
    lesson_id?: IntFilter<"Notes"> | number
    value?: FloatNullableFilter<"Notes"> | number | null
    type?: StringNullableFilter<"Notes"> | string | null
    quarter?: IntNullableFilter<"Notes"> | number | null
    supabase_id?: StringNullableFilter<"Notes"> | string | null
    last_modified?: DateTimeFilter<"Notes"> | Date | string
    needs_sync?: BoolFilter<"Notes"> | boolean
    is_deleted?: BoolFilter<"Notes"> | boolean
  }

  export type RegistrationsUpsertWithWhereUniqueWithoutStudentInput = {
    where: RegistrationsWhereUniqueInput
    update: XOR<RegistrationsUpdateWithoutStudentInput, RegistrationsUncheckedUpdateWithoutStudentInput>
    create: XOR<RegistrationsCreateWithoutStudentInput, RegistrationsUncheckedCreateWithoutStudentInput>
  }

  export type RegistrationsUpdateWithWhereUniqueWithoutStudentInput = {
    where: RegistrationsWhereUniqueInput
    data: XOR<RegistrationsUpdateWithoutStudentInput, RegistrationsUncheckedUpdateWithoutStudentInput>
  }

  export type RegistrationsUpdateManyWithWhereWithoutStudentInput = {
    where: RegistrationsScalarWhereInput
    data: XOR<RegistrationsUpdateManyMutationInput, RegistrationsUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentsUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentParentsWhereUniqueInput
    update: XOR<StudentParentsUpdateWithoutStudentInput, StudentParentsUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentParentsCreateWithoutStudentInput, StudentParentsUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentsUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentParentsWhereUniqueInput
    data: XOR<StudentParentsUpdateWithoutStudentInput, StudentParentsUncheckedUpdateWithoutStudentInput>
  }

  export type StudentParentsUpdateManyWithWhereWithoutStudentInput = {
    where: StudentParentsScalarWhereInput
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentsScalarWhereInput = {
    AND?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
    OR?: StudentParentsScalarWhereInput[]
    NOT?: StudentParentsScalarWhereInput | StudentParentsScalarWhereInput[]
    id?: IntFilter<"StudentParents"> | number
    student_id?: IntFilter<"StudentParents"> | number
    parent_id?: IntFilter<"StudentParents"> | number
    relation?: StringNullableFilter<"StudentParents"> | string | null
    supabase_id?: StringNullableFilter<"StudentParents"> | string | null
    last_modified?: DateTimeFilter<"StudentParents"> | Date | string
    needs_sync?: BoolFilter<"StudentParents"> | boolean
    is_deleted?: BoolFilter<"StudentParents"> | boolean
  }

  export type PaymentsCreateWithoutRegistrationInput = {
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    fee?: FeesCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutRegistrationInput = {
    id?: number
    fee_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsCreateOrConnectWithoutRegistrationInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput>
  }

  export type PaymentsCreateManyRegistrationInputEnvelope = {
    data: PaymentsCreateManyRegistrationInput | PaymentsCreateManyRegistrationInput[]
  }

  export type ClassesCreateWithoutRegistrationsInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutRegistrationsInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutRegistrationsInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
  }

  export type StudentsCreateWithoutRegistrationsInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    notes?: NotesCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutRegistrationsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutRegistrationsInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
  }

  export type PaymentsUpsertWithWhereUniqueWithoutRegistrationInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutRegistrationInput, PaymentsUncheckedUpdateWithoutRegistrationInput>
    create: XOR<PaymentsCreateWithoutRegistrationInput, PaymentsUncheckedCreateWithoutRegistrationInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutRegistrationInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutRegistrationInput, PaymentsUncheckedUpdateWithoutRegistrationInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutRegistrationInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutRegistrationInput>
  }

  export type PaymentsScalarWhereInput = {
    AND?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    OR?: PaymentsScalarWhereInput[]
    NOT?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    id?: IntFilter<"Payments"> | number
    registration_id?: IntNullableFilter<"Payments"> | number | null
    fee_id?: IntNullableFilter<"Payments"> | number | null
    amount?: FloatNullableFilter<"Payments"> | number | null
    method?: StringNullableFilter<"Payments"> | string | null
    date?: StringNullableFilter<"Payments"> | string | null
    reference?: StringNullableFilter<"Payments"> | string | null
    emitter_id?: StringNullableFilter<"Payments"> | string | null
    supabase_id?: StringNullableFilter<"Payments"> | string | null
    last_modified?: DateTimeFilter<"Payments"> | Date | string
    needs_sync?: BoolFilter<"Payments"> | boolean
    is_deleted?: BoolFilter<"Payments"> | boolean
  }

  export type ClassesUpsertWithoutRegistrationsInput = {
    update: XOR<ClassesUpdateWithoutRegistrationsInput, ClassesUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<ClassesCreateWithoutRegistrationsInput, ClassesUncheckedCreateWithoutRegistrationsInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutRegistrationsInput, ClassesUncheckedUpdateWithoutRegistrationsInput>
  }

  export type ClassesUpdateWithoutRegistrationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentsUpsertWithoutRegistrationsInput = {
    update: XOR<StudentsUpdateWithoutRegistrationsInput, StudentsUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<StudentsCreateWithoutRegistrationsInput, StudentsUncheckedCreateWithoutRegistrationsInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutRegistrationsInput, StudentsUncheckedUpdateWithoutRegistrationsInput>
  }

  export type StudentsUpdateWithoutRegistrationsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    notes?: NotesUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LessonsCreateWithoutTeacherInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutTeacherInput = {
    id?: number
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutTeacherInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput>
  }

  export type LessonsCreateManyTeacherInputEnvelope = {
    data: LessonsCreateManyTeacherInput | LessonsCreateManyTeacherInput[]
  }

  export type TeacherWorkHoursCreateWithoutTeacherInput = {
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject?: SubjectsCreateNestedOneWithoutWorkHoursInput
  }

  export type TeacherWorkHoursUncheckedCreateWithoutTeacherInput = {
    id?: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateOrConnectWithoutTeacherInput = {
    where: TeacherWorkHoursWhereUniqueInput
    create: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherWorkHoursCreateManyTeacherInputEnvelope = {
    data: TeacherWorkHoursCreateManyTeacherInput | TeacherWorkHoursCreateManyTeacherInput[]
  }

  export type LessonsUpsertWithWhereUniqueWithoutTeacherInput = {
    where: LessonsWhereUniqueInput
    update: XOR<LessonsUpdateWithoutTeacherInput, LessonsUncheckedUpdateWithoutTeacherInput>
    create: XOR<LessonsCreateWithoutTeacherInput, LessonsUncheckedCreateWithoutTeacherInput>
  }

  export type LessonsUpdateWithWhereUniqueWithoutTeacherInput = {
    where: LessonsWhereUniqueInput
    data: XOR<LessonsUpdateWithoutTeacherInput, LessonsUncheckedUpdateWithoutTeacherInput>
  }

  export type LessonsUpdateManyWithWhereWithoutTeacherInput = {
    where: LessonsScalarWhereInput
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherWorkHoursUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherWorkHoursWhereUniqueInput
    update: XOR<TeacherWorkHoursUpdateWithoutTeacherInput, TeacherWorkHoursUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherWorkHoursCreateWithoutTeacherInput, TeacherWorkHoursUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherWorkHoursUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherWorkHoursWhereUniqueInput
    data: XOR<TeacherWorkHoursUpdateWithoutTeacherInput, TeacherWorkHoursUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherWorkHoursUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherWorkHoursScalarWhereInput
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherWorkHoursScalarWhereInput = {
    AND?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
    OR?: TeacherWorkHoursScalarWhereInput[]
    NOT?: TeacherWorkHoursScalarWhereInput | TeacherWorkHoursScalarWhereInput[]
    id?: IntFilter<"TeacherWorkHours"> | number
    teacher_id?: IntFilter<"TeacherWorkHours"> | number
    subject_id?: IntNullableFilter<"TeacherWorkHours"> | number | null
    date?: StringNullableFilter<"TeacherWorkHours"> | string | null
    start_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    end_time?: StringNullableFilter<"TeacherWorkHours"> | string | null
    hours?: FloatFilter<"TeacherWorkHours"> | number
    notes?: StringNullableFilter<"TeacherWorkHours"> | string | null
    supabase_id?: StringNullableFilter<"TeacherWorkHours"> | string | null
    last_modified?: DateTimeFilter<"TeacherWorkHours"> | Date | string
    needs_sync?: BoolFilter<"TeacherWorkHours"> | boolean
    is_deleted?: BoolFilter<"TeacherWorkHours"> | boolean
  }

  export type SubjectsCreateWithoutWorkHoursInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutSubjectInput
    class: ClassesCreateNestedOneWithoutSubjectsInput
  }

  export type SubjectsUncheckedCreateWithoutWorkHoursInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsCreateOrConnectWithoutWorkHoursInput = {
    where: SubjectsWhereUniqueInput
    create: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
  }

  export type TeachersCreateWithoutWorkHoursInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUncheckedCreateWithoutWorkHoursInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    lessons?: LessonsUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeachersCreateOrConnectWithoutWorkHoursInput = {
    where: TeachersWhereUniqueInput
    create: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
  }

  export type SubjectsUpsertWithoutWorkHoursInput = {
    update: XOR<SubjectsUpdateWithoutWorkHoursInput, SubjectsUncheckedUpdateWithoutWorkHoursInput>
    create: XOR<SubjectsCreateWithoutWorkHoursInput, SubjectsUncheckedCreateWithoutWorkHoursInput>
    where?: SubjectsWhereInput
  }

  export type SubjectsUpdateToOneWithWhereWithoutWorkHoursInput = {
    where?: SubjectsWhereInput
    data: XOR<SubjectsUpdateWithoutWorkHoursInput, SubjectsUncheckedUpdateWithoutWorkHoursInput>
  }

  export type SubjectsUpdateWithoutWorkHoursInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutSubjectNestedInput
    class?: ClassesUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type SubjectsUncheckedUpdateWithoutWorkHoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeachersUpsertWithoutWorkHoursInput = {
    update: XOR<TeachersUpdateWithoutWorkHoursInput, TeachersUncheckedUpdateWithoutWorkHoursInput>
    create: XOR<TeachersCreateWithoutWorkHoursInput, TeachersUncheckedCreateWithoutWorkHoursInput>
    where?: TeachersWhereInput
  }

  export type TeachersUpdateToOneWithWhereWithoutWorkHoursInput = {
    where?: TeachersWhereInput
    data: XOR<TeachersUpdateWithoutWorkHoursInput, TeachersUncheckedUpdateWithoutWorkHoursInput>
  }

  export type TeachersUpdateWithoutWorkHoursInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersUncheckedUpdateWithoutWorkHoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    lessons?: LessonsUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SubjectsCreateWithoutLessonsInput = {
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class: ClassesCreateNestedOneWithoutSubjectsInput
    workHours?: TeacherWorkHoursCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsUncheckedCreateWithoutLessonsInput = {
    id?: number
    name: string
    class_id: number
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectsCreateOrConnectWithoutLessonsInput = {
    where: SubjectsWhereUniqueInput
    create: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
  }

  export type ClassesCreateWithoutLessonsInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
    subjects?: SubjectsCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutLessonsInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
    subjects?: SubjectsUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutLessonsInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
  }

  export type TeachersCreateWithoutLessonsInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    workHours?: TeacherWorkHoursCreateNestedManyWithoutTeacherInput
  }

  export type TeachersUncheckedCreateWithoutLessonsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    password_hash?: string | null
    role_id?: string | null
    speciality?: string | null
    matricule?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    hourlyRate?: number | null
    school_id?: string | null
    workHours?: TeacherWorkHoursUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeachersCreateOrConnectWithoutLessonsInput = {
    where: TeachersWhereUniqueInput
    create: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
  }

  export type NotesCreateWithoutLessonInput = {
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    student: StudentsCreateNestedOneWithoutNotesInput
  }

  export type NotesUncheckedCreateWithoutLessonInput = {
    id?: number
    student_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesCreateOrConnectWithoutLessonInput = {
    where: NotesWhereUniqueInput
    create: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput>
  }

  export type NotesCreateManyLessonInputEnvelope = {
    data: NotesCreateManyLessonInput | NotesCreateManyLessonInput[]
  }

  export type SchedulesCreateWithoutLessonInput = {
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesUncheckedCreateWithoutLessonInput = {
    id?: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesCreateOrConnectWithoutLessonInput = {
    where: SchedulesWhereUniqueInput
    create: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput>
  }

  export type SchedulesCreateManyLessonInputEnvelope = {
    data: SchedulesCreateManyLessonInput | SchedulesCreateManyLessonInput[]
  }

  export type SubjectsUpsertWithoutLessonsInput = {
    update: XOR<SubjectsUpdateWithoutLessonsInput, SubjectsUncheckedUpdateWithoutLessonsInput>
    create: XOR<SubjectsCreateWithoutLessonsInput, SubjectsUncheckedCreateWithoutLessonsInput>
    where?: SubjectsWhereInput
  }

  export type SubjectsUpdateToOneWithWhereWithoutLessonsInput = {
    where?: SubjectsWhereInput
    data: XOR<SubjectsUpdateWithoutLessonsInput, SubjectsUncheckedUpdateWithoutLessonsInput>
  }

  export type SubjectsUpdateWithoutLessonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneRequiredWithoutSubjectsNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ClassesUpsertWithoutLessonsInput = {
    update: XOR<ClassesUpdateWithoutLessonsInput, ClassesUncheckedUpdateWithoutLessonsInput>
    create: XOR<ClassesCreateWithoutLessonsInput, ClassesUncheckedCreateWithoutLessonsInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutLessonsInput, ClassesUncheckedUpdateWithoutLessonsInput>
  }

  export type ClassesUpdateWithoutLessonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
    subjects?: SubjectsUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeachersUpsertWithoutLessonsInput = {
    update: XOR<TeachersUpdateWithoutLessonsInput, TeachersUncheckedUpdateWithoutLessonsInput>
    create: XOR<TeachersCreateWithoutLessonsInput, TeachersUncheckedCreateWithoutLessonsInput>
    where?: TeachersWhereInput
  }

  export type TeachersUpdateToOneWithWhereWithoutLessonsInput = {
    where?: TeachersWhereInput
    data: XOR<TeachersUpdateWithoutLessonsInput, TeachersUncheckedUpdateWithoutLessonsInput>
  }

  export type TeachersUpdateWithoutLessonsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    workHours?: TeacherWorkHoursUpdateManyWithoutTeacherNestedInput
  }

  export type TeachersUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role_id?: NullableStringFieldUpdateOperationsInput | string | null
    speciality?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type NotesUpsertWithWhereUniqueWithoutLessonInput = {
    where: NotesWhereUniqueInput
    update: XOR<NotesUpdateWithoutLessonInput, NotesUncheckedUpdateWithoutLessonInput>
    create: XOR<NotesCreateWithoutLessonInput, NotesUncheckedCreateWithoutLessonInput>
  }

  export type NotesUpdateWithWhereUniqueWithoutLessonInput = {
    where: NotesWhereUniqueInput
    data: XOR<NotesUpdateWithoutLessonInput, NotesUncheckedUpdateWithoutLessonInput>
  }

  export type NotesUpdateManyWithWhereWithoutLessonInput = {
    where: NotesScalarWhereInput
    data: XOR<NotesUpdateManyMutationInput, NotesUncheckedUpdateManyWithoutLessonInput>
  }

  export type SchedulesUpsertWithWhereUniqueWithoutLessonInput = {
    where: SchedulesWhereUniqueInput
    update: XOR<SchedulesUpdateWithoutLessonInput, SchedulesUncheckedUpdateWithoutLessonInput>
    create: XOR<SchedulesCreateWithoutLessonInput, SchedulesUncheckedCreateWithoutLessonInput>
  }

  export type SchedulesUpdateWithWhereUniqueWithoutLessonInput = {
    where: SchedulesWhereUniqueInput
    data: XOR<SchedulesUpdateWithoutLessonInput, SchedulesUncheckedUpdateWithoutLessonInput>
  }

  export type SchedulesUpdateManyWithWhereWithoutLessonInput = {
    where: SchedulesScalarWhereInput
    data: XOR<SchedulesUpdateManyMutationInput, SchedulesUncheckedUpdateManyWithoutLessonInput>
  }

  export type SchedulesScalarWhereInput = {
    AND?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
    OR?: SchedulesScalarWhereInput[]
    NOT?: SchedulesScalarWhereInput | SchedulesScalarWhereInput[]
    id?: IntFilter<"Schedules"> | number
    lesson_id?: IntFilter<"Schedules"> | number
    day_of_week?: StringNullableFilter<"Schedules"> | string | null
    start_time?: StringNullableFilter<"Schedules"> | string | null
    end_time?: StringNullableFilter<"Schedules"> | string | null
    supabase_id?: StringNullableFilter<"Schedules"> | string | null
    last_modified?: DateTimeFilter<"Schedules"> | Date | string
    needs_sync?: BoolFilter<"Schedules"> | boolean
    is_deleted?: BoolFilter<"Schedules"> | boolean
  }

  export type LessonsCreateWithoutSubjectInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutSubjectInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutSubjectInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput>
  }

  export type LessonsCreateManySubjectInputEnvelope = {
    data: LessonsCreateManySubjectInput | LessonsCreateManySubjectInput[]
  }

  export type ClassesCreateWithoutSubjectsInput = {
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsCreateNestedManyWithoutClassInput
    registrations?: RegistrationsCreateNestedManyWithoutClassInput
  }

  export type ClassesUncheckedCreateWithoutSubjectsInput = {
    id?: number
    name: string
    level?: string | null
    school_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    lessons?: LessonsUncheckedCreateNestedManyWithoutClassInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassesCreateOrConnectWithoutSubjectsInput = {
    where: ClassesWhereUniqueInput
    create: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
  }

  export type TeacherWorkHoursCreateWithoutSubjectInput = {
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    teacher: TeachersCreateNestedOneWithoutWorkHoursInput
  }

  export type TeacherWorkHoursUncheckedCreateWithoutSubjectInput = {
    id?: number
    teacher_id: number
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateOrConnectWithoutSubjectInput = {
    where: TeacherWorkHoursWhereUniqueInput
    create: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherWorkHoursCreateManySubjectInputEnvelope = {
    data: TeacherWorkHoursCreateManySubjectInput | TeacherWorkHoursCreateManySubjectInput[]
  }

  export type LessonsUpsertWithWhereUniqueWithoutSubjectInput = {
    where: LessonsWhereUniqueInput
    update: XOR<LessonsUpdateWithoutSubjectInput, LessonsUncheckedUpdateWithoutSubjectInput>
    create: XOR<LessonsCreateWithoutSubjectInput, LessonsUncheckedCreateWithoutSubjectInput>
  }

  export type LessonsUpdateWithWhereUniqueWithoutSubjectInput = {
    where: LessonsWhereUniqueInput
    data: XOR<LessonsUpdateWithoutSubjectInput, LessonsUncheckedUpdateWithoutSubjectInput>
  }

  export type LessonsUpdateManyWithWhereWithoutSubjectInput = {
    where: LessonsScalarWhereInput
    data: XOR<LessonsUpdateManyMutationInput, LessonsUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ClassesUpsertWithoutSubjectsInput = {
    update: XOR<ClassesUpdateWithoutSubjectsInput, ClassesUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ClassesCreateWithoutSubjectsInput, ClassesUncheckedCreateWithoutSubjectsInput>
    where?: ClassesWhereInput
  }

  export type ClassesUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: ClassesWhereInput
    data: XOR<ClassesUpdateWithoutSubjectsInput, ClassesUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassesUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUpdateManyWithoutClassNestedInput
  }

  export type ClassesUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutClassNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeacherWorkHoursUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TeacherWorkHoursWhereUniqueInput
    update: XOR<TeacherWorkHoursUpdateWithoutSubjectInput, TeacherWorkHoursUncheckedUpdateWithoutSubjectInput>
    create: XOR<TeacherWorkHoursCreateWithoutSubjectInput, TeacherWorkHoursUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherWorkHoursUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TeacherWorkHoursWhereUniqueInput
    data: XOR<TeacherWorkHoursUpdateWithoutSubjectInput, TeacherWorkHoursUncheckedUpdateWithoutSubjectInput>
  }

  export type TeacherWorkHoursUpdateManyWithWhereWithoutSubjectInput = {
    where: TeacherWorkHoursScalarWhereInput
    data: XOR<TeacherWorkHoursUpdateManyMutationInput, TeacherWorkHoursUncheckedUpdateManyWithoutSubjectInput>
  }

  export type LessonsCreateWithoutNotesInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    schedules?: SchedulesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutNotesInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    schedules?: SchedulesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutNotesInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
  }

  export type StudentsCreateWithoutNotesInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutNotesInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutNotesInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
  }

  export type LessonsUpsertWithoutNotesInput = {
    update: XOR<LessonsUpdateWithoutNotesInput, LessonsUncheckedUpdateWithoutNotesInput>
    create: XOR<LessonsCreateWithoutNotesInput, LessonsUncheckedCreateWithoutNotesInput>
    where?: LessonsWhereInput
  }

  export type LessonsUpdateToOneWithWhereWithoutNotesInput = {
    where?: LessonsWhereInput
    data: XOR<LessonsUpdateWithoutNotesInput, LessonsUncheckedUpdateWithoutNotesInput>
  }

  export type LessonsUpdateWithoutNotesInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type StudentsUpsertWithoutNotesInput = {
    update: XOR<StudentsUpdateWithoutNotesInput, StudentsUncheckedUpdateWithoutNotesInput>
    create: XOR<StudentsCreateWithoutNotesInput, StudentsUncheckedCreateWithoutNotesInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutNotesInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutNotesInput, StudentsUncheckedUpdateWithoutNotesInput>
  }

  export type StudentsUpdateWithoutNotesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentParentsCreateWithoutParentInput = {
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    student: StudentsCreateNestedOneWithoutStudent_parentsInput
  }

  export type StudentParentsUncheckedCreateWithoutParentInput = {
    id?: number
    student_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsCreateOrConnectWithoutParentInput = {
    where: StudentParentsWhereUniqueInput
    create: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput>
  }

  export type StudentParentsCreateManyParentInputEnvelope = {
    data: StudentParentsCreateManyParentInput | StudentParentsCreateManyParentInput[]
  }

  export type StudentParentsUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentParentsWhereUniqueInput
    update: XOR<StudentParentsUpdateWithoutParentInput, StudentParentsUncheckedUpdateWithoutParentInput>
    create: XOR<StudentParentsCreateWithoutParentInput, StudentParentsUncheckedCreateWithoutParentInput>
  }

  export type StudentParentsUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentParentsWhereUniqueInput
    data: XOR<StudentParentsUpdateWithoutParentInput, StudentParentsUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentsUpdateManyWithWhereWithoutParentInput = {
    where: StudentParentsScalarWhereInput
    data: XOR<StudentParentsUpdateManyMutationInput, StudentParentsUncheckedUpdateManyWithoutParentInput>
  }

  export type ParentsCreateWithoutStudent_parentsInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
  }

  export type ParentsUncheckedCreateWithoutStudent_parentsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    profession?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    school_id?: string | null
  }

  export type ParentsCreateOrConnectWithoutStudent_parentsInput = {
    where: ParentsWhereUniqueInput
    create: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
  }

  export type StudentsCreateWithoutStudent_parentsInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesCreateNestedManyWithoutStudentInput
    notes?: NotesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutStudent_parentsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    attendances?: AttendancesUncheckedCreateNestedManyWithoutStudentInput
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutStudent_parentsInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
  }

  export type ParentsUpsertWithoutStudent_parentsInput = {
    update: XOR<ParentsUpdateWithoutStudent_parentsInput, ParentsUncheckedUpdateWithoutStudent_parentsInput>
    create: XOR<ParentsCreateWithoutStudent_parentsInput, ParentsUncheckedCreateWithoutStudent_parentsInput>
    where?: ParentsWhereInput
  }

  export type ParentsUpdateToOneWithWhereWithoutStudent_parentsInput = {
    where?: ParentsWhereInput
    data: XOR<ParentsUpdateWithoutStudent_parentsInput, ParentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type ParentsUpdateWithoutStudent_parentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentsUncheckedUpdateWithoutStudent_parentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentsUpsertWithoutStudent_parentsInput = {
    update: XOR<StudentsUpdateWithoutStudent_parentsInput, StudentsUncheckedUpdateWithoutStudent_parentsInput>
    create: XOR<StudentsCreateWithoutStudent_parentsInput, StudentsUncheckedCreateWithoutStudent_parentsInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutStudent_parentsInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutStudent_parentsInput, StudentsUncheckedUpdateWithoutStudent_parentsInput>
  }

  export type StudentsUpdateWithoutStudent_parentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUpdateManyWithoutStudentNestedInput
    notes?: NotesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutStudent_parentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendancesUncheckedUpdateManyWithoutStudentNestedInput
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type FeesCreateWithoutPaymentsInput = {
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeesUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name?: string | null
    amount?: number | null
    due_date?: string | null
    school_year?: string | null
    level?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type FeesCreateOrConnectWithoutPaymentsInput = {
    where: FeesWhereUniqueInput
    create: XOR<FeesCreateWithoutPaymentsInput, FeesUncheckedCreateWithoutPaymentsInput>
  }

  export type RegistrationsCreateWithoutPaymentsInput = {
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    class: ClassesCreateNestedOneWithoutRegistrationsInput
    student: StudentsCreateNestedOneWithoutRegistrationsInput
  }

  export type RegistrationsUncheckedCreateWithoutPaymentsInput = {
    id?: number
    student_id: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsCreateOrConnectWithoutPaymentsInput = {
    where: RegistrationsWhereUniqueInput
    create: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
  }

  export type FeesUpsertWithoutPaymentsInput = {
    update: XOR<FeesUpdateWithoutPaymentsInput, FeesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<FeesCreateWithoutPaymentsInput, FeesUncheckedCreateWithoutPaymentsInput>
    where?: FeesWhereInput
  }

  export type FeesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: FeesWhereInput
    data: XOR<FeesUpdateWithoutPaymentsInput, FeesUncheckedUpdateWithoutPaymentsInput>
  }

  export type FeesUpdateWithoutPaymentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeesUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    due_date?: NullableStringFieldUpdateOperationsInput | string | null
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegistrationsUpsertWithoutPaymentsInput = {
    update: XOR<RegistrationsUpdateWithoutPaymentsInput, RegistrationsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<RegistrationsCreateWithoutPaymentsInput, RegistrationsUncheckedCreateWithoutPaymentsInput>
    where?: RegistrationsWhereInput
  }

  export type RegistrationsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: RegistrationsWhereInput
    data: XOR<RegistrationsUpdateWithoutPaymentsInput, RegistrationsUncheckedUpdateWithoutPaymentsInput>
  }

  export type RegistrationsUpdateWithoutPaymentsInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneRequiredWithoutRegistrationsNestedInput
    student?: StudentsUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateWithoutFeeInput = {
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    registration?: RegistrationsCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutFeeInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsCreateOrConnectWithoutFeeInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutFeeInput, PaymentsUncheckedCreateWithoutFeeInput>
  }

  export type PaymentsCreateManyFeeInputEnvelope = {
    data: PaymentsCreateManyFeeInput | PaymentsCreateManyFeeInput[]
  }

  export type PaymentsUpsertWithWhereUniqueWithoutFeeInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutFeeInput, PaymentsUncheckedUpdateWithoutFeeInput>
    create: XOR<PaymentsCreateWithoutFeeInput, PaymentsUncheckedCreateWithoutFeeInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutFeeInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutFeeInput, PaymentsUncheckedUpdateWithoutFeeInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutFeeInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutFeeInput>
  }

  export type StudentsCreateWithoutAttendancesInput = {
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    notes?: NotesCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsCreateNestedManyWithoutStudentInput
  }

  export type StudentsUncheckedCreateWithoutAttendancesInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    genre?: string | null
    birth_date?: string | null
    picture_url?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    matricul?: string | null
    notes?: NotesUncheckedCreateNestedManyWithoutStudentInput
    registrations?: RegistrationsUncheckedCreateNestedManyWithoutStudentInput
    student_parents?: StudentParentsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentsCreateOrConnectWithoutAttendancesInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
  }

  export type StudentsUpsertWithoutAttendancesInput = {
    update: XOR<StudentsUpdateWithoutAttendancesInput, StudentsUncheckedUpdateWithoutAttendancesInput>
    create: XOR<StudentsCreateWithoutAttendancesInput, StudentsUncheckedCreateWithoutAttendancesInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutAttendancesInput, StudentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentsUpdateWithoutAttendancesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NotesUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUpdateManyWithoutStudentNestedInput
  }

  export type StudentsUncheckedUpdateWithoutAttendancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableStringFieldUpdateOperationsInput | string | null
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    matricul?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NotesUncheckedUpdateManyWithoutStudentNestedInput
    registrations?: RegistrationsUncheckedUpdateManyWithoutStudentNestedInput
    student_parents?: StudentParentsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SalaryPaymentsCreateWithoutEmployeeInput = {
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUncheckedCreateWithoutEmployeeInput = {
    id?: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsCreateOrConnectWithoutEmployeeInput = {
    where: SalaryPaymentsWhereUniqueInput
    create: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentsCreateManyEmployeeInputEnvelope = {
    data: SalaryPaymentsCreateManyEmployeeInput | SalaryPaymentsCreateManyEmployeeInput[]
  }

  export type SalaryPaymentsUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentsWhereUniqueInput
    update: XOR<SalaryPaymentsUpdateWithoutEmployeeInput, SalaryPaymentsUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryPaymentsCreateWithoutEmployeeInput, SalaryPaymentsUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentsUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentsWhereUniqueInput
    data: XOR<SalaryPaymentsUpdateWithoutEmployeeInput, SalaryPaymentsUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryPaymentsUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryPaymentsScalarWhereInput
    data: XOR<SalaryPaymentsUpdateManyMutationInput, SalaryPaymentsUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SalaryPaymentsScalarWhereInput = {
    AND?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
    OR?: SalaryPaymentsScalarWhereInput[]
    NOT?: SalaryPaymentsScalarWhereInput | SalaryPaymentsScalarWhereInput[]
    id?: IntFilter<"SalaryPayments"> | number
    employee_id?: IntFilter<"SalaryPayments"> | number
    base_salary?: FloatFilter<"SalaryPayments"> | number
    bonus_amount?: FloatFilter<"SalaryPayments"> | number
    total_amount?: FloatFilter<"SalaryPayments"> | number
    payment_date?: StringFilter<"SalaryPayments"> | string
    notes?: StringNullableFilter<"SalaryPayments"> | string | null
    supabase_id?: StringNullableFilter<"SalaryPayments"> | string | null
    last_modified?: DateTimeFilter<"SalaryPayments"> | Date | string
    needs_sync?: BoolFilter<"SalaryPayments"> | boolean
    is_deleted?: BoolFilter<"SalaryPayments"> | boolean
  }

  export type EmployeesCreateWithoutSalary_paymentsInput = {
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeesUncheckedCreateWithoutSalary_paymentsInput = {
    id?: number
    name?: string | null
    first_name?: string | null
    phone?: string | null
    email?: string | null
    adress?: string | null
    gender?: string | null
    job_title?: string | null
    salary?: number | null
    matricule?: string | null
    school_id?: string | null
    password_hash?: string | null
    supabase_id?: string | null
    user_supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type EmployeesCreateOrConnectWithoutSalary_paymentsInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
  }

  export type EmployeesUpsertWithoutSalary_paymentsInput = {
    update: XOR<EmployeesUpdateWithoutSalary_paymentsInput, EmployeesUncheckedUpdateWithoutSalary_paymentsInput>
    create: XOR<EmployeesCreateWithoutSalary_paymentsInput, EmployeesUncheckedCreateWithoutSalary_paymentsInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutSalary_paymentsInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutSalary_paymentsInput, EmployeesUncheckedUpdateWithoutSalary_paymentsInput>
  }

  export type EmployeesUpdateWithoutSalary_paymentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesUncheckedUpdateWithoutSalary_paymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    job_title?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    school_id?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsCreateWithoutSchedulesInput = {
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    subject: SubjectsCreateNestedOneWithoutLessonsInput
    class: ClassesCreateNestedOneWithoutLessonsInput
    teacher?: TeachersCreateNestedOneWithoutLessonsInput
    notes?: NotesCreateNestedManyWithoutLessonInput
  }

  export type LessonsUncheckedCreateWithoutSchedulesInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
    notes?: NotesUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonsCreateOrConnectWithoutSchedulesInput = {
    where: LessonsWhereUniqueInput
    create: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
  }

  export type LessonsUpsertWithoutSchedulesInput = {
    update: XOR<LessonsUpdateWithoutSchedulesInput, LessonsUncheckedUpdateWithoutSchedulesInput>
    create: XOR<LessonsCreateWithoutSchedulesInput, LessonsUncheckedCreateWithoutSchedulesInput>
    where?: LessonsWhereInput
  }

  export type LessonsUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: LessonsWhereInput
    data: XOR<LessonsUpdateWithoutSchedulesInput, LessonsUncheckedUpdateWithoutSchedulesInput>
  }

  export type LessonsUpdateWithoutSchedulesInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsCreateManyClassInput = {
    id?: number
    teacher_id?: number | null
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsCreateManyClassInput = {
    id?: number
    student_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SubjectsCreateManyClassInput = {
    id?: number
    name: string
    school_year?: string | null
    coefficient?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateWithoutClassInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegistrationsUpdateWithoutClassInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutRegistrationNestedInput
    student?: StudentsUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type RegistrationsUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubjectsUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUpdateManyWithoutSubjectNestedInput
    workHours?: TeacherWorkHoursUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lessons?: LessonsUncheckedUpdateManyWithoutSubjectNestedInput
    workHours?: TeacherWorkHoursUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectsUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    coefficient?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesCreateManyStudentInput = {
    id?: number
    date?: string | null
    state?: string | null
    justification?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesCreateManyStudentInput = {
    id?: number
    lesson_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type RegistrationsCreateManyStudentInput = {
    id?: number
    class_id: number
    school_year?: string | null
    state?: string | null
    registration_date?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsCreateManyStudentInput = {
    id?: number
    parent_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type AttendancesUpdateWithoutStudentInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttendancesUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUpdateWithoutStudentInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson?: LessonsUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegistrationsUpdateWithoutStudentInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUpdateManyWithoutRegistrationNestedInput
    class?: ClassesUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type RegistrationsUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    payments?: PaymentsUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type RegistrationsUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUpdateWithoutStudentInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    parent?: ParentsUpdateOneRequiredWithoutStudent_parentsNestedInput
  }

  export type StudentParentsUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateManyRegistrationInput = {
    id?: number
    fee_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsUpdateWithoutRegistrationInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    fee?: FeesUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutRegistrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsUncheckedUpdateManyWithoutRegistrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fee_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsCreateManyTeacherInput = {
    id?: number
    class_id: number
    subject_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateManyTeacherInput = {
    id?: number
    subject_id?: number | null
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateWithoutTeacherInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneRequiredWithoutLessonsNestedInput
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    class_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUpdateWithoutTeacherInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    subject?: SubjectsUpdateOneWithoutWorkHoursNestedInput
  }

  export type TeacherWorkHoursUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesCreateManyLessonInput = {
    id?: number
    student_id: number
    value?: number | null
    type?: string | null
    quarter?: number | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SchedulesCreateManyLessonInput = {
    id?: number
    day_of_week?: string | null
    start_time?: string | null
    end_time?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type NotesUpdateWithoutLessonInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentsUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NotesUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotesUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    quarter?: NullableIntFieldUpdateOperationsInput | number | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUpdateWithoutLessonInput = {
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchedulesUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonsCreateManySubjectInput = {
    id?: number
    teacher_id?: number | null
    class_id: number
    school_year?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type TeacherWorkHoursCreateManySubjectInput = {
    id?: number
    teacher_id: number
    date?: string | null
    start_time?: string | null
    end_time?: string | null
    hours: number
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type LessonsUpdateWithoutSubjectInput = {
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassesUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeachersUpdateOneWithoutLessonsNestedInput
    notes?: NotesUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NotesUncheckedUpdateManyWithoutLessonNestedInput
    schedules?: SchedulesUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonsUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
    class_id?: IntFieldUpdateOperationsInput | number
    school_year?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUpdateWithoutSubjectInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeachersUpdateOneRequiredWithoutWorkHoursNestedInput
  }

  export type TeacherWorkHoursUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherWorkHoursUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsCreateManyParentInput = {
    id?: number
    student_id: number
    relation?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type StudentParentsUpdateWithoutParentInput = {
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentsUpdateOneRequiredWithoutStudent_parentsNestedInput
  }

  export type StudentParentsUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentsUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsCreateManyFeeInput = {
    id?: number
    registration_id?: number | null
    amount?: number | null
    method?: string | null
    date?: string | null
    reference?: string | null
    emitter_id?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type PaymentsUpdateWithoutFeeInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    registration?: RegistrationsUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutFeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentsUncheckedUpdateManyWithoutFeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    emitter_id?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsCreateManyEmployeeInput = {
    id?: number
    base_salary: number
    bonus_amount?: number
    total_amount: number
    payment_date: string
    notes?: string | null
    supabase_id?: string | null
    last_modified?: Date | string
    needs_sync?: boolean
    is_deleted?: boolean
  }

  export type SalaryPaymentsUpdateWithoutEmployeeInput = {
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SalaryPaymentsUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_salary?: FloatFieldUpdateOperationsInput | number
    bonus_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_modified?: DateTimeFieldUpdateOperationsInput | Date | string
    needs_sync?: BoolFieldUpdateOperationsInput | boolean
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}